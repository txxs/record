{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[408],{832:function(e,s,v){\"use strict\";v.r(s);var t=v(13),_=Object(t.a)({},(function(){var e=this,s=e.$createElement,v=e._self._c||s;return v(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[v(\"h1\",{attrs:{id:\"变基-rebase\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#变基-rebase\"}},[e._v(\"#\")]),e._v(\" 变基（rebase）\")]),e._v(\" \"),v(\"p\",[e._v(\"在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。 在本节中我们将学习什么是 \"),v(\"strong\",[e._v(\"变基\")]),e._v(\"，怎样使用 \"),v(\"strong\",[e._v(\"变基\")]),e._v(\"，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。\")]),e._v(\" \"),v(\"h2\",{attrs:{id:\"变基的基本操作\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#变基的基本操作\"}},[e._v(\"#\")]),e._v(\" 变基的基本操作\")]),e._v(\" \"),v(\"p\",[e._v(\"请回顾之前在 \"),v(\"RouterLink\",{attrs:{to:\"/git-scm/03/02.html#分支的合并\"}},[e._v(\"分支的合并\")]),e._v(\" 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。\")],1),e._v(\" \"),v(\"p\",[e._v(\"分叉的提交历史\")]),e._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"assets/e875f7dec5a1508138312db58d7ff196.png\",alt:\"分叉的提交历史。\"}})]),e._v(\" \"),v(\"p\",[e._v(\"之前介绍过，整合分支最容易的方法是 \"),v(\"code\",[e._v(\"merge\")]),e._v(\" 命令。 它会把两个分支的 \"),v(\"strong\",[e._v(\"最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并\")]),e._v(\"，合并的结果是生成一个新的快照（并提交）。\")]),e._v(\" \"),v(\"p\",[e._v(\"通过合并操作来整合分叉了的历史\")]),e._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"assets/fca19900777748b5f807dbd485aea3f4.png\",alt:\"通过合并操作来整合分叉了的历史。\"}})]),e._v(\" \"),v(\"p\",[e._v(\"其实，还有一种方法：你可以 \"),v(\"strong\",[e._v(\"提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次\")]),e._v(\"。 在 Git 中，这种操作就叫做 \"),v(\"em\",[e._v(\"变基\")]),e._v(\"。 你可以使用 rebase 命令 \"),v(\"strong\",[e._v(\"将提交到某一分支上的所有修改都移至另一分支上\")]),e._v(\"，就好像 「重新播放」一样。\")]),e._v(\" \"),v(\"p\",[e._v(\"在上面这个例子中，运行：\")]),e._v(\" \"),v(\"div\",{staticClass:\"language- line-numbers-mode\"},[v(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[v(\"code\",[e._v(\"$ git checkout experiment\\n$ git rebase master\\nFirst, rewinding head to replay your work on top of it...\\nApplying: added staged command\\n\")])]),e._v(\" \"),v(\"div\",{staticClass:\"line-numbers-wrapper\"},[v(\"span\",{staticClass:\"line-number\"},[e._v(\"1\")]),v(\"br\"),v(\"span\",{staticClass:\"line-number\"},[e._v(\"2\")]),v(\"br\"),v(\"span\",{staticClass:\"line-number\"},[e._v(\"3\")]),v(\"br\"),v(\"span\",{staticClass:\"line-number\"},[e._v(\"4\")]),v(\"br\")])]),v(\"p\",[e._v(\"它的原理是：\")]),e._v(\" \"),v(\"ol\",[v(\"li\",[e._v(\"首先找到这两个分支（\"),v(\"strong\",[e._v(\"即当前分支 experiment、变基操作的目标基底分支 master\")]),e._v(\"）的最近共同祖先 C2，\")]),e._v(\" \"),v(\"li\",[e._v(\"然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件\")]),e._v(\" \"),v(\"li\",[e._v(\"然后将当前分支指向目标基底 C3,\")]),e._v(\" \"),v(\"li\",[e._v(\"最后以此将之前另存为临时文件的修改依序应用。（译注：写明了 commit id，以便理解，下同）\")])]),e._v(\" \"),v(\"p\",[e._v(\"将 C4 中的修改变基到 C3 上\")]),e._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"assets/d096548d5415a26f031fad67042bf896.png\",alt:\"将  中的修改变基到  上。\"}})]),e._v(\" \"),v(\"p\",[e._v(\"现在回到 master 分支，进行一次快进合并。\")]),e._v(\" \"),v(\"div\",{staticClass:\"language- line-numbers-mode\"},[v(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[v(\"code\",[e._v(\"$ git checkout master\\n$ git merge experiment\\n\")])]),e._v(\" \"),v(\"div\",{staticClass:\"line-numbers-wrapper\"},[v(\"span\",{staticClass:\"line-number\"},[e._v(\"1\")]),v(\"br\"),v(\"span\",{staticClass:\"line-number\"},[e._v(\"2\")]),v(\"br\")])]),v(\"p\",[e._v(\"master 分支的快进合并\")]),e._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"assets/092ab3724f00f68bda4846c17d305b56.png\",alt:\"master 分支的快进合并。\"}})]),e._v(\" \"),v(\"p\",[e._v(\"此时，C4′ 指向的快照就和上面使用 merge 命令的例子中 C5 指向的快照一模一样了。 \"),v(\"strong\",[e._v(\"这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁\")]),e._v(\"。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。\")]),e._v(\" \"),v(\"p\",[v(\"strong\",[e._v(\"一般我们这样做的目的\")]),e._v(\" 是为了 \"),v(\"strong\",[e._v(\"确保在向远程分支推送时能保持提交历史的整洁\")]),e._v(\"——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 \"),v(\"code\",[e._v(\"origin/master\")]),e._v(\" 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。\")]),e._v(\" \"),v(\"p\",[e._v(\"请注意，无论是 \"),v(\"strong\",[e._v(\"通过变基\")]),e._v(\"，还是 \"),v(\"strong\",[e._v(\"通过三方合并\")]),e._v(\"，\"),v(\"strong\",[e._v(\"整合的最终结果所指向的快照始终是一样的\")]),e._v(\"，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。\")]),e._v(\" \"),v(\"h3\",{attrs:{id:\"小结\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#小结\"}},[e._v(\"#\")]),e._v(\" 小结\")]),e._v(\" \"),v(\"p\",[e._v(\"变基中用到了 merge 中的 「快进 -> 不产生新的提交」和「三方合并 -> 产生新的提交」的知识点，步骤如下：\")]),e._v(\" \"),v(\"p\",[e._v(\"在 C2 提交点前有：\"),v(\"code\",[e._v(\"C0 -> C1\")]),e._v(\" 提交\")]),e._v(\" \"),v(\"ol\",[v(\"li\",[v(\"p\",[e._v(\"基于 master 的 C2 提交 \"),v(\"strong\",[e._v(\"创建了 B 分支\")]),e._v(\"，\"),v(\"strong\",[e._v(\"并提交了 C3\")])]),e._v(\" \"),v(\"p\",[e._v(\"此时当前分支提交历史为：\"),v(\"code\",[e._v(\"C0 -> C1 -> C2 -> C3\")])])]),e._v(\" \"),v(\"li\",[v(\"p\",[e._v(\"在 master 分支上 \"),v(\"strong\",[e._v(\"提交了 C4\")])]),e._v(\" \"),v(\"p\",[e._v(\"此时当前分支提交历史为：\"),v(\"code\",[e._v(\"C0 -> C1 -> C2 -> C4\")])])]),e._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[e._v(\"回到 B 分支\")]),e._v(\"，执行变基操作，基于 master 分支进行变基\")]),e._v(\" \"),v(\"p\",[e._v(\"此时当前分支提交历史为：\"),v(\"code\",[e._v(\"C0 -> C1 -> C2 -> C4 -> C3\")])])]),e._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[e._v(\"回到 master 分支\")]),e._v(\"，将 B 分支合并回来\")]),e._v(\" \"),v(\"p\",[e._v(\"此时由于 B 分支的提交历史 C3 的上游就是 master 的最新节点，所以在进行合并的时候，会产生「快进 -> 不产生新的提交」\")])])]),e._v(\" \"),v(\"h2\",{attrs:{id:\"更有趣的变基例子\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#更有趣的变基例子\"}},[e._v(\"#\")]),e._v(\" 更有趣的变基例子\")]),e._v(\" \"),v(\"p\",[e._v(\"在对两个分支进行变基时，所生成的「重放」并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。就像下图这样。 你创建了一个特性分支 server，为服务端添加了一些功能，提交了 C3 和 C4。 然后从 C3 上创建了特性分支 client，为客户端添加了一些功能，提交了 C8 和 C9。 最后，你回到 server 分支，又提交了 C10。\")]),e._v(\" \"),v(\"p\",[e._v(\"从一个特性分支里再分出一个特性分支的提交历史\")]),e._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"assets/b02fec3b5b459d25c56a79462b5e2a97.png\",alt:\"从一个特性分支里再分出一个特性分支的提交历史。\"}})]),e._v(\" \"),v(\"p\",[v(\"strong\",[e._v(\"假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改，因为它们还需要经过更全面的测试\")]),e._v(\"。 这时，你就可以使用 \"),v(\"code\",[e._v(\"git rebase\")]),e._v(\" 命令的 \"),v(\"code\",[e._v(\"–onto\")]),e._v(\" 选项， **选中在 client 分支里 ** 但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：\")]),e._v(\" \"),v(\"div\",{staticClass:\"language- line-numbers-mode\"},[v(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[v(\"code\",[e._v(\"git rebase --onto master server client\\n\")])]),e._v(\" \"),v(\"div\",{staticClass:\"line-numbers-wrapper\"},[v(\"span\",{staticClass:\"line-number\"},[e._v(\"1\")]),v(\"br\")])]),v(\"p\",[e._v(\"以上命令的意思是：取出 client 分支，找出处于 client 分支和 server 分支的共同祖先之后的修改，然后把它们在 master 分支上重放一遍。 这理解起来有一点复杂，不过效果非常酷。\")]),e._v(\" \"),v(\"p\",[e._v(\"截取特性分支上的另一个特性分支，然后变基到其他分支\")]),e._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"assets/1959c134329ece31f68b7229dbca855f.png\",alt:\"截取特性分支上的另一个特性分支，然后变基到其他分支。\"}})]),e._v(\" \"),v(\"p\",[e._v(\"现在可以快进合并 master 分支了。\")]),e._v(\" \"),v(\"div\",{staticClass:\"language- line-numbers-mode\"},[v(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[v(\"code\",[e._v(\"$ git checkout master\\n$ git merge client\\n\")])]),e._v(\" \"),v(\"div\",{staticClass:\"line-numbers-wrapper\"},[v(\"span\",{staticClass:\"line-number\"},[e._v(\"1\")]),v(\"br\"),v(\"span\",{staticClass:\"line-number\"},[e._v(\"2\")]),v(\"br\")])]),v(\"p\",[e._v(\"快进合并 master 分支，使之包含来自 client 分支的修改\")]),e._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"assets/cb15a0a36d17dd6018f5b61bbb08e682.png\",alt:\"快进合并 master 分支，使之包含来自 client 分支的修改。\"}})]),e._v(\" \"),v(\"p\",[e._v(\"接下来你决定将 server 分支中的修改也整合进来。 使用 \"),v(\"code\",[e._v(\"git rebase [basebranch] [topicbranch]\")]),e._v(\"  命令可以直接将特性分支（即本例中的 server）变基到目标分支（即 master）上。这样做能省去你先切换到 server 分支，再对其执行变基命令的多个步骤。\")]),e._v(\" \"),v(\"div\",{staticClass:\"language- line-numbers-mode\"},[v(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[v(\"code\",[e._v(\"$ git rebase master server\\n\")])]),e._v(\" \"),v(\"div\",{staticClass:\"line-numbers-wrapper\"},[v(\"span\",{staticClass:\"line-number\"},[e._v(\"1\")]),v(\"br\")])]),v(\"p\",[v(\"img\",{attrs:{src:\"assets/f1bafebaa9c1d94f57e5a6d1f5e39968.png\",alt:\"将 server 中的修改变基到 master 上。\"}})]),e._v(\" \"),v(\"p\",[e._v(\"如图所示，server 中的代码被「续」到了 master 上\")]),e._v(\" \"),v(\"p\",[e._v(\"然后就可以快进合并主分支 master 了：\")]),e._v(\" \"),v(\"div\",{staticClass:\"language- line-numbers-mode\"},[v(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[v(\"code\",[e._v(\"$ git checkout master\\n$ git merge server\\n\")])]),e._v(\" \"),v(\"div\",{staticClass:\"line-numbers-wrapper\"},[v(\"span\",{staticClass:\"line-number\"},[e._v(\"1\")]),v(\"br\"),v(\"span\",{staticClass:\"line-number\"},[e._v(\"2\")]),v(\"br\")])]),v(\"p\",[e._v(\"至此，client 和 server 分支中的修改都已经整合到主分支里了，你可以删除这两个分支，最终提交历史会变成图 最终的提交历史 中的样子：\")]),e._v(\" \"),v(\"div\",{staticClass:\"language- line-numbers-mode\"},[v(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[v(\"code\",[e._v(\"$ git branch -d client\\n$ git branch -d server\\n\")])]),e._v(\" \"),v(\"div\",{staticClass:\"line-numbers-wrapper\"},[v(\"span\",{staticClass:\"line-number\"},[e._v(\"1\")]),v(\"br\"),v(\"span\",{staticClass:\"line-number\"},[e._v(\"2\")]),v(\"br\")])]),v(\"p\",[e._v(\"最终的提交历史\")]),e._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"assets/b1a6034861f894323bca6b407ed8b86d.png\",alt:\"最终的提交历史。\"}})]),e._v(\" \"),v(\"h2\",{attrs:{id:\"变基的风险\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#变基的风险\"}},[e._v(\"#\")]),e._v(\" 变基的风险\")]),e._v(\" \"),v(\"p\",[e._v(\"呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：\"),v(\"strong\",[e._v(\"不要对在你的仓库外有副本的分支执行变基。\")])]),e._v(\" \"),v(\"p\",[e._v(\"如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。\")]),e._v(\" \"),v(\"p\",[v(\"strong\",[e._v(\"变基操作的实质是丢弃一些现有的提交\")]),e._v(\"，然后相应地 \"),v(\"strong\",[e._v(\"新建一些内容一样但实际上不同的提交\")]),e._v(\"。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 \"),v(\"code\",[e._v(\"git rebase\")]),e._v(\" 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。\")]),e._v(\" \"),v(\"p\",[e._v(\"让我们来看一个 \"),v(\"strong\",[e._v(\"在公开的仓库上执行变基操作所带来的问题\")]),e._v(\"。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：\")]),e._v(\" \"),v(\"p\",[e._v(\"克隆一个仓库，然后在它的基础上进行了一些开发\")]),e._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"assets/c5be80cc767dae1ff36daff6a9dbb690.png\",alt:\"克隆一个仓库，然后在它的基础上进行了一些开发。\"}})]),e._v(\" \"),v(\"p\",[e._v(\"然后，\"),v(\"strong\",[e._v(\"某人又向中央服务器提交了一些修改，其中还包括一次合并\")]),e._v(\"。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：\")]),e._v(\" \"),v(\"p\",[e._v(\"抓取别人的提交，合并到自己的开发分支\")]),e._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"assets/7b9a68acdc930fcec930b877c078cd32.png\",alt:\"抓取别人的提交，合并到自己的开发分支。\"}})]),e._v(\" \"),v(\"p\",[e._v(\"接下来，这个人又 \"),v(\"strong\",[e._v(\"决定把合并操作回滚\")]),e._v(\"，\"),v(\"strong\",[e._v(\"改用变基\")]),e._v(\"；继而又用 \"),v(\"code\",[e._v(\"git push –force\")]),e._v(\" 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。\")]),e._v(\" \"),v(\"p\",[e._v(\"有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交\")]),e._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"assets/ec510dc22178106bbef8c5f7c31b40f8.png\",alt:\"有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交。\"}})]),e._v(\" \"),v(\"p\",[e._v(\"结果就是你们两人的处境都十分尴尬。 如果你执行 \"),v(\"code\",[e._v(\"git pull\")]),e._v(\" 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：\")]),e._v(\" \"),v(\"p\",[e._v(\"你将相同的内容又合并了一次，生成了一个新的提交\")]),e._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"assets/d944f6d73579344313d2a6b1341b0de9.png\",alt:\"你将相同的内容又合并了一次，生成了一个新的提交。\"}})]),e._v(\" \"),v(\"p\",[e._v(\"此时如果你执行 \"),v(\"code\",[e._v(\"git log\")]),e._v(\" 命令，你会发现有 \"),v(\"strong\",[e._v(\"两个提交的作者、日期、日志居然是一样的\")]),e._v(\"，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 C4 和 C6，因为之前就是他把这两个提交通过变基丢弃的。\")]),e._v(\" \"),v(\"h2\",{attrs:{id:\"用变基解决变基\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#用变基解决变基\"}},[e._v(\"#\")]),e._v(\" 用变基解决变基\")]),e._v(\" \"),v(\"p\",[e._v(\"如果你 \"),v(\"strong\",[e._v(\"真的\")]),e._v(\" 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。\")]),e._v(\" \"),v(\"p\",[e._v(\"实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和—— 即 「patch-id」。\")]),e._v(\" \"),v(\"p\",[e._v(\"如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。\")]),e._v(\" \"),v(\"p\",[e._v(\"举个例子，如果遇到前面提到的 「有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交」那种情境，如果我们不是执行合并，而是执行 \"),v(\"code\",[e._v(\"git rebase teamone/master\")]),e._v(\", Git 将会：\")]),e._v(\" \"),v(\"ul\",[v(\"li\",[e._v(\"检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）\")]),e._v(\" \"),v(\"li\",[e._v(\"检查其中哪些提交不是合并操作的结果（C2，C3，C4）\")]),e._v(\" \"),v(\"li\",[e._v(\"检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4’）\")]),e._v(\" \"),v(\"li\",[e._v(\"把查到的这些提交应用在 teamone/master 上面\")])]),e._v(\" \"),v(\"p\",[e._v(\"从而我们将得到与 「你将相同的内容又合并了一次，生成了一个新的提交」 中不同的结果，如图\")]),e._v(\" \"),v(\"p\",[e._v(\"在一个被变基然后强制推送的分支上再次执行变基\")]),e._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"assets/b3023bc16ceab1b938bb3183b1f7d449.png\",alt:\"在一个被变基然后强制推送的分支上再次执行变基。\"}})]),e._v(\" \"),v(\"p\",[v(\"strong\",[e._v(\"要想上述方案有效，还需要对方在变基时确保 C4′ 和 C4 是几乎一样的\")]),e._v(\"。 否则变基操作将无法识别，并新建另一个类似 C4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。\")]),e._v(\" \"),v(\"p\",[e._v(\"在本例中另一种简单的方法是使用 \"),v(\"code\",[e._v(\"git pull –rebase\")]),e._v(\"  命令而不是直接 \"),v(\"code\",[e._v(\"git pull\")]),e._v(\"。 又或者你可以自己手动完成这个过程，先 \"),v(\"code\",[e._v(\"git fetch\")]),e._v(\"，再 \"),v(\"code\",[e._v(\"git rebase teamone/master\")]),e._v(\"。\")]),e._v(\" \"),v(\"p\",[e._v(\"如果你习惯使用 \"),v(\"code\",[e._v(\"git pull\")]),e._v(\" ，同时又希望默认使用选项 \"),v(\"code\",[e._v(\"–rebase\")]),e._v(\"，你可以执行这条语句 \"),v(\"code\",[e._v(\"git config –global pull.rebase true\")]),e._v(\" 来更改 \"),v(\"code\",[e._v(\"pull.rebase\")]),e._v(\" 的默认配置。\")]),e._v(\" \"),v(\"p\",[v(\"strong\",[e._v(\"只要你把变基命令当作是在推送前清理提交使之整洁的工具\")]),e._v(\"，并且 \"),v(\"strong\",[e._v(\"只在从未推送至共用仓库的提交上执行变基命令，就不会有事\")]),e._v(\"。 假如在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那你就有大麻烦了，你的同事也会因此鄙视你。\")]),e._v(\" \"),v(\"p\",[e._v(\"如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 \"),v(\"code\",[e._v(\"git pull –rebase\")]),e._v(\" 命令，这样尽管不能避免伤痛，但能有所缓解。\")]),e._v(\" \"),v(\"h2\",{attrs:{id:\"变基-vs-合并\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#变基-vs-合并\"}},[e._v(\"#\")]),e._v(\" 变基 vs. 合并\")]),e._v(\" \"),v(\"p\",[e._v(\"至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。\")]),e._v(\" \"),v(\"p\",[e._v(\"有一种观点认为，仓库的提交历史即是 \"),v(\"strong\",[e._v(\"记录实际发生过什么\")]),e._v(\"。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用_谎言_掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。\")]),e._v(\" \"),v(\"p\",[e._v(\"另一种观点则正好相反，他们认为提交历史是 \"),v(\"strong\",[e._v(\"项目过程中发生的事\")]),e._v(\"。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 \"),v(\"code\",[e._v(\"rebase\")]),e._v(\" 及 \"),v(\"code\",[e._v(\"filter-branch\")]),e._v(\" 等工具来编写故事，怎么方便后来的读者就怎么写。\")]),e._v(\" \"),v(\"p\",[e._v(\"现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。\")]),e._v(\" \"),v(\"p\",[v(\"strong\",[e._v(\"总的原则是\")]),e._v(\"，\"),v(\"strong\",[e._v(\"只对尚未推送或分享给别人的本地修改执行变基操作清理历史\")]),e._v(\"，从不对已推送至别处的提交执行变基操作，这样，\"),v(\"strong\",[e._v(\"你才能享受到两种方式带来的便利\")]),e._v(\"。\")])])}),[],!1,null,null,null);s.default=_.exports}}]);","extractedComments":[]}