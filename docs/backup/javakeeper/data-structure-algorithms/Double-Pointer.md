这一专题我们介绍在数组和链表的问题里经常考察的两类问题：「滑动窗口」和「双指针」，其实「滑动窗口」也可以称为「双指针」，我们在这个专题里会着重介绍这两类题型的思考路径。

我们在学习它们之前，我们先向大家介绍「循环不变量」。



## 循环不变量

循环前、中、后保持不变

「循环不变量」不是很高深的概念，在「算法」和「数据结构」的世界里，到处都有它的身影。

「循环不变量」是指我们在编写代码的过程中，要一直循序不变的性质，这样的性质是根据要解决的问题，由我们自己定义的。「循环不变量」是我们写对一个问题的基础，保证了在「初始化」「循环遍历」「结束」这三个阶段相同的性质，使得一个问题能够被正确解决。



### 例题：删除有序数组中的重复项

> 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。
>
> 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
>
> 说明:
>
> 为什么返回数值是整数，但输出的答案是数组呢?
>
> 请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
>
> 你可以想象内部操作如下:
>
> ```java
> // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
> int len = removeDuplicates(nums);
> // 在函数里修改输入数组对于调用者是可见的。
> // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
> for (int i = 0; i < len; i++) {
>     print(nums[i]);
> }
> ```
>
> ```
> 输入：nums = [1,1,2]
> 输出：2, nums = [1,2]
> 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
> ```
>
> ```
> 输入：nums = [0,0,1,1,1,2,2,3,3,4]
> 输出：5, nums = [0,1,2,3,4]
> 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
> ```


**思路分析**：这个问题并不难，相信大家一定可以独立做出来。我们给出两种写法，两种写法里 i 都是用于遍历的下标，而 j 的含义不同，请大家分别比较两者代码的差异。

**定义 1**：j 指向马上要赋值的元素的下标，因此我们定义区间 [0..j) （注意是左闭右开区间，j 不能取到）里没有重复元素。pre 永远指向第 1 个不重复的数字；

- 初始化：为了保证区间 [0..j) （注意这里是左闭右开区间）里没有重复元素。初始的时候，i = 0 ，下标为 0 的位置只有一个数，区间 [0..j) 一定不会出现重复，这件事情表示为区间 [0..0] 没有重复数字，即区间 [0..1) 没有重复数字，因此 j 初始化的时候需要等于 1；
- 保持：遇到和 pre 指向的数字相等元素，i++ 直接看到下一个元素，如果 nums[i] != pre ，表示程序看到了第 1 个不重复的数字，此时需要赋值 nums[j] = nums[i] 和 pre = nums[j] ，然后让 j++ 指向下一个需要赋值的下标；
- 终止：循环结束以后 i = len ，程序看完了输入数组的所有元素，此时区间 [0..j) 里没有重复元素，它的长度为 j ，返回 j。

参考代码 1：

```java
public int removeDuplicates(int[] nums) {
    int len = nums.length;
    if (len < 2) {
        return len;
    }
    int j = 1;
    int pre = nums[0];
    for (int i = 1; i < len; i++) {
        if (nums[i] != pre) {
            nums[j] = nums[i];
            pre = nums[j];
            j++;
        }
    }
    return j;
}
```

**定义 2**：我们定义：区间 [0..j] （注意这里是左闭右闭区间）没有出现重复元素，此时变量 j 是上一轮找到的第 1 次出现的元素的下标。因此我们不需要像「定义 1」一样给 pre 定义。循环变量 i 看到的数值 nums[i] 永远和变量 j 看到的数值 nums[j] 进行比较。 大家可以对照上面的「定义 1」自行写出「初始化」「保持」「终止」的逻辑。

参考代码 2：

```java
public int removeDuplicates(int[] nums) {
    int len = nums.length;
    if (len < 2) {
        return len;
    }
    int j = 0;
    for (int i = 1; i < len; i++) {
        if (nums[i] != nums[j]) {
            j++;
            nums[j] = nums[i];
        }
    }
    return j + 1;
}
```

复杂度分析：

- 时间复杂度：O(N)，这里数组的长度是 N， i 和 j 分别最多走 N 步；
- 空间复杂度：O(1)。



### 例题：最长连续递增序列

> 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。
>
> 连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。
>
> ```
> 输入：nums = [1,3,5,4,7]
> 输出：3
> 解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
> ```

思路分析：题目要求我们找的子序列是 连续 的，并且子序列里的元素要求 严格单调递增。在遍历的时候，从第 2 个元素开始；

如果当前遍历到的元素比它左边的那一个元素要严格大，「连续递增」的长度就加 11；
否则「连续递增」的起始位置就需要重新开始计算。
我们给出了两版参考代码，分别对应了不同的循环不变量。请大家体会它们的不同。

参考代码 1：

```java
public int findLengthOfLCIS(int[] nums) {
    int len = nums.length;
    int res = 0;
    int i = 0;
    int j = 0;
    // 循环不变量 [i..j) 严格单调递增
    while (j < len) {
        if (j > 0 && nums[j - 1] >= nums[j]) {
            i = j;
        }
        j++;
        res = Math.max(res, j - i);
    }
    return res;
}
```

说明：这一版代码循环不变量为：[i..j) 严格单调递增，初始化的时候 i = 0，j = 0 ，空区间符合严格单调递增的定义。j 左边的元素表示程序已经看到，所以先 j++，计算严格单调递增的区间的长度的时候，长度为 j - i。

参考代码 2：

```java
public int findLengthOfLCIS(int[] nums) {
    int len = nums.length;
    int res = 0;
    int i = 0;
    int j = 0;
    // 循环不变量 [i..j] 严格单调递增
    while (j < len) {
        if (j > 0 && nums[j - 1] >= nums[j]) {
            i = j;
        }
        res = Math.max(res, j - i + 1);
        j++;
    }
    return res;
}
```
说明：这一版代码循环不变量为：[i..j] 严格单调递增，初始化的时候 i = 0，j = 0 ，只有一个元素的区间符合严格单调递增的定义。j 的含义与「参考代码 1」不同，j 以及 j 左边的元素表示程序已经看到，所以先计算区间的长度 j - i + 1，然后 j++。

复杂度分析：

时间复杂度：O(N)，其中 N 是数组 nums 的长度，程序需要遍历数组一次；

空间复杂度：O(1)。额外使用的空间为常数。



### 总结

区间不同的定义决定了不同的初始化逻辑、遍历过程中的逻辑。

- 移除元素
- 删除排序数组中的重复项 II
- 移动零



## 使用循环不变量写对代码

这一节我们讲解两个非常基础且常考的问题，向大家展示：我们在写代码的时候一定要明确自己对变量以及区间的定义是什么，并且在编写代码的过程中保持定义不变。

https://leetcode-cn.com/leetbook/read/sliding-window-and-two-pointers/rl5i7m/











#### [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。
>
> 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
>
> ```
> 输入：s = ["h","e","l","l","o"]
> 输出：["o","l","l","e","h"]
> ```

**思路**：双指针

1. 将 left 指向字符数组首元素，right 指向字符数组尾元素。
2. 当 left < right：
   - 交换 s[left] 和 s[right]；
   - left 指针右移一位，即 left = left + 1；
   - right 指针左移一位，即 right = right - 1。
3. 当 left >= right，反转结束，返回字符数组即可。

```java
public void reverseString(char[] s) {
  int n = s.length;
  for (int left = 0, right = n - 1; left < right; ++left, --right) {
    char tmp = s[left];
    s[left] = s[right];
    s[right] = tmp;
  }
}
```



#### [557. 反转字符串中的单词 III](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)

> 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。
>
> ```
> 输入："Let's take LeetCode contest"
> 输出："s'teL ekat edoCteeL tsetnoc"
> ```

思路：开辟一个新字符串。然后从头到尾遍历原字符串，直到找到空格为止，此时找到了一个单词，并能得到单词的起止位置。随后，根据单词的起止位置，可以将该单词逆序放到新字符串当中。如此循环多次，直到遍历完原字符串，就能得到翻转后的结果。

```java
public String reverseWords(String s) {
  StringBuffer ret = new StringBuffer();
  int length = s.length();
  int i = 0;
  while (i < length) {
    int start = i;
    while (i < length && s.charAt(i) != ' ') {
      i++;
    }
    for (int p = start; p < i; p++) {
      ret.append(s.charAt(start + i - 1 - p));
    }
    while (i < length && s.charAt(i) == ' ') {
      i++;
      ret.append(' ');
    }
  }
  return ret.toString();
}
```

