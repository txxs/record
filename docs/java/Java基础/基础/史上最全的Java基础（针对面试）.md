# 前言
>文本已收录至我的GitHub仓库，欢迎Star：https://github.com/bin392328206/six-finger                             
> **种一棵树最好的时间是十年前，其次是现在**   
>我知道很多人不玩**qq**了,但是怀旧一下,欢迎加入六脉神剑Java菜鸟学习群，群聊号码：**549684836** 鼓励大家在技术的路上写博客

## 絮叨 
> 写Java基础的原因，第一个就是想好好复习一下Java,因为再工作中很多东西都是CV大法，工作过的都知道，然后大学 就 哈哈，感觉就是没读过一样（非本专业），就借这个机会一边写文章，一边把自己的基本打好，其实就是总结拉。   

> 还有我这个不是针对0基础学Java的，可能不会讲那么细。这个系列就是跟大家一起总结一些面试题和一些平时没注意到的地方 下面是我再我工位上拍的照片，我就一边看书，一边写。。上班。。你们懂的。。。


![](https://user-gold-cdn.xitu.io/2019/12/4/16ed04f5a6c890fb?w=3024&h=4032&f=jpeg&s=634958)

> 还记得书是当时当当买的 250 买了10来本(便宜) 哈哈，终于有机会，那就好好啃啃吧


##  什么是 Java 虚拟机（JVM）？为什么 Java 被称作是“平台无关的编程语言”？
> Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚拟机执行的字节码文件。 
Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。

## JDK、JRE、JVM 分别是什么关系？
> JDK 即为 Java 开发工具包，包含编写 Java 程序所必须的编译、运行等开发工具以及 JRE。开发工具如：用于编译 Java 程序的 javac 命令、用于启动 JVM 运行 Java 程序的 Java 命令、用于生成文档的 Javadoc 命令以及用于打包的 jar 命令等等。 

> JRE 即为 Java 运行环境，提供了运行 Java 应用程序所必须的软件环境，包含有 Java 虚拟机（JVM）和丰富的系统类库。系统类库即为 Java 提前封装好的功能类，只需拿来直接使用即可，可以大大的提高开发效率。

> JVM 即为 Java 虚拟机，提供了字节码文件（.class）的运行环境支持。 简单说，就是 JDK 包含 JRE 包含 JVM。

##  Java 支持的数据类型有哪些？

Java 支持的数据类型包括基本数据类型和引用类型。基本数据类型如下。

整数值型：byte(1个字节)，short(2个字节)，int(4个字节)，long(8个字节) 

字符型：char(2个字节) 

浮点类型：float(4个字节)，double (8个字节)

布尔型：boolean(没有明确说明)

整数默认 int 型，小数默认是 double 型。Float 和 long 类型的必须加后缀。比如 float f = 100f。 

首先知道 String 是引用类型不是基本类型，引用类型声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。引用类型包括类、接口、数组等。String 类还是 final 修饰的。


## 什么是自动拆装箱？

自动装箱和拆箱就是基本类型和引用类型之间的转换，至于为什么要转换，因为基本类型转换为引用类型后，就可以 new 对象，从而调用包装类中封装好的方法进行基本类型之间的转换或者 toString（当然用类名直接调用也可以，便于一眼看出该方法是静态的），还有就是如果集合中想存放基本类型，泛型的限定类型只能是对应的包装类型。

## 什么是面向对象？

面向对象是一种思想，世间万物都可以看做一个对象，这里只讨论面向对象编程（OOP），Java 是一个支持并发、基于类和面向对象的计算机编程语言，面向对象软件开发具有以下优点：代码开发模块化，更易维护和修改；代码复用性强；增强代码的可靠性和灵活性；增加代码的可读性。

## 面向对象的特征
- 封装
 
  > 封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
- 继承

    > 面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。


- 多态

    > 多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。 实现多态，有二种方式，覆盖，重载。

## & 与 && 的区别？
& 运算符有两种用法：(1) 按位与，(2) 逻辑与。&& 运算符是短路与运算。

逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是 true。&& 之所以称为短路运算是因为，如果 && 左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。

 很多时候我们可能都需要用 && 而不是 &，例如在验证用户登录时判定用户名不是 null 而且不是空字符串，应当写为：

1username != null && !username.equals(“”)

二者的顺序不能交换，更不能用 & 运算符，因为第一个条件如果不成立，根本不能进行字符串的 equals 比较，否则会产生 NullPointerException 异常。

注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。

## 什么是值传递和引用传递？
值传递是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。

引用传递一般是对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身。一般认为，Java 内的传递都是值传递，Java 中实例对象的传递是引用传递。  **值得注意的一个点是Java的String 也是值传递，博主亲测，不信的可以自己试试**

##  是否可以在 static 环境中访问非 static 变量？

static 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机载入的时候，会对 static 变量进行初始化。如果你的代码尝试不用实例来访问非 static 的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。   

## Java 中的方法覆盖（Overriding）和方法重载（Overloading）是什么意思？
Java 中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。

## Java 支持多继承么？ 
Java 中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是 Java 中的接口支持多继承，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。 

## Java 中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？
当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java 编译器会为这个类创建一个默认的构造方法。

Java 中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。 

Java 不支持像 C++ 中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java 不会创建默认的复制构造方法。

##  接口和抽象类的区别是什么？
从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。 

Java 提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于： 接口中所有的方法隐含的都是抽象的，而抽象类则可以同时包含抽象和非抽象的方法。 

类可以实现很多个接口，但是只能继承一个抽象类。类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。 

抽象类可以在不提供接口方法实现的情况下实现接口。 Java 接口中声明的变量默认都是 final 的。抽象类可以包含非 final 的变量。Java 接口中的成员函数默认是 public 的。抽象类的成员函数可以是 private，protected 或者是 public。 

接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含 main 方法的话是可以被调用的。也可以参考 JDK8 中抽象类和接口的区别。

## final, finally, finalize 的区别
- final: 用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承.
- finally:是异常处理语句结构的一部分，表示总是执行.
- finalize: 是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用.

## 用最有效率的方法计算 2 乘以 8？
 2 << 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。
 
 ## String和StringBuilder、StringBuffer的区别？
 Java 平台提供了两种类型的字符串：String 和 StringBuffer/StringBuilder，它们可以储存和操作字符串。

其中 String 是只读字符串，也就意味着  String 引用的字符串内容是不能被改变的。

而 StringBuffer/StringBuilder 类表示的字符串对象可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被 synchronized 修饰，因此它的效率也比 StringBuffer 要高。

## 说说反射的用途及实现
Java 反射机制是一个非常强大的功能，在很多的项目比如 Spring，MyBatis 都都可以看到反射的身影。通过反射机制，我们可以在运行期间获取对象的类型信息。利用这一点我们可以实现工厂模式和代理模式等设计模式，同时也可以解决 Java 泛型擦除等令人苦恼的问题。

获取一个对象对应的反射类，在 Java 中有下列方法可以获取一个对象的反射类

- 通过 getClass() 方法
- 通过 Class.forName() 方法
- 使用 类.class
- 通过类加载器实现，getClassLoader()
## 说说自定义注解的场景及实现
登陆、权限拦截、日志处理，以及各种 Java 框架，如 Spring，Hibernate，JUnit 提到注解就不能不说反射，Java 自定义注解是通过运行时靠反射获取注解。实际开发中，例如我们要获取某个方法的调用日志，可以通过 AOP（动态代理机制）给方法添加切面，通过反射来获取方法包含的注解，如果包含日志注解，就进行日志记录。反射的实现在 Java 应用层面上讲，是通过对 Class 对象的操作实现的，Class 对象为我们提供了一系列方法对类进行操作。在 JVM 这个角度来说，Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目按严格的顺序紧凑的排列在 Class 文件中，里面包含了类、方法、字段等等相关数据。通过对 Class 数据流的处理我们即可得到字段、方法等数据。

## equals 与 == 的区别
- == 与equals 的主要区别是：== 常用于比较原生类型，而 equals() 方法用于检查对象的相等性。
- 另一个不同的点是：如果 == 和 equals() 用于比较对象，当两个引用地址相同，== 返回 true。而 equals() 可以返回 true 或者 false 主要取决于重写实现。最常见的一个例子，字符串的比较，不同情况 == 和 equals() 返回不同的结果。

## HTTP 请求的 GET 与 POST 方式的区别
根据 HTTP 规范，GET 用于信息获取，而且应该是安全的和幂等的。
根据 HTTP 规范，POST 表示可能修改变服务器上的资源的请求。
首先是 "GET 方式提交的数据最多只能是 1024 字节"，因为 GET 是通过 URL 提交数据，那么 GET 可提交的数据量就跟 URL 的长度有直接关系了。而实际上，URL 不存在参数上限的问题，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE 对 URL 长度的限制是 2083 字节(2K+35)。对于其他浏览器，如 Netscape、FireFox 等，理论上没有长度限制，其限制取决于操作系统的支持。注意这是限制是整个 URL 长度，而不仅仅是你的参数值数据长度。
POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制

## 结尾
> 这个Java基础，算是针对面试的，没有讲很细，也有很多没讲。接下来就是 **容器**，**I/O**，**泛型，反射**，**线程**，等等 这些是按专题讲的，会讲的很细的。

> 因为博主也是一个开发萌新 我也是一边学一边写 我有个目标就是一周 二到三篇 希望能坚持个一年吧 希望各位大佬多提意见，让我多学习，一起进步。
## 日常求赞
> 好了各位，以上就是这篇文章的全部内容了，能看到这里的人呀，都是**人才**。

> 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见

>六脉神剑 | 文 【原创】如果本篇博客有任何错误，请批评指教，不胜感激 ！
