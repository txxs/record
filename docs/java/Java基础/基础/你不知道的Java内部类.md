# 前言
>文本已收录至我的GitHub仓库，欢迎Star：https://github.com/bin392328206/six-finger                             
> **种一棵树最好的时间是十年前，其次是现在**   
>我知道很多人不玩**qq**了,但是怀旧一下,欢迎加入六脉神剑Java菜鸟学习群，群聊号码：**549684836** 鼓励大家在技术的路上写博客
## 絮叨 
> 看了很多源码，都有用到内部类，但是自己以前在生产环境上，用的确实少，也有用过但是很少，所以今天就打算好好的把它从头到尾的过一遍。  
>可能我写文章有点乱，但是我是发现自己少了啥，我就补啥，如果是写系列的话，就肯定是从头到尾的

## 定义
可以将一个类的定义放在里另一个类的内部，这就是内部类，所谓的内部类的概念只是出现在编译阶段，对于jvm层是没有内部类这个概念的。我们可以利用内部类来解决
- 类的单继承问题，外部类不能再继承的类可以交给内部类继承
- 我们可以通过定义内部类来实现一个类私属于一个类，实现更好的封装性
- 代码优化：它需要更少的代码
## 分类
内部类可以分为：
- 静态内部类。
- 非静态内部类。

非静态内部类又可以分为：
- 成员内部类。
- 方法内部类。
- 匿名内部类。

## 静态内部类

我感觉这个是用的最多的，你比如说Redis的key的设计， 因为我们要中间拼接：号，所以用静态内部类去组成不同的key是非常好的，这样可以让相同类型的key再同一个文件目录下

![](https://user-gold-cdn.xitu.io/2019/12/11/16ef446299d6d34b?w=859&h=678&f=png&s=75485)

静态内部类的定义和普通的静态变量或者静态方法的定义方法是一样的，使用static关键字，只不过这次static是修饰在class上的，一般而言，只有静态内部类才允许使用static关键字修饰，普通类的定义是不能用static关键字修饰的，这一点需要注意一下。下面定义一个静态内部类：

```
public class Out {
    private static String name;
    private int age;

    public static class In{
        private int age;
        public void sayHello(){
            
            System.out.println("my name is : "+name);
            //--编译报错---
            //System.out.println("my age is :"+ age);
        }
    }
}
```

在上述代码中，In这个类就是一个静态内部类。我们说内部类是可以访问外部类的私有字段和私有方法的，对于静态内部类，它遵循一致的原则，只能访问外部类的静态成员。上述代码中，外部类的非静态私有字段age在静态内部类中使不允许访问的，而静态字段name则是可访问的。下面我们看，如何创建一个静态内部类的实例对象。


```
public static void main(String [] args){
    Out.In innerClass = new Out.In();
    innerClass.sayHello();
}
```

使用场景，一般来说，对于和外部类联系紧密但是并不依赖于外部类实例的情况下，可以考虑定义成静态内部类。下面我们看稍显复杂的成员内部类。

## 成员内部类

我们说了，四种不同类型的内部类都各自有各自的使用场景，静态内部类适合于那种和外部类关系密切但是并不依赖外部类实例的情况。但是对于需要和外部类实例相关联的情况下，可以选择将内部类定义成成员内部类。以下代码定义了一个简单的成员内部类：


```
public class Out {
    private String name;

    public void showName(){
        System.out.println("my name is : "+name);
    }

    public class In{
        public void sayHello(){
            System.out.println(name);
            Out.this.showName();
        }
    }
}
```

以上定义了一个简单的内部类In，我们的成员内部类可以直接访问外部类的成员字段和成员方法，因为它是关联着一个外部类实例的。下面我们看看在外部是如何创建该内部类实例的。


```
public static void main(String [] args){
    Out out = new Out();
    out.setName("六脉神剑")
    Out.In in = out.new In();
    in.sayHello();
}
```
因为成员内部类是关联着一个具体的外部类实例的，所以它的实例创建必然是由外部类实例来创建的。对于实例的创建，我们只需要记住即可，成员内部类的实例创建需要关联外部类实例对象，静态内部类实例创建相对简单。下面我们主要看看在编译阶段编译器是如何保持内部类对外部类成员信息可访问的。

使用场景，对于那种要高度依赖外部类实例的情况下，定义一个成员内部类则会显的更加明智。

## 方法内部类

  方法内部类，顾名思义，定义在一个方法内部的类。方法内部类相对而言要复杂一些，下面定义一个方法内部类：
  
```
public class Out {
    private String name;

    public void sayHello(){
        class In{
            public void showName(){
                System.out.println("my name is : "+name);
            }
        }

        In in = new In();
        in.showName();
    }
}
```
我们定义了一个类，在该类中又定义了一个方法sayHello，然而在该方法中我们定义了一个内部类，类In就是一个方法内部类。我们的方法内部类的生命周期不超过包含它的方法的生命周期，也就是说，方法内部类只能在方法中使用。所以在声明的时候，任何的访问修饰符都是没有意义的，于是Java干脆不允许使用任何的访问修饰符修饰方法内部类。其中还需要注意一点的是，定义和使用时两回事，别看那一大串定义类的代码，你实际想要使用该类，就必须new对象，而对于方法内部类而言，只能在方法内部new对象。这就是方法内部类的简单介绍，下面我们看看其实现原理。

有关方法内部类的实现原理其实是和成员内部类差不太多的，也是在内部类初始化的时候为其传入一个外部类实例，区别在哪呢？就在于方法内部类是定义在具体方法的内部的，所以该类除了可以通过传入的外部实例访问外部类中的字段和方法，对于包含它的方法中被传入的参数也会随着外部类实例一起初始化给内部类。

毋庸置疑的是，方法内部类的封装性比之前介绍的两种都要完善。所以一般只有在需要高度封装的时候才会将类定义成方法内部类。

## 匿名内部类

 可能内部类的所有分类中，匿名内部类的名号是最大的，也是我们最常用到的，多见于函数式编程，lambda表达式等。下面我们重点看看这个匿名内部类。
 
 匿名内部类就是没有名字的内部类，在定义完成同时，实例也创建好了，常常和new关键字紧密结合。当然，它也不局限于类，也可以是接口
，可以出现在任何位置。下面我们定义一个匿名内部类：

如果您必须重写类或接口的方法，则应该使用它。可以通过两种方式创建Java匿名内部类 




```
//首先定义一个普通类
public class Out {
    private String name;

    public void sayHello(){
        System.out.println("my name is :" + name);
    }
}
```


```
//定义和使用一个匿名内部类
public static void main(String [] args){
    Out out = new Out(){
        @Override
        public void sayHello(){
            System.out.println("my name is cyy");
        }
        public void showName(){
            System.out.println("hello single");
        }
    };
    out.sayHello();
}
```

从上述代码中可以很显然的让我们看出来，我们的匿名内部类必定是要依托一个父类的，因为它是没有名字的，无法用一个具体的类型来表示。所以匿名内部类往往都是通过继承一个父类，重写或者重新声明一些成员来实现一个匿名内部类的定义。实际上还是利用了里式转换原理。

其实在看了上述三种内部类的原理之后，反而觉得匿名内部类的实现较为简单了。主要思路还是将内部类抽离出来，通过初始化传入外部类的实例以达到对外部类所有成员的访问。只是在匿名内部类中，被依托的父类不是他的外部类。匿名内部类的主要特点在于，没有名字，对象只能被使用一次，可以出现在任意位置。所以它的使用场景也是呼之欲出，对于一些对代码简洁度有所要求的情况下，可首选匿名内部类。

## 总结
以上完成了对四种内部类的简单介绍，对于他们各自实现的原理也都已经介绍过了。其实大致相同，由于jvm对每个类都要求一个单独的源码文件，所以编译阶段就完成了分离的操作，但是在分离的过程中又要保持内部类和外部类之间的这种联系，于是编译器添加了一些接口保持这种信息共享的结构。使用内部类可以大大增加程序的封装性，使得代码整体简洁度较高。

讲完这个后面的函数式接口 引用就好讲一点了


## 结尾
内部类就讲那么多，希望大家以后看源码会轻松点，哈哈
## 日常求赞
> 好了各位，以上就是这篇文章的全部内容了，能看到这里的人呀，都是**人才**。

> 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见

>六脉神剑 | 文 【原创】如果本篇博客有任何错误，请批评指教，不胜感激 ！
