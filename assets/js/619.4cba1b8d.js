(window.webpackJsonp=window.webpackJsonp||[]).push([[619],{1026:function(e,t,n){"use strict";n.r(t);var r=n(13),o=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("本文转载自："),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/jasonGeng88/blog"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看")]),e._v(" "),n("blockquote",[n("p",[e._v("https://github.com/h2pl/Java-Tutorial")])]),e._v(" "),n("p",[e._v("喜欢的话麻烦点下Star哈")]),e._v(" "),n("p",[e._v("文章将同步到我的个人博客：")]),e._v(" "),n("blockquote",[n("p",[e._v("www.how2playlife.com")])]),e._v(" "),n("p",[e._v("本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。")]),e._v(" "),n("p",[e._v("该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。")]),e._v(" "),n("p",[e._v("为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。")]),e._v(" "),n("p",[e._v("如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。")]),e._v(" "),n("ul",[n("li",[e._v("文章一："),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("JAVA 中原生的 socket 通信机制"),n("OutboundLink")],1)])]),e._v(" "),n("h2",{attrs:{id:"当前环境"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#当前环境"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),e._v("当前环境")]),e._v(" "),n("ol",[n("li",[e._v("jdk == 1.8")])]),e._v(" "),n("h2",{attrs:{id:"代码地址"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#代码地址"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E4%BB%A3%E7%A0%81%E5%9C%B0%E5%9D%80",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),e._v("代码地址")]),e._v(" "),n("p",[e._v("git 地址："),n("a",{attrs:{href:"https://github.com/jasonGeng88/java-network-programming",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/jasonGeng88/java-network-programming"),n("OutboundLink")],1)]),e._v(" "),n("h2",{attrs:{id:"知识点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#知识点"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E7%9F%A5%E8%AF%86%E7%82%B9",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),e._v("知识点")]),e._v(" "),n("ul",[n("li",[e._v("nio 下 I/O 阻塞与非阻塞实现")]),e._v(" "),n("li",[e._v("SocketChannel 介绍")]),e._v(" "),n("li",[e._v("I/O 多路复用的原理")]),e._v(" "),n("li",[e._v("事件选择器与 SocketChannel 的关系")]),e._v(" "),n("li",[e._v("事件监听类型")]),e._v(" "),n("li",[e._v("字节缓冲 ByteBuffer 数据结构")])]),e._v(" "),n("h2",{attrs:{id:"场景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#场景"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%9C%BA%E6%99%AF",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),e._v("场景")]),e._v(" "),n("p",[e._v("接着上一篇中的站点访问问题，如果我们需要并发访问10个不同的网站，我们该如何处理？")]),e._v(" "),n("p",[e._v("在上一篇中，我们使用了"),n("code",[e._v("java.net.socket")]),e._v("类来实现了这样的需求，以一线程处理一连接的方式，并配以线程池的控制，貌似得到了当前的最优解。可是这里也存在一个问题，连接处理是同步的，也就是并发数量增大后，大量请求会在队列中等待，或直接异常抛出。")]),e._v(" "),n("p",[e._v("为解决这问题，我们发现元凶处在“一线程一请求”上，如果一个线程能同时处理多个请求，那么在高并发下性能上会大大改善。这里就借住 JAVA 中的 nio 技术来实现这一模型。")]),e._v(" "),n("h2",{attrs:{id:"nio-的阻塞实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nio-的阻塞实现"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#nio-%E7%9A%84%E9%98%BB%E5%A1%9E%E5%AE%9E%E7%8E%B0",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),e._v("nio 的阻塞实现")]),e._v(" "),n("p",[e._v("关于什么是 nio，从字面上理解为 New IO，就是为了弥补原本 I/O 上的不足，而在 JDK 1.4 中引入的一种新的 I/O 实现方式。简单理解，就是它提供了 I/O 的阻塞与非阻塞的两种实现方式（"),n("em",[e._v("当然，默认实现方式是阻塞的。")]),e._v("）。")]),e._v(" "),n("p",[e._v("下面，我们先来看下 nio 以阻塞方式是如何处理的。")]),e._v(" "),n("h3",{attrs:{id:"建立连接"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#建立连接"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),e._v("建立连接")]),e._v(" "),n("p",[e._v("有了上一篇 socket 的经验，我们的第一步一定也是建立 socket 连接。只不过，这里不是采用 "),n("code",[e._v("new socket()")]),e._v(" 的方式，而是引入了一个新的概念 "),n("code",[e._v("SocketChannel")]),e._v("。它可以看作是 socket 的一个完善类，除了提供 Socket 的相关功能外，还提供了许多其他特性，如后面要讲到的向选择器注册的功能。")]),e._v(" "),n("p",[e._v("类图如下： "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/assets/java-nio-01.jpg",target:"_blank",rel:"noopener noreferrer"}},[n("img",{attrs:{src:"https://github.com/jasonGeng88/blog/raw/master/201708/assets/java-nio-01.jpg",alt:""}}),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("建立连接代码实现：")]),e._v(" "),n("pre",[e._v("// 初始化 socket，建立 socket 与 channel 的绑定关系\nSocketChannel socketChannel = SocketChannel.open();\n// 初始化远程连接地址\nSocketAddress remote = new InetSocketAddress(this.host, port);\n// I/O 处理设置阻塞，这也是默认的方式，可不设置\nsocketChannel.configureBlocking(true);\n// 建立连接\nsocketChannel.connect(remote);")]),e._v(" "),n("h3",{attrs:{id:"获取-socket-连接"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#获取-socket-连接"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E8%8E%B7%E5%8F%96-socket-%E8%BF%9E%E6%8E%A5",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),e._v("获取 socket 连接")]),e._v(" "),n("p",[e._v("因为是同样是 I/O 阻塞的实现，所以后面的关于 socket 输入输出流的处理，和上一篇的基本相同。唯一差别是，这里需要通过 channel 来获取 socket 连接。")]),e._v(" "),n("ul",[n("li",[e._v("获取 socket 连接")])]),e._v(" "),n("pre",[e._v("Socket socket = socketChannel.socket();")]),e._v(" "),n("ul",[n("li",[e._v("处理输入输出流")])]),e._v(" "),n("pre",[e._v("PrintWriter pw = getWriter(socketChannel.socket());\nBufferedReader br = getReader(socketChannel.socket());")]),e._v(" "),n("h3",{attrs:{id:"完整示例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#完整示例"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),e._v("完整示例")]),e._v(" "),n("pre",[e._v("package com.jason.network.mode.nio;\n\nimport com.jason.network.constant.HttpConstant;\nimport com.jason.network.util.HttpUtil;\n\nimport java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.nio.channels.SocketChannel;\n\npublic class NioBlockingHttpClient {\n\n    private SocketChannel socketChannel;\n    private String host;\n\n    public static void main(String[] args) throws IOException {\n\n        for (String host: HttpConstant.HOSTS) {\n\n            NioBlockingHttpClient client = new NioBlockingHttpClient(host, HttpConstant.PORT);\n            client.request();\n\n        }\n\n    }\n\n    public NioBlockingHttpClient(String host, int port) throws IOException {\n        this.host = host;\n        socketChannel = SocketChannel.open();\n        socketChannel.socket().setSoTimeout(5000);\n        SocketAddress remote = new InetSocketAddress(this.host, port);\n        this.socketChannel.connect(remote);\n    }\n\n    public void request() throws IOException {\n        PrintWriter pw = getWriter(socketChannel.socket());\n        BufferedReader br = getReader(socketChannel.socket());\n\n        pw.write(HttpUtil.compositeRequest(host));\n        pw.flush();\n        String msg;\n        while ((msg = br.readLine()) != null){\n            System.out.println(msg);\n        }\n    }\n\n    private PrintWriter getWriter(Socket socket) throws IOException {\n        OutputStream out = socket.getOutputStream();\n        return new PrintWriter(out);\n    }\n\n    private BufferedReader getReader(Socket socket) throws IOException {\n        InputStream in = socket.getInputStream();\n        return new BufferedReader(new InputStreamReader(in));\n    }\n}")]),e._v(" "),n("h2",{attrs:{id:"nio-的非阻塞实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nio-的非阻塞实现"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#nio-%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%AE%9E%E7%8E%B0",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),e._v("nio 的非阻塞实现")]),e._v(" "),n("h3",{attrs:{id:"原理分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原理分析"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),e._v("原理分析")]),e._v(" "),n("p",[e._v("nio 的阻塞实现，基本与使用原生的 socket 类似，没有什么特别大的差别。")]),e._v(" "),n("p",[e._v("下面我们来看看它真正强大的地方。到目前为止，我们将的都是阻塞 I/O。何为阻塞 I/O，看下图：")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/assets/java-nio-02.jpg",target:"_blank",rel:"noopener noreferrer"}},[n("img",{attrs:{src:"https://github.com/jasonGeng88/blog/raw/master/201708/assets/java-nio-02.jpg",alt:""}}),n("OutboundLink")],1)]),e._v(" "),n("p",[n("em",[e._v("我们主要观察图中的前三种 I/O 模型，关于异步 I/O，一般需要依靠操作系统的支持，这里不讨论。")])]),e._v(" "),n("p",[e._v("从图中可以发现，阻塞过程主要发生在两个阶段上：")]),e._v(" "),n("ul",[n("li",[e._v("第一阶段：等待数据就绪；")]),e._v(" "),n("li",[e._v("第二阶段：将已就绪的数据从内核缓冲区拷贝到用户空间；")])]),e._v(" "),n("p",[e._v("这里产生了一个从内核到用户空间的拷贝，主要是为了系统的性能优化考虑。假设，从网卡读到的数据直接返回给用户空间，那势必会造成频繁的系统中断，因为从网卡读到的数据不一定是完整的，可能断断续续的过来。通过内核缓冲区作为缓冲，等待缓冲区有足够的数据，或者读取完结后，进行一次的系统中断，将数据返回给用户，这样就能避免频繁的中断产生。")]),e._v(" "),n("p",[e._v("了解了 I/O 阻塞的两个阶段，下面我们进入正题。看看一个线程是如何实现同时处理多个 I/O 调用的。从上图中的非阻塞 I/O 可以看出，仅仅只有第二阶段需要阻塞，第一阶段的数据等待过程，我们是不需要关心的。不过该模型是频繁地去检查是否就绪，造成了 CPU 无效的处理，反而效果不好。如果有一种类似的好莱坞原则— “不要给我们打电话，我们会打给你” 。这样一个线程可以同时发起多个 I/O 调用，并且不需要同步等待数据就绪。在数据就绪完成的时候，会以事件的机制，来通知我们。这样不就实现了单线程同时处理多个 IO 调用的问题了吗？即所说的“I/O 多路复用模型”。")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("废话讲了一大堆，下面就来实际操刀一下。")]),e._v(" "),n("h3",{attrs:{id:"创建选择器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建选择器"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%88%9B%E5%BB%BA%E9%80%89%E6%8B%A9%E5%99%A8",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),e._v("创建选择器")]),e._v(" "),n("p",[e._v("由上面分析可以，我们得有一个选择器，它能监听所有的 I/O 操作，并且以事件的方式通知我们哪些 I/O 已经就绪了。")]),e._v(" "),n("p",[e._v("代码如下：")]),e._v(" "),n("pre",[e._v("import java.nio.channels.Selector;\n\n...\n\nprivate static Selector selector;\nstatic {\n    try {\n        selector = Selector.open();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n")]),e._v(" "),n("h3",{attrs:{id:"创建非阻塞-i-o"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建非阻塞-i-o"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%88%9B%E5%BB%BA%E9%9D%9E%E9%98%BB%E5%A1%9E-io",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),e._v("创建非阻塞 I/O")]),e._v(" "),n("p",[e._v("下面，我们来创建一个非阻塞的 "),n("code",[e._v("SocketChannel")]),e._v("，代码与阻塞实现类型，唯一不同是"),n("code",[e._v("socketChannel.configureBlocking(false)")]),e._v("。")]),e._v(" "),n("p",[n("em",[n("strong",[e._v("注意：只有在"),n("code",[e._v("socketChannel.configureBlocking(false)")]),e._v("之后的代码，才是非阻塞的，如果"),n("code",[e._v("socketChannel.connect()")]),e._v("在设置非阻塞模式之前，那么连接操作依旧是阻塞调用的。")])])]),e._v(" "),n("pre",[e._v("SocketChannel socketChannel = SocketChannel.open();\nSocketAddress remote = new InetSocketAddress(host, port);\n// 设置非阻塞模式\nsocketChannel.configureBlocking(false);\nsocketChannel.connect(remote);")]),e._v(" "),n("h3",{attrs:{id:"建立选择器与-socket-的关联"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#建立选择器与-socket-的关联"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%BB%BA%E7%AB%8B%E9%80%89%E6%8B%A9%E5%99%A8%E4%B8%8E-socket-%E7%9A%84%E5%85%B3%E8%81%94",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),e._v("建立选择器与 socket 的关联")]),e._v(" "),n("p",[e._v("选择器与 socket 都创建好了，下一步就是将两者进行关联，好让选择器和监听到 Socket 的变化。这里采用了以 "),n("code",[e._v("SocketChannel")]),e._v(" 主动注册到选择器的方式进行关联绑定，这也就解释了，为什么不直接"),n("code",[e._v("new Socket()")]),e._v("，而是以"),n("code",[e._v("SocketChannel")]),e._v("的方式来创建 socket。")]),e._v(" "),n("p",[e._v("代码如下：")]),e._v(" "),n("pre",[e._v("socketChannel.register(selector,\n                        SelectionKey.OP_CONNECT\n                        | SelectionKey.OP_READ\n                        | SelectionKey.OP_WRITE);")]),e._v(" "),n("p",[e._v("上面代码，我们将 socketChannel 注册到了选择器中，并且对它的连接、可读、可写事件进行了监听。")]),e._v(" "),n("p",[e._v("具体的事件监听类型如下：")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th",[e._v("操作类型")]),e._v(" "),n("th",[e._v("值")]),e._v(" "),n("th",[e._v("描述")]),e._v(" "),n("th",[e._v("所属对象")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("OP_READ")]),e._v(" "),n("td",[e._v("1 << 0")]),e._v(" "),n("td",[e._v("读操作")]),e._v(" "),n("td",[e._v("SocketChannel")])]),e._v(" "),n("tr",[n("td",[e._v("OP_WRITE")]),e._v(" "),n("td",[e._v("1 << 2")]),e._v(" "),n("td",[e._v("写操作")]),e._v(" "),n("td",[e._v("SocketChannel")])]),e._v(" "),n("tr",[n("td",[e._v("OP_CONNECT")]),e._v(" "),n("td",[e._v("1 << 3")]),e._v(" "),n("td",[e._v("连接socket操作")]),e._v(" "),n("td",[e._v("SocketChannel")])]),e._v(" "),n("tr",[n("td",[e._v("OP_ACCEPT")]),e._v(" "),n("td",[e._v("1 << 4")]),e._v(" "),n("td",[e._v("接受socket操作")]),e._v(" "),n("td",[e._v("ServerSocketChannel")])])])]),e._v(" "),n("h3",{attrs:{id:"选择器监听-socket-变化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#选择器监听-socket-变化"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E9%80%89%E6%8B%A9%E5%99%A8%E7%9B%91%E5%90%AC-socket-%E5%8F%98%E5%8C%96",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),e._v("选择器监听 socket 变化")]),e._v(" "),n("p",[e._v("现在，选择器已经与我们关心的 socket 进行了关联。下面就是感知事件的变化，然后调用相应的处理机制。")]),e._v(" "),n("p",[e._v("这里与 Linux 下的 selector 有点不同，nio 下的 selecotr 不会去遍历所有关联的 socket。我们在注册时设置了我们关心的事件类型，每次从选择器中获取的，只会是那些符合事件类型，并且完成就绪操作的 socket，减少了大量无效的遍历操作。")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public void select() throws IOException {\n\t// 获取就绪的 socket 个数\n    while (selector.select() > 0){\n\n    \t// 获取符合的 socket 在选择器中对应的事件句柄 key\n        Set keys = selector.selectedKeys();\n\n\t\t// 遍历所有的key\n        Iterator it = keys.iterator();\n        while (it.hasNext()){\n\n\t\t\t// 获取对应的 key，并从已选择的集合中移除\n            SelectionKey key = (SelectionKey)it.next();\n            it.remove();\n\n            if (key.isConnectable()){\n            \t// 进行连接操作\n                connect(key);\n            }\n            else if (key.isWritable()){\n            \t// 进行写操作\n                write(key);\n            }\n            else if (key.isReadable()){\n            \t// 进行读操作\n                receive(key);\n            }\n        }\n    }\n}\n\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br"),n("span",{staticClass:"line-number"},[e._v("14")]),n("br"),n("span",{staticClass:"line-number"},[e._v("15")]),n("br"),n("span",{staticClass:"line-number"},[e._v("16")]),n("br"),n("span",{staticClass:"line-number"},[e._v("17")]),n("br"),n("span",{staticClass:"line-number"},[e._v("18")]),n("br"),n("span",{staticClass:"line-number"},[e._v("19")]),n("br"),n("span",{staticClass:"line-number"},[e._v("20")]),n("br"),n("span",{staticClass:"line-number"},[e._v("21")]),n("br"),n("span",{staticClass:"line-number"},[e._v("22")]),n("br"),n("span",{staticClass:"line-number"},[e._v("23")]),n("br"),n("span",{staticClass:"line-number"},[e._v("24")]),n("br"),n("span",{staticClass:"line-number"},[e._v("25")]),n("br"),n("span",{staticClass:"line-number"},[e._v("26")]),n("br"),n("span",{staticClass:"line-number"},[e._v("27")]),n("br"),n("span",{staticClass:"line-number"},[e._v("28")]),n("br"),n("span",{staticClass:"line-number"},[e._v("29")]),n("br"),n("span",{staticClass:"line-number"},[e._v("30")]),n("br"),n("span",{staticClass:"line-number"},[e._v("31")]),n("br")])]),n("p",[n("em",[n("strong",[e._v("注意：这里的"),n("code",[e._v("selector.select()")]),e._v("是同步阻塞的，等待有事件发生后，才会被唤醒。这就防止了 CPU 空转的产生。当然，我们也可以给它设置超时时间，"),n("code",[e._v("selector.select(long timeout)")]),e._v("来结束阻塞过程。")])])]),e._v(" "),n("h3",{attrs:{id:"处理连接就绪事件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#处理连接就绪事件"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%A4%84%E7%90%86%E8%BF%9E%E6%8E%A5%E5%B0%B1%E7%BB%AA%E4%BA%8B%E4%BB%B6",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),e._v("处理连接就绪事件")]),e._v(" "),n("p",[e._v("下面，我们分别来看下，一个 socket 是如何来处理连接、写入数据和读取数据的（"),n("em",[e._v("这些操作都是阻塞的过程，只是我们将等待就绪的过程变成了非阻塞的了")]),e._v("）。")]),e._v(" "),n("p",[e._v("处理连接代码：")]),e._v(" "),n("pre",[e._v('// SelectionKey 代表 SocketChannel 在选择器中注册的事件句柄\nprivate void connect(SelectionKey key) throws IOException {\n\t// 获取事件句柄对应的 SocketChannel\n    SocketChannel channel = (SocketChannel) key.channel();\n\n   // 真正的完成 socket 连接\n    channel.finishConnect();\n\n   // 打印连接信息\n    InetSocketAddress remote = (InetSocketAddress) channel.socket().getRemoteSocketAddress();\n    String host = remote.getHostName();\n    int port = remote.getPort();\n    System.out.println(String.format("访问地址: %s:%s 连接成功!", host, port));\n}')]),e._v(" "),n("h3",{attrs:{id:"处理写入就绪事件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#处理写入就绪事件"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%A4%84%E7%90%86%E5%86%99%E5%85%A5%E5%B0%B1%E7%BB%AA%E4%BA%8B%E4%BB%B6",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),e._v("处理写入就绪事件")]),e._v(" "),n("pre",[e._v('// 字符集处理类\nprivate Charset charset = Charset.forName("utf8");\n\nprivate void write(SelectionKey key) throws IOException {\n    SocketChannel channel = (SocketChannel) key.channel();\n    InetSocketAddress remote = (InetSocketAddress) channel.socket().getRemoteSocketAddress();\n    String host = remote.getHostName();\n\n\t// 获取 HTTP 请求，同上一篇\n    String request = HttpUtil.compositeRequest(host);\n\n\t// 向 SocketChannel 写入事件 \n    channel.write(charset.encode(request));\n\n    // 修改 SocketChannel 所关心的事件\n    key.interestOps(SelectionKey.OP_READ);\n}')]),e._v(" "),n("p",[e._v("这里有两个地方需要注意：")]),e._v(" "),n("ul",[n("li",[e._v("第一个是使用 "),n("code",[e._v("channel.write(charset.encode(request));")]),e._v(" 进行数据写入。有人会说，为什么不能像上面同步阻塞那样，通过"),n("code",[e._v("PrintWriter")]),e._v("包装类进行操作。因为"),n("code",[e._v("PrintWriter")]),e._v("的 "),n("code",[e._v("write()")]),e._v(" 方法是阻塞的，也就是说要等数据真正从 socket 发送出去后才返回。")])]),e._v(" "),n("p",[e._v("这与我们这里所讲的阻塞是不一致的，这里的操作虽然也是阻塞的，但它发生的过程是在数据从用户空间到内核缓冲区拷贝过程。至于系统将缓冲区的数据通过 socket 发送出去，这不在阻塞范围内。也解释了为什么要用 "),n("code",[e._v("Charset")]),e._v(" 对写入内容进行编码了，因为缓冲区接收的格式是"),n("code",[e._v("ByteBuffer")]),e._v("。")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("第二，选择器用来监听事件变化的两个参数是 "),n("code",[e._v("interestOps")]),e._v(" 与 "),n("code",[e._v("readyOps")]),e._v("。")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("interestOps：表示 "),n("code",[e._v("SocketChannel")]),e._v(" 所关心的事件类型，也就是告诉选择器，当有这几种事件发生时，才来通知我。这里通过"),n("code",[e._v("key.interestOps(SelectionKey.OP_READ);")]),e._v("告诉选择器，之后我只关心“读就绪”事件，其他的不用通知我了。")])]),e._v(" "),n("li",[n("p",[e._v("readyOps：表示 "),n("code",[e._v("SocketChannel")]),e._v(" 当前就绪的事件类型。以"),n("code",[e._v("key.isReadable()")]),e._v("为例，判断依据就是："),n("code",[e._v("return (readyOps() & OP_READ) != 0;")])])])])])]),e._v(" "),n("h3",{attrs:{id:"处理读取就绪事件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#处理读取就绪事件"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%A4%84%E7%90%86%E8%AF%BB%E5%8F%96%E5%B0%B1%E7%BB%AA%E4%BA%8B%E4%BB%B6",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),e._v("处理读取就绪事件")]),e._v(" "),n("pre",[e._v('private void receive(SelectionKey key) throws IOException {\n    SocketChannel channel = (SocketChannel) key.channel();\n    ByteBuffer buffer = ByteBuffer.allocate(1024);\n    channel.read(buffer);\n    buffer.flip();\n    String receiveData = charset.decode(buffer).toString();\n\n\t// 当再没有数据可读时，取消在选择器中的关联，并关闭 socket 连接\n    if ("".equals(receiveData)) {\n        key.cancel();\n        channel.close();\n        return;\n    }\n\n    System.out.println(receiveData);\n}')]),e._v(" "),n("p",[e._v("这里的处理基本与写入一致，唯一要注意的是，这里我们需要自行处理去缓冲区读取数据的操作。首先会分配一个固定大小的缓冲区，然后从内核缓冲区中，拷贝数据至我们刚分配固定缓冲区上。这里存在两种情况：")]),e._v(" "),n("ul",[n("li",[e._v("我们分配的缓冲区过大，那多余的部分以0补充（"),n("em",[e._v("初始化时，其实会自动补0")]),e._v("）。")]),e._v(" "),n("li",[e._v("我们分配的缓冲去过小，因为选择器会不停的遍历。只要 "),n("code",[e._v("SocketChannel")]),e._v(" 处理读就绪状态，那下一次会继续读取。当然，分配过小，会增加遍历次数。")])]),e._v(" "),n("p",[e._v("最后，将一下 "),n("code",[e._v("ByteBuffer")]),e._v(" 的结构，它主要有 position, limit,capacity 以及 mark 属性。以 "),n("code",[e._v("buffer.flip();")]),e._v(" 为例，讲下各属性的作用（"),n("em",[e._v("mark 主要是用来标记之前 position 的位置，是在当前 postion 无法满足的情况下使用的，这里不作讨论")]),e._v("）。")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/assets/java-nio-03.png",target:"_blank",rel:"noopener noreferrer"}},[n("img",{attrs:{src:"https://github.com/jasonGeng88/blog/raw/master/201708/assets/java-nio-03.png",alt:""}}),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("从图中看出，")]),e._v(" "),n("ul",[n("li",[e._v("容量（capacity）：表示缓冲区可以保存的数据容量；")]),e._v(" "),n("li",[e._v("极限（limit）：表示缓冲区的当前终点，即写入、读取都不可超过该重点；")]),e._v(" "),n("li",[e._v("位置（position）：表示缓冲区下一个读写单元的位置；")])]),e._v(" "),n("h3",{attrs:{id:"完整代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#完整代码"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),e._v("完整代码")]),e._v(" "),n("pre",[e._v('package com.jason.network.mode.nio;\n\nimport com.jason.network.constant.HttpConstant;\nimport com.jason.network.util.HttpUtil;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NioNonBlockingHttpClient {\n\n    private static Selector selector;\n    private Charset charset = Charset.forName("utf8");\n\n    static {\n        try {\n            selector = Selector.open();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n\n        NioNonBlockingHttpClient client = new NioNonBlockingHttpClient();\n\n        for (String host: HttpConstant.HOSTS) {\n\n            client.request(host, HttpConstant.PORT);\n\n        }\n\n        client.select();\n\n    }\n\n    public void request(String host, int port) throws IOException {\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.socket().setSoTimeout(5000);\n        SocketAddress remote = new InetSocketAddress(host, port);\n        socketChannel.configureBlocking(false);\n        socketChannel.connect(remote);\n        socketChannel.register(selector,\n                        SelectionKey.OP_CONNECT\n                        | SelectionKey.OP_READ\n                        | SelectionKey.OP_WRITE);\n    }\n\n    public void select() throws IOException {\n        while (selector.select(500) > 0){\n            Set keys = selector.selectedKeys();\n\n            Iterator it = keys.iterator();\n\n            while (it.hasNext()){\n\n                SelectionKey key = (SelectionKey)it.next();\n                it.remove();\n\n                if (key.isConnectable()){\n                    connect(key);\n                }\n                else if (key.isWritable()){\n                    write(key);\n                }\n                else if (key.isReadable()){\n                    receive(key);\n                }\n            }\n        }\n    }\n\n    private void connect(SelectionKey key) throws IOException {\n        SocketChannel channel = (SocketChannel) key.channel();\n        channel.finishConnect();\n        InetSocketAddress remote = (InetSocketAddress) channel.socket().getRemoteSocketAddress();\n        String host = remote.getHostName();\n        int port = remote.getPort();\n        System.out.println(String.format("访问地址: %s:%s 连接成功!", host, port));\n    }\n\n    private void write(SelectionKey key) throws IOException {\n        SocketChannel channel = (SocketChannel) key.channel();\n        InetSocketAddress remote = (InetSocketAddress) channel.socket().getRemoteSocketAddress();\n        String host = remote.getHostName();\n\n        String request = HttpUtil.compositeRequest(host);\n        System.out.println(request);\n\n        channel.write(charset.encode(request));\n        key.interestOps(SelectionKey.OP_READ);\n    }\n\n    private void receive(SelectionKey key) throws IOException {\n        SocketChannel channel = (SocketChannel) key.channel();\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        channel.read(buffer);\n        buffer.flip();\n        String receiveData = charset.decode(buffer).toString();\n\n        if ("".equals(receiveData)) {\n            key.cancel();\n            channel.close();\n            return;\n        }\n\n        System.out.println(receiveData);\n    }\n}\n')]),e._v(" "),n("h3",{attrs:{id:"示例效果"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#示例效果"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E7%A4%BA%E4%BE%8B%E6%95%88%E6%9E%9C",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),e._v("示例效果")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/assets/java-nio-04.png",target:"_blank",rel:"noopener noreferrer"}},[n("img",{attrs:{src:"https://github.com/jasonGeng88/blog/raw/master/201708/assets/java-nio-04.png",alt:""}}),n("OutboundLink")],1)]),e._v(" "),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E6%80%BB%E7%BB%93",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),e._v("总结")]),e._v(" "),n("p",[e._v("本文从 nio 的阻塞方式讲起，介绍了阻塞 I/O 与非阻塞 I/O 的区别，以及在 nio 下是如何一步步构建一个 IO 多路复用的模型的客户端。文中需要理解的内容比较多，如果有理解错误的地方，欢迎指正~")]),e._v(" "),n("h2",{attrs:{id:"后续"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#后续"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%90%8E%E7%BB%AD",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),e._v("后续")]),e._v(" "),n("ul",[n("li",[e._v("Netty 下的异步请求实现")])])])}),[],!1,null,null,null);t.default=o.exports}}]);