(window.webpackJsonp=window.webpackJsonp||[]).push([[263],{647:function(v,_,e){"use strict";e.r(_);var t=e(13),r=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("ul",[e("li",[v._v("贫血模型即事务脚本模式")]),v._v(" "),e("li",[v._v("充血模型即领域模型模式")])]),v._v(" "),e("h1",{attrs:{id:"贫血模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#贫血模型"}},[v._v("#")]),v._v(" 贫血模型")]),v._v(" "),e("p",[v._v("最早广泛应用源于EJB2，最强盛时期则是由Spring创造，把")]),v._v(" "),e("ul",[e("li",[v._v("“行为”（逻辑、过程）")]),v._v(" "),e("li",[v._v("“状态”（数据，对应到语言就是对象成员变量）")])]),v._v(" "),e("p",[v._v("分离到不同的对象中：")]),v._v(" "),e("ul",[e("li",[v._v("只有状态的对象就是所谓的“贫血对象”（常称为VO——Value Object）")]),v._v(" "),e("li",[v._v("只有行为的对象就是我们常见的N层结构中的Logic/Service/Manager层（对应到EJB2中的Stateless Session Bean）。（曾经Spring的作者Rod Johnson也承认，Spring不过是在沿袭EJB2时代的“事务脚本”，也就是面向过程编程）")])]),v._v(" "),e("p",[v._v("贫血领域模型是一个存在已久的反模式，它不是个好东西。")]),v._v(" "),e("ul",[e("li",[v._v("贫血领域模型的基本特征\n它第一眼看起来还真像这么回事儿。项目中有许多对象，它们的命名都是根据领域来的。对象之间有着丰富的连接方式，和真正的领域模型非常相似。但当你检视这些对象的行为时，会发现它们基本上没有任何行为，仅仅是一堆getter/setter。\n其实这些对象在设计之初就被定义为只能包含数据，不能加入领域逻辑。这些逻辑要全部写入一组叫Service的对象中。这些Service构建在领域模型之上，使用这些模型来传递数据。")])]),v._v(" "),e("h2",{attrs:{id:"反模式的恐怖"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#反模式的恐怖"}},[v._v("#")]),v._v(" 反模式的恐怖")]),v._v(" "),e("p",[v._v("它完全和面向对象设计背道而驰。面向对象设计主张将数据和行为绑定在一起，而贫血领域模型则更像是一种面向过程设计。")]),v._v(" "),e("p",[v._v("贫血领域模型的根本问题在于，它"),e("strong",[v._v("引入了领域模型设计的所有成本，却没有带来任何好处")]),v._v("。\n最主要的成本是将对象映射到数据库中，从而产生了一个O/R（对象关系）映射层。只有当你充分使用了面向对象设计来组织复杂的业务逻辑后，这一成本才能够被抵消。如果将所有行为都写入到Service对象，那最终你会得到一组事务处理脚本，从而错过了领域模型带来的好处。正如martin在企业应用架构模式一书中说到的，领域模型并不一定是最好的工具。")]),v._v(" "),e("p",[v._v("将行为放入领域模型，这点和分层设计（领域层、持久化层、展现层等）并不冲突。因为领域模型中放入的是和领域相关的逻辑——验证、计算、业务规则等。如果你要讨论能否将数据源或展现逻辑放入到领域模型中，这就不在本文论述范围之内了。")]),v._v(" "),e("p",[v._v("一些面向对象专家的观点有时会让人产生疑惑，他们认为的确应该有一个面向过程的服务层。但是，"),e("strong",[v._v("这并不意味着领域模型就不应该包含行为")]),v._v("。事实上，service层需要和一组富含行为的领域模型结合使用。")]),v._v(" "),e("p",[v._v("Eric Evans的Domain Driven Design一书中提到：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("应用层（即Service层）\n描述应用程序所要做的工作，并调度丰富的领域模型来完成它。这个层次的任务是描述业务逻辑，或和其它项目的应用层做交互。这层很薄，不包含任何业务规则或知识，仅用于调度和派发任务给下一层的领域模型。这层没有"),e("strong",[v._v("业务状态")]),v._v("，但可以为用户或程序提供"),e("strong",[v._v("任务状态")]),v._v("。")])]),v._v(" "),e("li",[e("p",[v._v("领域层（或者叫模型层）\n表示业务逻辑、业务场景和规则。该层次会控制和使用业务状态，即使这些状态最终会交由持久化层来存储。总之，该层是软件核心。")])])]),v._v(" "),e("p",[v._v("服务层很薄——所有重要的业务逻辑都写在领域层。他在服务模式中复述了这一观点：\n如今人们常犯的错误是不愿花时间将业务逻辑放到合适的领域模型中，从而逐渐形成面向过程的程序设计。")]),v._v(" "),e("p",[v._v("为什么这种反模式会那么常见呢。我怀疑是因为大多数人并没有使用过一个设计良好的领域模型，特别是那些以数据为中心的开发人员。此外，有些技术也会推动这种反模式，比如J2EE的Entity Bean，这会让我更倾向于使用POJO领域模型。")]),v._v(" "),e("p",[v._v("总之，如果你将大部分行为都放置在服务层，那么你就会失去领域模型带来的好处。如果你将所有行为都放在服务层，那你就无可救药了。")]),v._v(" "),e("h2",{attrs:{id:"优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[v._v("#")]),v._v(" 优点")]),v._v(" "),e("p",[v._v("简单")]),v._v(" "),e("ul",[e("li",[v._v("对于只有少量业务逻辑的应用来说，使用起来非常自然")]),v._v(" "),e("li",[v._v("开发迅速，易于理解")]),v._v(" "),e("li",[v._v("注意：也不能完全排斥这种方式")])]),v._v(" "),e("h2",{attrs:{id:"缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[v._v("#")]),v._v(" 缺点")]),v._v(" "),e("p",[v._v("无法良好的应对复杂逻辑")]),v._v(" "),e("ul",[e("li",[v._v("比如收入确认规则发生变化，例如在4月1号之前签订的合同要使用某规则.....")]),v._v(" "),e("li",[v._v("和欧洲签订的合同使用另外一个规则.....")])]),v._v(" "),e("h1",{attrs:{id:"充血模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#充血模型"}},[v._v("#")]),v._v(" 充血模型")]),v._v(" "),e("p",[v._v("面向对象设计的本质：“一个对象是拥有状态和行为的”，比如一个人：")]),v._v(" "),e("ul",[e("li",[v._v("他眼睛什么样鼻子什么样这就是状态")]),v._v(" "),e("li",[v._v("人可以去打游戏或是写程序，这就是行为")])]),v._v(" "),e("p",[v._v("为什么要有一个“人Manager”这样的东西存在去帮人“打游戏”呢？\n举个简单的J2EE案例，设计一个与用户（User）相关功能。\n传统的设计一般是：")]),v._v(" "),e("ul",[e("li",[v._v("类：User+UserManager")]),v._v(" "),e("li",[v._v("保存用户调用：userManager.save(User user)")])]),v._v(" "),e("p",[v._v("充血的设计则可能会是：")]),v._v(" "),e("ul",[e("li",[v._v("类：User")]),v._v(" "),e("li",[v._v("保存用户调用：user.save()")]),v._v(" "),e("li",[v._v("User有一个行为是：保存它自己")])]),v._v(" "),e("p",[v._v("其实它们没有什么特别适用的方向，个人更倾向于总是使用充血模型，因为OOP总是比面向过程编程要有更丰富的语义、更合理的组织、更强的可维护性—当然也更难掌握。因此实际工程场景中，是否使用，如何使用还依赖于设计者以及团队充血模型设计的理解和把握，因为现在绝大多数J2EE开发者都受贫血模型影响非常深。另外，实际工程场景中使用充血模型还会碰到很多很多细节问题，其中最大的难关就是“如何设计充血模型”或者说“如何从复杂的业务中分离出恰到好处且包含语义的逻辑放到VO的行为中”。")]),v._v(" "),e("p",[v._v("如果一个对象包含其他对象，那就将职责继续委托下去，由具体的 POJO 执行业务逻辑，将策略模式更加细粒度，而不是写 ifelse。")]),v._v(" "),e("blockquote",[e("p",[v._v("参考")]),v._v(" "),e("ul",[e("li",[v._v("《领域驱动设计》")]),v._v(" "),e("li",[v._v("https://www.zhihu.com/question/20360521/answer/14891150")]),v._v(" "),e("li",[v._v("https://www.martinfowler.com/bliki/AnemicDomainModel.html")])])])])}),[],!1,null,null,null);_.default=r.exports}}]);