(window.webpackJsonp=window.webpackJsonp||[]).push([[589],{980:function(a,n,s){"use strict";s.r(n);var i=s(13),e=Object(i.a)({},(function(){var a=this,n=a.$createElement,s=a._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"table-of-contents"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#table-of-contents"}},[a._v("#")]),a._v(" Table of Contents")]),a._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#%E5%89%8D%E8%A8%80"}},[a._v("前言")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E5%86%99final%E5%9F%9F%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99"}},[a._v("写final域的重排序规则")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E8%AF%BBfinal%E5%9F%9F%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99"}},[a._v("读final域的重排序规则")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E5%A6%82%E6%9E%9Cfinal%E5%9F%9F%E6%98%AF%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"}},[a._v("如果final域是引用类型")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E4%B8%BA%E4%BB%80%E4%B9%88final%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E4%BB%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%86%85%E9%80%B8%E5%87%BA"}},[a._v("为什么final引用不能从构造函数内“逸出”")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#final%E8%AF%AD%E4%B9%89%E5%9C%A8%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"}},[a._v("final语义在处理器中的实现")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#jsr-133%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A2%9E%E5%BC%BAfinal%E7%9A%84%E8%AF%AD%E4%B9%89"}},[a._v("JSR-133为什么要增强final的语义")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"}},[a._v("参考文献")])])]),a._v(" "),s("p",[s("strong",[a._v("本文转载自互联网，侵删")])]),a._v(" "),s("p",[a._v("本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看")]),a._v(" "),s("blockquote",[s("p",[a._v("https://github.com/h2pl/Java-Tutorial")])]),a._v(" "),s("p",[a._v("喜欢的话麻烦点下Star哈")]),a._v(" "),s("p",[a._v("文章首发于我的个人博客：")]),a._v(" "),s("blockquote",[s("p",[a._v("www.how2playlife.com")])]),a._v(" "),s("p",[a._v("本文是微信公众号【Java技术江湖】的《Java并发指南》其中一篇，本文大部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。")]),a._v(" "),s("p",[a._v("该系列博文会告诉你如何全面深入地学习Java并发技术，从Java多线程基础，再到并发编程的基础知识，从Java并发包的入门和实战，再到JUC的源码剖析，一步步地学习Java并发编程，并上手进行实战，以便让你更完整地了解整个Java并发编程知识体系，形成自己的知识框架。")]),a._v(" "),s("p",[a._v("为了更好地总结和检验你的学习成果，本系列文章也会提供一些对应的面试题以及参考答案。")]),a._v(" "),s("p",[a._v("如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。")]),a._v(" "),s("h2",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),s("p",[a._v("与前面介绍的锁和volatile相比较，对final域的读和写更像是普通的变量访问。对于final域，编译器和处理器要遵守两个重排序规则：")]),a._v(" "),s("ol",[s("li",[a._v("在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。")]),a._v(" "),s("li",[a._v("初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。")])]),a._v(" "),s("p",[a._v("下面，我们通过一些示例性的代码来分别说明这两个规则：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("public class FinalExample {\n    int i;                            //普通变量\n    final int j;                      //final变量\n    static FinalExample obj;\n\n    public void FinalExample () {     //构造函数\n        i = 1;                        //写普通域\n        j = 2;                        //写final域\n    }\n\n    public static void writer () {    //写线程A执行\n        obj = new FinalExample ();\n    }\n\n    public static void reader () {       //读线程B执行\n        FinalExample object = obj;       //读对象引用\n        int a = object.i;                //读普通域\n        int b = object.j;                //读final域\n    }\n}\n\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br"),s("span",{staticClass:"line-number"},[a._v("21")]),s("br")])]),s("p",[s("img",{attrs:{src:"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==",alt:"",title:"点击并拖拽以移动"}})]),a._v(" "),s("p",[a._v("这里假设一个线程A执行writer ()方法，随后另一个线程B执行reader ()方法。下面我们通过这两个线程的交互来说明这两个规则。")]),a._v(" "),s("h2",{attrs:{id:"写final域的重排序规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#写final域的重排序规则"}},[a._v("#")]),a._v(" 写final域的重排序规则")]),a._v(" "),s("p",[a._v("写final域的重排序规则禁止把final域的写重排序到构造函数之外。这个规则的实现包含下面2个方面：")]),a._v(" "),s("ul",[s("li",[a._v("JMM禁止编译器把final域的写重排序到构造函数之外。")]),a._v(" "),s("li",[a._v("编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。")])]),a._v(" "),s("p",[a._v("现在让我们分析writer ()方法。writer ()方法只包含一行代码：finalExample = new FinalExample ()。这行代码包含两个步骤：")]),a._v(" "),s("ol",[s("li",[a._v("构造一个FinalExample类型的对象；")]),a._v(" "),s("li",[a._v("把这个对象的引用赋值给引用变量obj。")])]),a._v(" "),s("p",[a._v("假设线程B读对象引用与读对象的成员域之间没有重排序（马上会说明为什么需要这个假设），下图是一种可能的执行时序：")]),a._v(" "),s("p",[a._v("在上图中，写普通域的操作被编译器重排序到了构造函数之外，读线程B错误的读取了普通变量i初始化之前的值。而写final域的操作，被写final域的重排序规则“限定”在了构造函数之内，读线程B正确的读取了final变量初始化之后的值。")]),a._v(" "),s("p",[a._v("写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。以上图为例，在读线程B“看到”对象引用obj时，很可能obj对象还没有构造完成（对普通域i的写操作被重排序到构造函数外，此时初始值2还没有写入普通域i）。")]),a._v(" "),s("h2",{attrs:{id:"读final域的重排序规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#读final域的重排序规则"}},[a._v("#")]),a._v(" 读final域的重排序规则")]),a._v(" "),s("p",[a._v("读final域的重排序规则如下：")]),a._v(" "),s("ul",[s("li",[a._v("在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。")])]),a._v(" "),s("p",[a._v("初次读对象引用与初次读该对象包含的final域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，大多数处理器也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如alpha处理器），这个规则就是专门用来针对这种处理器。")]),a._v(" "),s("p",[a._v("reader()方法包含三个操作：")]),a._v(" "),s("ol",[s("li",[a._v("初次读引用变量obj;")]),a._v(" "),s("li",[a._v("初次读引用变量obj指向对象的普通域j。")]),a._v(" "),s("li",[a._v("初次读引用变量obj指向对象的final域i。")])]),a._v(" "),s("p",[a._v("现在我们假设写线程A没有发生任何重排序，同时程序在不遵守间接依赖的处理器上执行，下面是一种可能的执行时序：")]),a._v(" "),s("p",[a._v("在上图中，读对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该域还没有被写线程A写入，这是一个错误的读取操作。而读final域的重排序规则会把读对象final域的操作“限定”在读对象引用之后，此时该final域已经被A线程初始化过了，这是一个正确的读取操作。")]),a._v(" "),s("p",[a._v("读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。在这个示例程序中，如果该引用不为null，那么引用对象的final域一定已经被A线程初始化过了。")]),a._v(" "),s("h2",{attrs:{id:"如果final域是引用类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如果final域是引用类型"}},[a._v("#")]),a._v(" 如果final域是引用类型")]),a._v(" "),s("p",[a._v("上面我们看到的final域是基础数据类型，下面让我们看看如果final域是引用类型，将会有什么效果？")]),a._v(" "),s("p",[a._v("请看下列示例代码：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("public class FinalReferenceExample {\nfinal int[] intArray;                     //final是引用类型\nstatic FinalReferenceExample obj;\n\npublic FinalReferenceExample () {        //构造函数\n    intArray = new int[1];              //1\n    intArray[0] = 1;                   //2\n}\n\npublic static void writerOne () {          //写线程A执行\n    obj = new FinalReferenceExample ();  //3\n}\n\npublic static void writerTwo () {          //写线程B执行\n    obj.intArray[0] = 2;                 //4\n}\n\npublic static void reader () {              //读线程C执行\n    if (obj != null) {                    //5\n        int temp1 = obj.intArray[0];       //6\n    }\n}\n}\n\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br"),s("span",{staticClass:"line-number"},[a._v("21")]),s("br"),s("span",{staticClass:"line-number"},[a._v("22")]),s("br"),s("span",{staticClass:"line-number"},[a._v("23")]),s("br"),s("span",{staticClass:"line-number"},[a._v("24")]),s("br")])]),s("p",[s("img",{attrs:{src:"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==",alt:"",title:"点击并拖拽以移动"}})]),a._v(" "),s("p",[a._v("这里final域为一个引用类型，它引用一个int型的数组对象。对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：")]),a._v(" "),s("ol",[s("li",[a._v("在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。")])]),a._v(" "),s("p",[a._v("对上面的示例程序，我们假设首先线程A执行writerOne()方法，执行完后线程B执行writerTwo()方法，执行完后线程C执行reader ()方法。下面是一种可能的线程执行时序：")]),a._v(" "),s("p",[a._v("在上图中，1是对final域的写入，2是对这个final域引用的对象的成员域的写入，3是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的1不能和3重排序外，2和3也不能重排序。")]),a._v(" "),s("p",[a._v("JMM可以确保读线程C至少能看到写线程A在构造函数中对final引用对象的成员域的写入。即C至少能看到数组下标0的值为1。而写线程B对数组元素的写入，读线程C可能看的到，也可能看不到。JMM不保证线程B的写入对读线程C可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知。")]),a._v(" "),s("p",[a._v("如果想要确保读线程C看到写线程B对数组元素的写入，写线程B和读线程C之间需要使用同步原语（lock或volatile）来确保内存可见性。")]),a._v(" "),s("h2",{attrs:{id:"为什么final引用不能从构造函数内-逸出"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么final引用不能从构造函数内-逸出"}},[a._v("#")]),a._v(" 为什么final引用不能从构造函数内“逸出”")]),a._v(" "),s("p",[a._v("前面我们提到过，写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中“逸出”。为了说明问题，让我们来看下面示例代码：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("public class FinalReferenceEscapeExample {\nfinal int i;\nstatic FinalReferenceEscapeExample obj;\n\npublic FinalReferenceEscapeExample () {\n    i = 1;                              //1写final域\n    obj = this;                          //2 this引用在此“逸出”\n}\n\npublic static void writer() {\n    new FinalReferenceEscapeExample ();\n}\n\npublic static void reader {\n    if (obj != null) {                     //3\n        int temp = obj.i;                 //4\n    }\n}\n}\n\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br")])]),s("p",[s("img",{attrs:{src:"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==",alt:"",title:"点击并拖拽以移动"}})]),a._v(" "),s("p",[a._v("假设一个线程A执行writer()方法，另一个线程B执行reader()方法。这里的操作2使得对象还未完成构造前就为线程B可见。即使这里的操作2是构造函数的最后一步，且即使在程序中操作2排在操作1后面，执行read()方法的线程仍然可能无法看到final域被初始化后的值，因为这里的操作1和操作2之间可能被重排序。实际的执行时序可能如下图所示：")]),a._v(" "),s("p",[a._v("从上图我们可以看出：在构造函数返回前，被构造对象的引用不能为其他线程可见，因为此时的final域可能还没有被初始化。在构造函数返回后，任意线程都将保证能看到final域正确初始化之后的值。")]),a._v(" "),s("h2",{attrs:{id:"final语义在处理器中的实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#final语义在处理器中的实现"}},[a._v("#")]),a._v(" final语义在处理器中的实现")]),a._v(" "),s("p",[a._v("现在我们以x86处理器为例，说明final语义在处理器中的具体实现。")]),a._v(" "),s("p",[a._v("上面我们提到，写final域的重排序规则会要求译编器在final域的写之后，构造函数return之前，插入一个StoreStore障屏。读final域的重排序规则要求编译器在读final域的操作前面插入一个LoadLoad屏障。")]),a._v(" "),s("p",[a._v("由于x86处理器不会对写-写操作做重排序，所以在x86处理器中，写final域需要的StoreStore障屏会被省略掉。同样，由于x86处理器不会对存在间接依赖关系的操作做重排序，所以在x86处理器中，读final域需要的LoadLoad屏障也会被省略掉。也就是说在x86处理器中，final域的读/写不会插入任何内存屏障！")]),a._v(" "),s("h2",{attrs:{id:"jsr-133为什么要增强final的语义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jsr-133为什么要增强final的语义"}},[a._v("#")]),a._v(" JSR-133为什么要增强final的语义")]),a._v(" "),s("p",[a._v("在旧的Java内存模型中 ，最严重的一个缺陷就是线程可能看到final域的值会改变。比如，一个线程当前看到一个整形final域的值为0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个final域的值时，却发现值变为了1（被某个线程初始化之后的值）。最常见的例子就是在旧的Java内存模型中，String的值可能会改变（参考文献2中有一个具体的例子，感兴趣的读者可以自行参考，这里就不赘述了）。")]),a._v(" "),s("p",[a._v("为了修补这个漏洞，JSR-133专家组增强了final的语义。通过为final域增加写和读重排序规则，可以为java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用），就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。")]),a._v(" "),s("h2",{attrs:{id:"参考文献"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[a._v("#")]),a._v(" 参考文献")]),a._v(" "),s("ol",[s("li",[s("p",[s("a",{attrs:{href:"http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601/ref=pd_sim_b_1",target:"_blank",rel:"noopener noreferrer"}},[a._v(" Java Concurrency in Practice"),s("OutboundLink")],1)])]),a._v(" "),s("li",[s("p",[s("a",{attrs:{href:"http://www.cs.umd.edu/users/pugh/java/memoryModel/jsr-133-faq.html",target:"_blank",rel:"noopener noreferrer"}},[a._v(" JSR 133 (Java Memory Model) FAQ"),s("OutboundLink")],1)])]),a._v(" "),s("li",[s("p",[s("a",{attrs:{href:"http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601/ref=pd_sim_b_1",target:"_blank",rel:"noopener noreferrer"}},[a._v(" Java Concurrency in Practice"),s("OutboundLink")],1)])]),a._v(" "),s("li",[s("p",[s("a",{attrs:{href:"http://gee.cs.oswego.edu/dl/jmm/cookbook.html",target:"_blank",rel:"noopener noreferrer"}},[a._v(" The JSR-133 Cookbook for Compiler Writers"),s("OutboundLink")],1)])])]),a._v(" "),s("p",[s("a",{attrs:{href:"http://download.intel.com/products/processor/manual/253668.pdf",target:"_blank",rel:"noopener noreferrer"}},[a._v("Intel® 64 and IA-32 ArchitecturesvSoftware Developer’s Manual Volume 3A: System Programming Guide, Part 1"),s("OutboundLink")],1)])])}),[],!1,null,null,null);n.default=e.exports}}]);