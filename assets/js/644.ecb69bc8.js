(window.webpackJsonp=window.webpackJsonp||[]).push([[644],{1034:function(a,n,r){"use strict";r.r(n);var t=r(13),v=Object(t.a)({},(function(){var a=this,n=a.$createElement,r=a._self._c||n;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("p",[a._v("我们知道synchronized是重量级锁，效率不怎么样，不过在JDK6中对synchronize的实现进行了各种优化，使得它显得不是那么重了，那么JVM采用了那些优化手段呢")]),a._v(" "),r("h1",{attrs:{id:"锁优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#锁优化"}},[a._v("#")]),a._v(" 锁优化")]),a._v(" "),r("p",[a._v("如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。 \n锁主要存在四种状态：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态\n他们会随着竞争的激烈而逐渐升级。\n注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率")]),a._v(" "),r("h2",{attrs:{id:"自旋锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#自旋锁"}},[a._v("#")]),a._v(" 自旋锁")]),a._v(" "),r("p",[a._v("线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。\n同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。\n \n所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。")]),a._v(" "),r("p",[a._v("怎么等待呢？执行一段无意义的循环即可（自旋）。\n \n自旋等待不能替代阻塞，先不说对处理器数量的要求，虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。\n如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。\n所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。")]),a._v(" "),r("p",[a._v("自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整； \n如果通过参数-XX:preBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。")]),a._v(" "),r("h2",{attrs:{id:"适应自旋锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#适应自旋锁"}},[a._v("#")]),a._v(" 适应自旋锁")]),a._v(" "),r("p",[a._v("JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。\n所谓自适应就意味着自旋的次数不再是固定的，它由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。")]),a._v(" "),r("p",[a._v("它怎么做呢？\n线程如果自旋成功了，那么下次自旋的次数会更多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。")]),a._v(" "),r("p",[a._v("有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。")]),a._v(" "),r("h2",{attrs:{id:"锁消除"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#锁消除"}},[a._v("#")]),a._v(" 锁消除")]),a._v(" "),r("p",[a._v("为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这时JVM会对这些同步锁进行锁消除。")]),a._v(" "),r("p",[a._v("锁消除的依据是逃逸分析的数据支持。\n \n如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。\n变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？但有时候程序并不是我们所想的那样,我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法")]),a._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v('    public void vectorTest(){\n        Vector<String> vector = new Vector<String>();\n        for(int i = 0 ; i < 10 ; i++){\n            vector.add(i + "");\n        }\n\n        System.out.println(vector);\n    }\n')])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br"),r("span",{staticClass:"line-number"},[a._v("2")]),r("br"),r("span",{staticClass:"line-number"},[a._v("3")]),r("br"),r("span",{staticClass:"line-number"},[a._v("4")]),r("br"),r("span",{staticClass:"line-number"},[a._v("5")]),r("br"),r("span",{staticClass:"line-number"},[a._v("6")]),r("br"),r("span",{staticClass:"line-number"},[a._v("7")]),r("br"),r("span",{staticClass:"line-number"},[a._v("8")]),r("br")])]),r("p",[a._v("在运行这段代码时，JVM可以明显检测到变量vector没有逃逸出方法vectorTest()之外，所以JVM可以大胆地将vector内部的加锁操作消除。")]),a._v(" "),r("h2",{attrs:{id:"锁粗化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#锁粗化"}},[a._v("#")]),a._v(" 锁粗化")]),a._v(" "),r("p",[a._v("我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小,即仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁")]),a._v(" "),r("p",[a._v("在大多数的情况下，上述观点是正确的，本人也一直坚持着这个观点。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗化的概念:\n就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁")]),a._v(" "),r("p",[a._v("如上面实例：vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环外")]),a._v(" "),r("h2",{attrs:{id:"轻量级锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#轻量级锁"}},[a._v("#")]),a._v(" 轻量级锁")]),a._v(" "),r("p",[a._v("主要目的是在没有多线程竞争的前提下，减少传统的重量级锁使用OS的互斥量(mutex)产生的性能消耗。\n当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下： \n###"),r("strong",[a._v("获取锁")])]),a._v(" "),r("ol",[r("li",[a._v("判断当前对象是否处于无锁状态（hashcode、0、01）\n"),r("ul",[r("li",[a._v("是\nJVM将首先在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）")]),a._v(" "),r("li",[a._v("否\n执行3")])])]),a._v(" "),r("li",[a._v("JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正\n"),r("ul",[r("li",[a._v("成功(表示竞争到锁)\n将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作")]),a._v(" "),r("li",[a._v("失败\n执行3")])])]),a._v(" "),r("li",[a._v("判断当前对象的Mark Word是否指向当前线程的栈帧\n"),r("ul",[r("li",[a._v("是(表示当前线程已经持有当前对象的锁)\n直接执行同步代码块")]),a._v(" "),r("li",[a._v("否(只能说明该锁对象已经被其他线程抢占)\n轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态\n###"),r("strong",[a._v("释放锁")]),a._v(" \n轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：")])])]),a._v(" "),r("li",[a._v("取出获取轻量级锁时保存在Displaced Mark Word中的数据")]),a._v(" "),r("li",[a._v("用CAS操作将取出的数据替换到当前对象的Mark Word中\n"),r("ul",[r("li",[a._v("成功\n说明释放锁成功")]),a._v(" "),r("li",[a._v("失败\n执行3")])])]),a._v(" "),r("li",[a._v("CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程")])]),a._v(" "),r("p",[a._v('对于轻量级锁，其性能提升的依据是\n"对于绝大部分的锁，在整个生命周期内都是不会存在竞争的"\n如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢')]),a._v(" "),r("hr"),a._v(" "),r("p",[a._v("下图是轻量级锁的获取和释放过程 \n"),r("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/4685968-835dc27a4cab0094.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}})]),a._v(" "),r("h2",{attrs:{id:"偏向锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#偏向锁"}},[a._v("#")]),a._v(" 偏向锁")]),a._v(" "),r("p",[a._v("目的：在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。\n上面提到了轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的。\n那么偏向锁是如何来减少不必要的CAS操作呢？\n我们可以查看Mark work的结构就明白了。\n只需要检查是否为偏向锁、锁标识为以及ThreadID即可，处理流程如下： \n###"),r("strong",[a._v("获取锁")])]),a._v(" "),r("ol",[r("li",[a._v("检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01")]),a._v(" "),r("li",[a._v("若为可偏向状态，则测试线程ID是否为当前线程ID\n"),r("ul",[r("li",[a._v("是\n执行5")]),a._v(" "),r("li",[a._v("否\n执行3")])])]),a._v(" "),r("li",[a._v("如果线程ID不为当前线程ID，则通过CAS操作竞争锁,竞争\n"),r("ul",[r("li",[a._v("成功\n将Mark Word的线程ID替换为当前线程ID，")]),a._v(" "),r("li",[a._v("失败\n执行4")])])]),a._v(" "),r("li",[a._v("CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块")]),a._v(" "),r("li",[a._v("执行同步代码块\n###"),r("strong",[a._v("释放锁")]),a._v(" \n偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。\n偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：")]),a._v(" "),r("li",[a._v("暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态")]),a._v(" "),r("li",[a._v("撤销偏向锁，恢复到无锁状态（01）或者轻量级锁的状态")])]),a._v(" "),r("hr"),a._v(" "),r("p",[a._v("下图是偏向锁的获取和释放流程 \n"),r("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/4685968-15051bba71218318?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}})]),a._v(" "),r("h2",{attrs:{id:"重量级锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#重量级锁"}},[a._v("#")]),a._v(" 重量级锁")]),a._v(" "),r("p",[a._v("重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高")])])}),[],!1,null,null,null);n.default=v.exports}}]);