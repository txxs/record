(window.webpackJsonp=window.webpackJsonp||[]).push([[657],{1068:function(n,a,s){"use strict";s.r(a);var e=s(13),t=Object(e.a)({},(function(){var n=this,a=n.$createElement,s=n._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h1",{attrs:{id:"_1-概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-概述"}},[n._v("#")]),n._v(" 1 概述")]),n._v(" "),s("p",[n._v("HashMap是基于哈希表实现的,每一个元素是一个key-value对,其内部通过单链表解决冲突问题,容量不足(超过了阀值)时,同样会自动增长.")]),n._v(" "),s("p",[n._v("HashMap是非线程安全的,只适用于单线程环境,多线程环境可以采用并发包下的"),s("code",[n._v("concurrentHashMap")])]),n._v(" "),s("p",[n._v("HashMap 实现了Serializable接口，因此它支持序列化，实现了Cloneable接口，能被克隆")]),n._v(" "),s("p",[n._v("HashMap是基于哈希表的Map接口的非同步实现.此实现提供所有可选的映射操作,并允许使用null值和null键.此类不保证映射的顺序,特别是它不保证该顺序恒久不变.")]),n._v(" "),s("p",[n._v("Java8中又对此类底层实现进行了优化，比如引入了红黑树的结构以解决哈希碰撞")]),n._v(" "),s("h1",{attrs:{id:"_2-hashmap的数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-hashmap的数据结构"}},[n._v("#")]),n._v(" 2 HashMap的数据结构")]),n._v(" "),s("p",[n._v('在Java中,最基本的结构就是两种,一个是数组,另外一个是模拟指针(引用),所有的数据结构都可以用这两个基本结构来构造,HashMap也不例外.\nHashMap实际上是一个"链表散列"的数据结构,即数组和链表的结合体.')]),n._v(" "),s("p",[s("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/4685968-cd353393ebc2ddf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"HashMap的结构"}}),n._v("\nHashMap的主结构类似于一个数组,添加值时通过"),s("code",[n._v("key")]),n._v("确定储存位置.\n每个位置是一个Entry的数据结构,该结构可组成链表.\n当发生冲突时,相同hash值的键值对会组成链表.\n这种"),s("code",[n._v("数组+链表")]),n._v("的组合形式大部分情况下都能有不错的性能效果,Java6、7就是这样设计的.\n然而,在极端情况下,一组（比如经过精心设计的）键值对都发生了冲突，这时的哈希结构就会退化成一个链表，使HashMap性能急剧下降.")]),n._v(" "),s("p",[n._v("所以在Java8中,HashMap的结构实现变为数组+链表+红黑树\n"),s("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-0e08421c5183e8ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"Java8 HashMap的结构"}}),n._v("\n可以看出,HashMap底层就是一个数组结构\n数组中的每一项又是一个链表\n当新建一个HashMap时,就会初始化一个数组.")]),n._v(" "),s("h1",{attrs:{id:"_3-三大集合与迭代子"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-三大集合与迭代子"}},[n._v("#")]),n._v(" 3 三大集合与迭代子")]),n._v(" "),s("p",[n._v("HashMap使用三大集合和三种迭代子来轮询其Key、Value和Entry对象")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('public class HashMapExam {\n    public static void main(String[] args) {\n        Map<Integer, String> map = new HashMap<>(16);\n        for (int i = 0; i < 15; i++) {\n            map.put(i, new String(new char[]{(char) (\'A\'+ i)}));\n        }\n\n        System.out.println("======keySet=======");\n        Set<Integer> set = map.keySet();\n        Iterator<Integer> iterator = set.iterator();\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n\n        System.out.println("======values=======");\n        Collection<String> values = map.values();\n        Iterator<String> stringIterator=values.iterator();\n        while (stringIterator.hasNext()) {\n            System.out.println(stringIterator.next());\n        }\n\n        System.out.println("======entrySet=======");\n        for (Map.Entry<Integer, String> entry : map.entrySet()) {\n            System.out.println(entry);\n        }\n    }\n}\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br")])]),s("h1",{attrs:{id:"_4-源码分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-源码分析"}},[n._v("#")]),n._v(" 4 源码分析")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("    //默认的初始容量16,且实际容量是2的整数幂 \n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;\n    \n    //最大容量(传入容量过大将被这个值替换)\n    static final int MAXIMUM_CAPACITY = 1 << 30;\n     \n    // 默认加载因子为0.75(当表达到3/4满时,才会再散列),这个因子在时间和空间代价之间达到了平衡.更高的因子可以降低表所需的空间,但是会增加查找代价,而查找是最频繁操作\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n\t//桶的树化阈值：即 链表转成红黑树的阈值，在存储数据时，当链表长度 >= 8时，则将链表转换成红黑树\n    static final int TREEIFY_THRESHOLD = 8;\n   // 桶的链表还原阈值：即 红黑树转为链表的阈值，当在扩容（resize（））时（HashMap的数据存储位置会重新计算），在重新计算存储位置后，当原有的红黑树内数量 <= 6时，则将 红黑树转换成链表\n    static final int UNTREEIFY_THRESHOLD = 6;\n   //最小树形化容量阈值：即 当哈希表中的容量 > 该值时，才允许树形化链表 （即 将链表 转换成红黑树）\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br")])]),s("p",[n._v("因为红黑树的平均查找长度是log(n)，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为8/2=4，这才有转换为树的必要\n链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短")]),n._v(" "),s("p",[n._v("还有选择6和8，中间有个差值7可以有效防止链表和树频繁转换\n假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('    // 为了避免扩容/树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD\n    // 小于该值时使用的是扩容哦!!!\n    static final int MIN_TREEIFY_CAPACITY = 64;\n    \n    // 存储数据的Node数组,长度是2的幂.    \n    // HashMap采用链表法解决冲突，每一个Node本质上是一个单向链表 \n    //HashMap底层存储的数据结构,是一个Node数组.上面得知Node类为元素维护了一个单向链表.至此,HashMap存储的数据结构也就很清晰了:维护了一个数组,每个数组又维护了一个单向链表.之所以这么设计,考虑到遇到哈希冲突的时候,同index的value值就用单向链表来维护\n    //与 JDK 1.7 的对比（Entry类），仅仅只是换了名字\n    transient Node<K,V>[] table;\n\n    // HashMap的底层数组中已用槽的数量 \n    transient int size;\n    // HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子） \n    int threshold;\n    \n    // 负载因子实际大小\n    final float loadFactor;\n    \n    // HashMap被改变的次数 \n    transient int modCount;\n    \n    // 指定“容量大小”和“加载因子”的构造函数,是最基础的构造函数\n    public HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException("Illegal initial capacity: " +\n                                               initialCapacity);\n        // HashMap的最大容量只能是MAXIMUM_CAPACITY                                       \n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        //负载因子须大于0\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException("Illegal load factor: " +\n                                               loadFactor);\n        // 设置"负载因子"                                        \n        this.loadFactor = loadFactor;\n        // 设置"HashMap阈值",当HashMap中存储数据的数量达到threshold时,就需将HashMap的容量加倍    \n        this.threshold = tableSizeFor(initialCapacity);\n    }\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br")])]),s("ul",[s("li",[n._v("上面的tableSizeFor有何用?\ntableSizeFor方法保证函数返回值是大于等于给定参数initialCapacity最小的2的幂次方的数值")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br")])]),s("p",[n._v("可以看出该方法是一系列的二进制位操作")]),n._v(" "),s("blockquote",[s("p",[n._v("a |= b 等同于 a = a|b")])]),n._v(" "),s("p",[n._v("逐行分析")]),n._v(" "),s("ul",[s("li",[s("p",[s("code",[n._v("int n = cap - 1")]),n._v("\n给定的cap 减 1,为了避免参数cap本来就是2的幂次方,这样一来,经过后续操作，cap将会变成2 * cap,是不符合我们预期的")])]),n._v(" "),s("li",[s("p",[s("code",[n._v("n |= n >>> 1")]),n._v("\nn >>> 1 : n无符号右移1位,即n二进制最高位的1右移一位\nn | (n >>> 1) 导致 n二进制的高2位值为1\n目前n的高1~2位均为1")])]),n._v(" "),s("li",[s("p",[s("code",[n._v("n |= n >>> 2")]),n._v("\nn继续无符号右移2位\nn | (n >>> 2) 导致n二进制表示的高3~4位经过运算值均为1\n目前n的高1~4位均为1")])]),n._v(" "),s("li",[s("p",[s("code",[n._v("n |= n >>> 4")]),n._v("\nn继续无符号右移4位\nn | (n >>> 4) 导致n二进制表示的高5~8位经过运算值均为1\n目前n的高1~8位均为1")])]),n._v(" "),s("li",[s("p",[s("code",[n._v("n |= n >>> 8")]),n._v("\nn继续无符号右移8位\nn | (n >>> 8) 导致n二进制表示的高9~16位经过运算值均为1\n目前n的高1~16位均为1")])])]),n._v(" "),s("p",[n._v("可以看出,无论给定cap(cap < MAXIMUM_CAPACITY )的值是多少,经过以上运算,其值的二进制所有位都会是1.再将其加1,这时候这个值一定是2的幂次方.\n当然如果经过运算值大于MAXIMUM_CAPACITY,直接选用MAXIMUM_CAPACITY.")]),n._v(" "),s("p",[s("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/4685968-ffb968a6b1a70fa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}})]),n._v(" "),s("p",[n._v("至此tableSizeFor如何保证cap为2的幂次方已经显而易见了,那么问题来了")]),n._v(" "),s("h2",{attrs:{id:"_4-1-为什么cap要保持为2的幂次方"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-为什么cap要保持为2的幂次方"}},[n._v("#")]),n._v(" 4.1 "),s("strong",[n._v("为什么cap要保持为2的幂次方？")])]),n._v(" "),s("p",[n._v("主要与HashMap中的数据存储有关.")]),n._v(" "),s("p",[n._v("在Java8中,HashMap中key的Hash值由Hash(key)方法计得\n"),s("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-e8540295874593d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}})]),n._v(" "),s("p",[n._v("HashMap中存储数据table的index是由key的Hash值决定的.\n在HashMap存储数据时,我们期望数据能均匀分布,以防止哈希冲突.\n自然而然我们就会想到去用"),s("code",[n._v("%")]),n._v("取余操作来实现我们这一构想")]),n._v(" "),s("blockquote",[s("p",[n._v("取余(%)操作 : 如果除数是2的幂次则等价于与其除数减一的与(&)操作.")])]),n._v(" "),s("p",[n._v("这也就解释了为什么一定要求cap要为2的幂次方.再来看看table的index的计算规则：\n"),s("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-ddd3a2805bea14c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}}),n._v("\n等价于:")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v(" index = e.hash % newCap\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br")])]),s("p",[n._v("采用二进制位操作&,相对于%,能够提高运算效率,这就是cap的值被要求为2幂次的原因\n"),s("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-5b47864c20546b8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}}),n._v(" "),s("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-80fbc4a63ab41290.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"数据结构 & 参数与 JDK 7 / 8"}})]),n._v(" "),s("h2",{attrs:{id:"_4-2-node类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-node类"}},[n._v("#")]),n._v(" 4.2 "),s("strong",[n._v("Node类")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('static class Node<K,V> implements Map.Entry<K,V> {\n        final int hash;\n        final K key;\n        V value;\n        Node<K,V> next;\n\n        Node(int hash, K key, V value, Node<K,V> next) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n\n        public final K getKey()        { return key; }\n        public final V getValue()      { return value; }\n        public final String toString() { return key + "=" + value; }\n\n        public final int hashCode() {\n            return Objects.hashCode(key) ^ Objects.hashCode(value);\n        }\n\n        public final V setValue(V newValue) {\n            V oldValue = value;\n            value = newValue;\n            return oldValue;\n        }\n\n        public final boolean equals(Object o) {\n            if (o == this)\n                return true;\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n                if (Objects.equals(key, e.getKey()) &&\n                    Objects.equals(value, e.getValue()))\n                    return true;\n            }\n            return false;\n        }\n    }\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br"),s("span",{staticClass:"line-number"},[n._v("39")]),s("br")])]),s("p",[n._v("Node<K,V> 类是HashMap中的静态内部类,实现Map.Entry<K,V>接口.定义了key键、value值、next节点,也就是说元素之间构成了单向链表.")]),n._v(" "),s("h2",{attrs:{id:"_4-3-treenode"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-treenode"}},[n._v("#")]),n._v(" 4.3 TreeNode")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n        TreeNode<K,V> parent;  // red-black tree links\n        TreeNode<K,V> left;\n        TreeNode<K,V> right;\n        TreeNode<K,V> prev;    // needed to unlink next upon deletion\n        boolean red;\n        TreeNode(int hash, K key, V val, Node<K,V> next) {}\n\n        // 返回当前节点的根节点  \n        final TreeNode<K,V> root() {  \n          for (TreeNode<K,V> r = this, p;;) {  \n            if ((p = r.parent) == null)  \n                return r;  \n            r = p;  \n        }  \n    } \n }\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br")])]),s("p",[n._v("红黑树结构包含前、后、左、右节点，以及标志是否为红黑树的字段\n此结构是Java8新加的")]),n._v(" "),s("h2",{attrs:{id:"_4-4-hash方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-hash方法"}},[n._v("#")]),n._v(" 4.4 hash方法")]),n._v(" "),s("p",[n._v("Java 8中的散列值优化函数\n"),s("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-2c057211c7051fd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}}),n._v("\n只做一次16位右位移异或\nkey.hashCode()函数调用的是key键值类型自带的哈希函数，返回int型散列值")]),n._v(" "),s("p",[n._v('理论上散列值是一个int型，如果直接拿散列值作为下标访问HashMap主数组的话，考虑到2进制32位带符号的int范围大概40亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。\n但问题是一个40亿长度的数组，内存是放不下的.HashMap扩容之前的数组初始大小才16,所以这个散列值是不能直接拿来用的.\n用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标\n源码中模运算就是把散列值和数组长度做一个"与"操作，\n'),s("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-4fcd8fe2039d26c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}}),n._v("\n这也正好解释了为什么HashMap的数组长度要取2的整次幂\n因为这样（数组长度-1）正好相当于一个“低位掩码”\n“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问")]),n._v(" "),s("p",[n._v("以初始长度16为例，16-1=15\n2进制表示是00000000 00000000 00001111\n和某散列值做“与”操作如下，结果就是截取了最低的四位值\n"),s("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-89fececc1ca1c0b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}}),n._v("\n但这时候问题就来了,这样就算我的散列值分布再松散,要是只取最后几位的话,碰撞也会很严重")]),n._v(" "),s("p",[n._v("这时候“扰动函数”的价值就体现出来了\n"),s("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-4825a9e897a9723b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}}),n._v("\n右位移16位，正好是32位一半，自己的高半区和低半区做异或，就是为了混合原始hashCode的高位和低位，以此来加大低位的随机性\n而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。")]),n._v(" "),s("p",[n._v("index的运算规则是")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("e.hash & (newCap - 1)\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br")])]),s("p",[n._v("newCap是2的幂,所以newCap - 1的高位全0")]),n._v(" "),s("p",[n._v("若e.hash值只用自身的hashcode,index只会和e.hash的低位做&操作.这样一来,index的值就只有低位参与运算,高位毫无存在感,从而会带来哈希冲突的风险\n所以在计算key的hashCode时,用其自身hashCode与其低16位做异或操作\n这也就让高位参与到index的计算中来了,即降低了哈希冲突的风险又不会带来太大的性能问题")]),n._v(" "),s("h2",{attrs:{id:"_4-5-put方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-put方法"}},[n._v("#")]),n._v(" 4.5 Put方法")]),n._v(" "),s("p",[s("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-ac54873c0837d3ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}})]),n._v(" "),s("p",[s("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-76c3c90239e1f15e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}})]),n._v(" "),s("p",[s("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/4685968-0ccc069e89b40e4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"HashMap-put(k,v)"}}),n._v("\n①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容")]),n._v(" "),s("p",[n._v("②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③")]),n._v(" "),s("p",[n._v("③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals")]),n._v(" "),s("p",[n._v("④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤")]),n._v(" "),s("p",[n._v("⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可")]),n._v(" "),s("p",[n._v("⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，执行resize()扩容")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v(" public V put(K key, V value) {\n        // 对key的hashCode()做hash\n        return putVal(hash(key), key, value, false, true);\n    }\n    \nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        // 步骤① tab为空则调用resize()初始化创建\n        if ((tab = table) == null || (n = tab.length) == 0)         \n            n = (tab = resize()).length;\n        // 步骤② 计算index,并对null做处理  \n        //tab[i = (n - 1) & hash对应下标的第一个节点   \n        if ((p = tab[i = (n - 1) & hash]) == null)\n            // 无哈希冲突的情况下,将value直接封装为Node并赋值\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node<K,V> e; K k;\n            // 步骤③ 节点的key相同,直接覆盖节点\n            if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            // 步骤④ 判断该链为红黑树    \n            else if (p instanceof TreeNode)\n                 // p是红黑树类型，则调用putTreeVal方式赋值\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            // 步骤⑤ p非红黑树类型,该链为链表    \n            else {\n                // index 相同的情况下\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        // 如果p的next为空,将新的value值添加至链表后面\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount >= TREEIFY_THRESHOLD - 1)\n                            // 如果链表长度大于8,链表转化为红黑树,执行插入\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    // key相同则跳出循环\n                    if (e.hash == hash &&  ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    //就是移动指针方便继续取 p.next\n    \n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                //根据规则选择是否覆盖value\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        // 步骤⑥:超过最大容量,就扩容\n        if (++size > threshold)\n            // size大于加载因子,扩容\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br"),s("span",{staticClass:"line-number"},[n._v("39")]),s("br"),s("span",{staticClass:"line-number"},[n._v("40")]),s("br"),s("span",{staticClass:"line-number"},[n._v("41")]),s("br"),s("span",{staticClass:"line-number"},[n._v("42")]),s("br"),s("span",{staticClass:"line-number"},[n._v("43")]),s("br"),s("span",{staticClass:"line-number"},[n._v("44")]),s("br"),s("span",{staticClass:"line-number"},[n._v("45")]),s("br"),s("span",{staticClass:"line-number"},[n._v("46")]),s("br"),s("span",{staticClass:"line-number"},[n._v("47")]),s("br"),s("span",{staticClass:"line-number"},[n._v("48")]),s("br"),s("span",{staticClass:"line-number"},[n._v("49")]),s("br"),s("span",{staticClass:"line-number"},[n._v("50")]),s("br"),s("span",{staticClass:"line-number"},[n._v("51")]),s("br"),s("span",{staticClass:"line-number"},[n._v("52")]),s("br"),s("span",{staticClass:"line-number"},[n._v("53")]),s("br"),s("span",{staticClass:"line-number"},[n._v("54")]),s("br"),s("span",{staticClass:"line-number"},[n._v("55")]),s("br"),s("span",{staticClass:"line-number"},[n._v("56")]),s("br"),s("span",{staticClass:"line-number"},[n._v("57")]),s("br"),s("span",{staticClass:"line-number"},[n._v("58")]),s("br"),s("span",{staticClass:"line-number"},[n._v("59")]),s("br"),s("span",{staticClass:"line-number"},[n._v("60")]),s("br"),s("span",{staticClass:"line-number"},[n._v("61")]),s("br")])]),s("p",[n._v("在构造函数中最多也只是设置了initialCapacity、loadFactor的值,并没有初始化table,table的初始化工作是在put方法中进行的.")]),n._v(" "),s("h2",{attrs:{id:"_4-6-resize"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-resize"}},[n._v("#")]),n._v(" 4.6 resize")]),n._v(" "),s("p",[s("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-fd60bec62611e900.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}}),n._v("\n扩容(resize)就是重新计算容量,向HashMap对象里不停的添加元素,内部的数组无法装载更多的元素时,就需要扩大数组的长度.\n当然Java里的数组是无法自动扩容的,方法是使用一个新的数组代替已有的容量小的数组")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('   /**\n     * 该函数有2种使用情况：1.初始化哈希表 2.当前数组容量过小，需扩容\n     */\nfinal Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n\n        // 针对情况2：若扩容前的数组容量超过最大值，则不再扩充\n        if (oldCap > 0) {\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            // 针对情况2：若无超过最大值，就扩充为原来的2倍\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                //newCap设置为oldCap的2倍并小于MAXIMUM_CAPACITY，且大于默认值, 新的threshold增加为原来的2倍\n                newThr = oldThr << 1; // double threshold\n        }\n     \n        // 针对情况1：初始化哈希表（采用指定 or 默认值）\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            // threshold>0, 将threshold设置为newCap,所以要用tableSizeFor方法保证threshold是2的幂次方\n            newCap = oldThr;\n        else {               // zero initial threshold signifies using defaults\n            // 默认初始化\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n\n        // 计算新的resize上限\n        if (newThr == 0) {\n            // newThr为0，newThr = newCap * 0.75\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;\n        @SuppressWarnings({"rawtypes","unchecked"})\n            // 新生成一个table数组\n            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        table = newTab;\n        if (oldTab != null) {\n            // oldTab 复制到 newTab\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                       // 链表只有一个节点，直接赋值\n                       //为什么要重新Hash呢？因为长度扩大以后，Hash的规则也随之改变。\n                        newTab[e.hash & (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        // e为红黑树的情况\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // preserve order链表优化重hash的代码块\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            // 原索引\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            // 原索引 + oldCap\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        // 原索引放到bucket里\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        // 原索引+oldCap放到bucket里\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br"),s("span",{staticClass:"line-number"},[n._v("39")]),s("br"),s("span",{staticClass:"line-number"},[n._v("40")]),s("br"),s("span",{staticClass:"line-number"},[n._v("41")]),s("br"),s("span",{staticClass:"line-number"},[n._v("42")]),s("br"),s("span",{staticClass:"line-number"},[n._v("43")]),s("br"),s("span",{staticClass:"line-number"},[n._v("44")]),s("br"),s("span",{staticClass:"line-number"},[n._v("45")]),s("br"),s("span",{staticClass:"line-number"},[n._v("46")]),s("br"),s("span",{staticClass:"line-number"},[n._v("47")]),s("br"),s("span",{staticClass:"line-number"},[n._v("48")]),s("br"),s("span",{staticClass:"line-number"},[n._v("49")]),s("br"),s("span",{staticClass:"line-number"},[n._v("50")]),s("br"),s("span",{staticClass:"line-number"},[n._v("51")]),s("br"),s("span",{staticClass:"line-number"},[n._v("52")]),s("br"),s("span",{staticClass:"line-number"},[n._v("53")]),s("br"),s("span",{staticClass:"line-number"},[n._v("54")]),s("br"),s("span",{staticClass:"line-number"},[n._v("55")]),s("br"),s("span",{staticClass:"line-number"},[n._v("56")]),s("br"),s("span",{staticClass:"line-number"},[n._v("57")]),s("br"),s("span",{staticClass:"line-number"},[n._v("58")]),s("br"),s("span",{staticClass:"line-number"},[n._v("59")]),s("br"),s("span",{staticClass:"line-number"},[n._v("60")]),s("br"),s("span",{staticClass:"line-number"},[n._v("61")]),s("br"),s("span",{staticClass:"line-number"},[n._v("62")]),s("br"),s("span",{staticClass:"line-number"},[n._v("63")]),s("br"),s("span",{staticClass:"line-number"},[n._v("64")]),s("br"),s("span",{staticClass:"line-number"},[n._v("65")]),s("br"),s("span",{staticClass:"line-number"},[n._v("66")]),s("br"),s("span",{staticClass:"line-number"},[n._v("67")]),s("br"),s("span",{staticClass:"line-number"},[n._v("68")]),s("br"),s("span",{staticClass:"line-number"},[n._v("69")]),s("br"),s("span",{staticClass:"line-number"},[n._v("70")]),s("br"),s("span",{staticClass:"line-number"},[n._v("71")]),s("br"),s("span",{staticClass:"line-number"},[n._v("72")]),s("br"),s("span",{staticClass:"line-number"},[n._v("73")]),s("br"),s("span",{staticClass:"line-number"},[n._v("74")]),s("br"),s("span",{staticClass:"line-number"},[n._v("75")]),s("br"),s("span",{staticClass:"line-number"},[n._v("76")]),s("br"),s("span",{staticClass:"line-number"},[n._v("77")]),s("br"),s("span",{staticClass:"line-number"},[n._v("78")]),s("br"),s("span",{staticClass:"line-number"},[n._v("79")]),s("br"),s("span",{staticClass:"line-number"},[n._v("80")]),s("br"),s("span",{staticClass:"line-number"},[n._v("81")]),s("br"),s("span",{staticClass:"line-number"},[n._v("82")]),s("br"),s("span",{staticClass:"line-number"},[n._v("83")]),s("br"),s("span",{staticClass:"line-number"},[n._v("84")]),s("br"),s("span",{staticClass:"line-number"},[n._v("85")]),s("br"),s("span",{staticClass:"line-number"},[n._v("86")]),s("br"),s("span",{staticClass:"line-number"},[n._v("87")]),s("br"),s("span",{staticClass:"line-number"},[n._v("88")]),s("br"),s("span",{staticClass:"line-number"},[n._v("89")]),s("br"),s("span",{staticClass:"line-number"},[n._v("90")]),s("br"),s("span",{staticClass:"line-number"},[n._v("91")]),s("br"),s("span",{staticClass:"line-number"},[n._v("92")]),s("br"),s("span",{staticClass:"line-number"},[n._v("93")]),s("br"),s("span",{staticClass:"line-number"},[n._v("94")]),s("br"),s("span",{staticClass:"line-number"},[n._v("95")]),s("br"),s("span",{staticClass:"line-number"},[n._v("96")]),s("br")])]),s("p",[s("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/4685968-3edeccbe9811a4c3.jpg",alt:"图片发自简书App"}})]),n._v(" "),s("h2",{attrs:{id:"_4-7-remove方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-remove方法"}},[n._v("#")]),n._v(" 4.7 remove方法")]),n._v(" "),s("p",[n._v("remove(key) 方法 和 remove(key, value) 方法都是通过调用removeNode的方法来实现删除元素的")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v(" final Node<K,V> removeNode(int hash, Object key, Object value,\n                               boolean matchValue, boolean movable) {\n        Node<K,V>[] tab; Node<K,V> p; int n, index;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (p = tab[index = (n - 1) & hash]) != null) {\n            Node<K,V> node = null, e; K k; V v;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                // index 元素只有一个元素\n                node = p;\n            else if ((e = p.next) != null) {\n                if (p instanceof TreeNode)\n                    // index处是一个红黑树\n                    node = ((TreeNode<K,V>)p).getTreeNode(hash, key);\n                else {\n                    // index处是一个链表，遍历链表返回node\n                    do {\n                        if (e.hash == hash &&\n                            ((k = e.key) == key ||\n                             (key != null && key.equals(k)))) {\n                            node = e;\n                            break;\n                        }\n                        p = e;\n                    } while ((e = e.next) != null);\n                }\n            }\n            // 分不同情形删除节点\n            if (node != null && (!matchValue || (v = node.value) == value ||\n                                 (value != null && value.equals(v)))) {\n                if (node instanceof TreeNode)\n                    ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);\n                else if (node == p)\n                    tab[index] = node.next;\n                else\n                    p.next = node.next;\n                ++modCount;\n                --size;\n                afterNodeRemoval(node);\n                return node;\n            }\n        }\n        return null;\n    }\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br"),s("span",{staticClass:"line-number"},[n._v("39")]),s("br"),s("span",{staticClass:"line-number"},[n._v("40")]),s("br"),s("span",{staticClass:"line-number"},[n._v("41")]),s("br"),s("span",{staticClass:"line-number"},[n._v("42")]),s("br"),s("span",{staticClass:"line-number"},[n._v("43")]),s("br"),s("span",{staticClass:"line-number"},[n._v("44")]),s("br")])]),s("h2",{attrs:{id:"_4-8-get"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-8-get"}},[n._v("#")]),n._v(" 4.8 get")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("/**\n   * 函数原型\n   * 作用：根据键key，向HashMap获取对应的值\n   */ \n   map.get(key)；\n\n\n /**\n   * 源码分析\n   */ \n   public V get(Object key) {\n    Node<K,V> e;\n    // 1. 计算需获取数据的hash值\n    // 2. 通过getNode（）获取所查询的数据 ->>分析1\n    // 3. 获取后，判断数据是否为空\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\n/**\n   * 分析1：getNode(hash(key), key))\n   */ \nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n\n    // 1. 计算存放在数组table中的位置\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n\n        // 4. 通过该函数，依次在数组、红黑树、链表中查找（通过equals（）判断）\n        // a. 先在数组中找，若存在，则直接返回\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n\n        // b. 若数组中没有，则到红黑树中寻找\n        if ((e = first.next) != null) {\n            // 在树中get\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n\n            // c. 若红黑树中也没有，则通过遍历，到链表中寻找\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br"),s("span",{staticClass:"line-number"},[n._v("39")]),s("br"),s("span",{staticClass:"line-number"},[n._v("40")]),s("br"),s("span",{staticClass:"line-number"},[n._v("41")]),s("br"),s("span",{staticClass:"line-number"},[n._v("42")]),s("br"),s("span",{staticClass:"line-number"},[n._v("43")]),s("br"),s("span",{staticClass:"line-number"},[n._v("44")]),s("br"),s("span",{staticClass:"line-number"},[n._v("45")]),s("br"),s("span",{staticClass:"line-number"},[n._v("46")]),s("br"),s("span",{staticClass:"line-number"},[n._v("47")]),s("br"),s("span",{staticClass:"line-number"},[n._v("48")]),s("br"),s("span",{staticClass:"line-number"},[n._v("49")]),s("br"),s("span",{staticClass:"line-number"},[n._v("50")]),s("br")])]),s("blockquote",[s("p",[n._v("在JDK1.7及以前的版本中，HashMap里是没有红黑树的实现的，在JDK1.8中加入了红黑树是为了防止哈希表碰撞攻击，当链表链长度为8时，及时转成红黑树，提高map的效率")])]),n._v(" "),s("p",[n._v("如果某个桶中的记录过大的话（当前是TREEIFY_THRESHOLD = 8），HashMap会动态的使用一个专门的treemap实现来替换掉它。这样做的结果会更好，是O(logn)，而不是糟糕的O(n)。它是如何工作的？\n前面产生冲突的那些KEY对应的记录只是简单的追加到一个链表后面，这些记录只能通过遍历来进行查找。但是超过这个阈值后HashMap开始将列表升级成一个二叉树，使用哈希值作为树的分支变量，如果两个哈希值不等，但指向同一个桶的话，较大的那个会插入到右子树里。如果哈希值相等，HashMap希望key值最好是实现了Comparable接口的，这样它可以按照顺序来进行插入。这对HashMap的key来说并不是必须的，不过如果实现了当然最好。如果没有实现这个接口，在出现严重的哈希碰撞的时候，你就并别指望能获得性能提升了。")]),n._v(" "),s("p",[n._v("这个性能提升有什么用处？比方说恶意的程序，如果它知道我们用的是哈希算法，它可能会发送大量的请求，导致产生严重的哈希碰撞。然后不停的访问这些key就能显著的影响服务器的性能，这样就形成了一次拒绝服务攻击（DoS）。JDK 8中从O(n)到O(logn)的飞跃，可以有效地防止类似的攻击，同时也让HashMap性能的可预测性稍微增强了一些")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("/**\n   * 源码分析：resize(2 * table.length)\n   * 作用：当容量不足时（容量 > 阈值），则扩容（扩到2倍）\n   */ \n   void resize(int newCapacity) {  \n\n    // 1. 保存旧数组（old table） \n    Entry[] oldTable = table;  \n\n    // 2. 保存旧容量（old capacity ），即数组长度\n    int oldCapacity = oldTable.length; \n\n    // 3. 若旧容量已经是系统默认最大容量了，那么将阈值设置成整型的最大值，退出    \n    if (oldCapacity == MAXIMUM_CAPACITY) {  \n        threshold = Integer.MAX_VALUE;  \n        return;  \n    }  \n\n    // 4. 根据新容量（2倍容量）新建1个数组，即新table  \n    Entry[] newTable = new Entry[newCapacity];  \n\n    // 5. （重点分析）将旧数组上的数据（键值对）转移到新table中，从而完成扩容 ->>分析1.1 \n    transfer(newTable); \n\n    // 6. 新数组table引用到HashMap的table属性上\n    table = newTable;  \n\n    // 7. 重新设置阈值  \n    threshold = (int)(newCapacity * loadFactor); \n} \n\n /**\n   * 分析1.1：transfer(newTable); \n   * 作用：将旧数组上的数据（键值对）转移到新table中，从而完成扩容\n   * 过程：按旧链表的正序遍历链表、在新链表的头部依次插入\n   */ \nvoid transfer(Entry[] newTable) {\n      // 1. src引用了旧数组\n      Entry[] src = table; \n\n      // 2. 获取新数组的大小 = 获取新容量大小                 \n      int newCapacity = newTable.length;\n\n      // 3. 通过遍历 旧数组，将旧数组上的数据（键值对）转移到新数组中\n      for (int j = 0; j < src.length; j++) { \n          // 3.1 取得旧数组的每个元素  \n          Entry<K,V> e = src[j];           \n          if (e != null) {\n              // 3.2 释放旧数组的对象引用（for循环后，旧数组不再引用任何对象）\n              src[j] = null; \n\n              do { \n                  // 3.3 遍历 以该数组元素为首 的链表\n                  // 注：转移链表时，因是单链表，故要保存下1个结点，否则转移后链表会断开\n                  Entry<K,V> next = e.next; \n                 // 3.3 重新计算每个元素的存储位置\n                 int i = indexFor(e.hash, newCapacity); \n                 // 3.4 将元素放在数组上：采用单链表的头插入方式 = 在链表头上存放数据 = 将数组位置的原有数据放在后1个指针、将需放入的数据放到数组位置中\n                 // 即 扩容后，可能出现逆序：按旧链表的正序遍历链表、在新链表的头部依次插入\n                 e.next = newTable[i]; \n                 newTable[i] = e;  \n                 // 访问下1个Entry链上的元素，如此不断循环，直到遍历完该链表上的所有节点\n                 e = next;             \n             } while (e != null);\n             // 如此不断循环，直到遍历完数组上的所有数据元素\n         }\n     }\n }\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br"),s("span",{staticClass:"line-number"},[n._v("39")]),s("br"),s("span",{staticClass:"line-number"},[n._v("40")]),s("br"),s("span",{staticClass:"line-number"},[n._v("41")]),s("br"),s("span",{staticClass:"line-number"},[n._v("42")]),s("br"),s("span",{staticClass:"line-number"},[n._v("43")]),s("br"),s("span",{staticClass:"line-number"},[n._v("44")]),s("br"),s("span",{staticClass:"line-number"},[n._v("45")]),s("br"),s("span",{staticClass:"line-number"},[n._v("46")]),s("br"),s("span",{staticClass:"line-number"},[n._v("47")]),s("br"),s("span",{staticClass:"line-number"},[n._v("48")]),s("br"),s("span",{staticClass:"line-number"},[n._v("49")]),s("br"),s("span",{staticClass:"line-number"},[n._v("50")]),s("br"),s("span",{staticClass:"line-number"},[n._v("51")]),s("br"),s("span",{staticClass:"line-number"},[n._v("52")]),s("br"),s("span",{staticClass:"line-number"},[n._v("53")]),s("br"),s("span",{staticClass:"line-number"},[n._v("54")]),s("br"),s("span",{staticClass:"line-number"},[n._v("55")]),s("br"),s("span",{staticClass:"line-number"},[n._v("56")]),s("br"),s("span",{staticClass:"line-number"},[n._v("57")]),s("br"),s("span",{staticClass:"line-number"},[n._v("58")]),s("br"),s("span",{staticClass:"line-number"},[n._v("59")]),s("br"),s("span",{staticClass:"line-number"},[n._v("60")]),s("br"),s("span",{staticClass:"line-number"},[n._v("61")]),s("br"),s("span",{staticClass:"line-number"},[n._v("62")]),s("br"),s("span",{staticClass:"line-number"},[n._v("63")]),s("br"),s("span",{staticClass:"line-number"},[n._v("64")]),s("br"),s("span",{staticClass:"line-number"},[n._v("65")]),s("br"),s("span",{staticClass:"line-number"},[n._v("66")]),s("br"),s("span",{staticClass:"line-number"},[n._v("67")]),s("br"),s("span",{staticClass:"line-number"},[n._v("68")]),s("br")])]),s("p",[n._v("从上面可看出：在扩容resize（）过程中，在将旧数组上的数据 转移到 新数组上时，转移数据操作 = 按旧链表的正序遍历链表、在新链表的头部依次插入，即在转移数据、扩容后，容易出现链表逆序的情况")]),n._v(" "),s("blockquote",[s("p",[s("code",[n._v("设重新计算存储位置后不变，即扩容前 = 1->2->3，扩容后 = 3->2->1")])])]),n._v(" "),s("p",[n._v("此时若并发执行 put 操作，一旦出现扩容情况，则 容易出现 环形链表，从而在获取数据、遍历链表时 形成死循环（Infinite Loop），即死锁\n"),s("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-f0fc8abf5588bda4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}}),n._v(" "),s("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-33e1eb8ca4751050.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"image.png"}}),n._v(" "),s("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-52f69ae7fb5284dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}}),n._v(" "),s("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-7ab28eced8714fe6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"为什么 HashMap 中 String、Integer 这样的包装类适合作为 key 键"}})]),n._v(" "),s("h1",{attrs:{id:"单线程rehash"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单线程rehash"}},[n._v("#")]),n._v(" 单线程rehash")]),n._v(" "),s("p",[n._v("单线程情况下，rehash无问题\n"),s("a",{attrs:{href:"http://www.jasongj.com/img/java/concurrenthashmap/single_thread_rehash.png",target:"_blank",rel:"noopener noreferrer"}},[s("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/4685968-a36b5a282b6ffefa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"HashMap rehash single thread"}}),s("OutboundLink")],1)]),n._v(" "),s("h1",{attrs:{id:"多线程并发下的rehash"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多线程并发下的rehash"}},[n._v("#")]),n._v(" 多线程并发下的rehash")]),n._v(" "),s("p",[n._v("这里假设有两个线程同时执行了put操作并引发了rehash，执行了transfer方法，并假设线程一进入transfer方法并执行完next = e.next后，因为线程调度所分配时间片用完而“暂停”，此时线程二完成了transfer方法的执行。此时状态如下。")]),n._v(" "),s("p",[s("a",{attrs:{href:"http://www.jasongj.com/img/java/concurrenthashmap/multi_thread_rehash_1.png",target:"_blank",rel:"noopener noreferrer"}},[s("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/4685968-c68bf4c25dfd8f2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"HashMap rehash multi thread step 1"}}),s("OutboundLink")],1),n._v("\n接着线程1被唤醒，继续执行第一轮循环的剩余部分")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("e.next = newTable[1] = null\nnewTable[1] = e = key(5)\ne = next = key(9)\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br")])]),s("p",[n._v("结果如下图所示\n"),s("a",{attrs:{href:"http://www.jasongj.com/img/java/concurrenthashmap/multi_thread_rehash_2.png",target:"_blank",rel:"noopener noreferrer"}},[s("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/4685968-39e50bf8b6272f1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"HashMap rehash multi thread step 2"}}),s("OutboundLink")],1)]),n._v(" "),s("p",[n._v("接着执行下一轮循环，结果状态图如下所示\n"),s("a",{attrs:{href:"http://www.jasongj.com/img/java/concurrenthashmap/multi_thread_rehash_3.png",target:"_blank",rel:"noopener noreferrer"}},[s("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/4685968-4d3ecfe9177c8ec5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"HashMap rehash multi thread step 3"}}),s("OutboundLink")],1)]),n._v(" "),s("p",[n._v("继续下一轮循环，结果状态图如下所示\n"),s("a",{attrs:{href:"http://www.jasongj.com/img/java/concurrenthashmap/multi_thread_rehash_4.png",target:"_blank",rel:"noopener noreferrer"}},[s("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/4685968-14ed3884c7e20cd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"HashMap rehash multi thread step 4"}}),s("OutboundLink")],1)]),n._v(" "),s("p",[n._v("此时循环链表形成，并且key(11)无法加入到线程1的新数组。在下一次访问该链表时会出现死循环。")]),n._v(" "),s("h1",{attrs:{id:"fast-fail"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fast-fail"}},[n._v("#")]),n._v(" Fast-fail")]),n._v(" "),s("h3",{attrs:{id:"产生原因"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#产生原因"}},[n._v("#")]),n._v(" "),s("a",{attrs:{href:"http://www.jasongj.com/java/concurrenthashmap/#%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0",title:"产生原因",target:"_blank",rel:"noopener noreferrer"}},[s("OutboundLink")],1),n._v("产生原因")]),n._v(" "),s("p",[n._v("在使用迭代器的过程中如果HashMap被修改，那么"),s("code",[n._v("ConcurrentModificationException")]),n._v("将被抛出，也即Fast-fail策略。")]),n._v(" "),s("p",[n._v("当HashMap的iterator()方法被调用时，会构造并返回一个新的EntryIterator对象，并将EntryIterator的expectedModCount设置为HashMap的modCount（该变量记录了HashMap被修改的次数）。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("HashIterator() {\n  expectedModCount = modCount;\n  if (size > 0) { // advance to first entry\n  Entry[] t = table;\n  while (index < t.length && (next = t[index++]) == null)\n    ;\n  }\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br")])]),s("p",[n._v("在通过该Iterator的next方法访问下一个Entry时，它会先检查自己的expectedModCount与HashMap的modCount是否相等，如果不相等，说明HashMap被修改，直接抛出"),s("code",[n._v("ConcurrentModificationException")]),n._v("。该Iterator的remove方法也会做类似的检查。该异常的抛出意在提醒用户及早意识到线程安全问题。")]),n._v(" "),s("h3",{attrs:{id:"线程安全解决方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程安全解决方案"}},[n._v("#")]),n._v(" "),s("a",{attrs:{href:"http://www.jasongj.com/java/concurrenthashmap/#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88",title:"线程安全解决方案",target:"_blank",rel:"noopener noreferrer"}},[s("OutboundLink")],1),n._v("线程安全解决方案")]),n._v(" "),s("p",[n._v("单线程条件下，为避免出现"),s("code",[n._v("ConcurrentModificationException")]),n._v("，需要保证只通过HashMap本身或者只通过Iterator去修改数据，不能在Iterator使用结束之前使用HashMap本身的方法修改数据。因为通过Iterator删除数据时，HashMap的modCount和Iterator的expectedModCount都会自增，不影响二者的相等性。如果是增加数据，只能通过HashMap本身的方法完成，此时如果要继续遍历数据，需要重新调用iterator()方法从而重新构造出一个新的Iterator，使得新Iterator的expectedModCount与更新后的HashMap的modCount相等。")]),n._v(" "),s("p",[n._v("多线程条件下，可使用"),s("code",[n._v("Collections.synchronizedMap")]),n._v("方法构造出一个同步Map，或者直接使用线程安全的ConcurrentHashMap。")])])}),[],!1,null,null,null);a.default=t.exports}}]);