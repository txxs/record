(window.webpackJsonp=window.webpackJsonp||[]).push([[1174],{1567:function(v,_,t){"use strict";t.r(_);var e=t(13),s=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("消费消息需要考虑：")]),v._v(" "),t("ul",[t("li",[v._v("会不会重复消费")]),v._v(" "),t("li",[v._v("能不能避免重复消费")]),v._v(" "),t("li",[v._v("重复消费了也别造成系统异常可以吗")])]),v._v(" "),t("p",[v._v("使用MQ如何保证幂等性也是架构设计考虑的问题。")]),v._v(" "),t("p",[v._v("rabbitmq、rocketmq、kafka，都可能会出现消费重复消费，因为这个问题不是MQ自身保证的，是我们开发自己需要保证的。")]),v._v(" "),t("h1",{attrs:{id:"何时重复消费"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#何时重复消费"}},[v._v("#")]),v._v(" 何时重复消费？")]),v._v(" "),t("p",[v._v("kafka有个offset概念，每个消息写进去，都有一个offset，代表他的序号，然后consumer消费了消息后，每隔一段时间，会把自己消费过的消息的offset提交一下，代表我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的offset来继续消费。")]),v._v(" "),t("p",[v._v("但凡事有意外，比如重启系统，碰到急的，直接kill进程再重启。这会导致consumer有些消息处理了，但是没来得及提交offset。重启之后，少数消息会再次消费。")]),v._v(" "),t("p",[v._v("其实重复消费不可怕，可怕的是你没考虑到重复消费之后，如何"),t("strong",[v._v("保证幂等性")]),v._v("。")]),v._v(" "),t("p",[v._v("比如你有个系统，消费一条往DB插一条，要是你一个消息重复两次，你不就插入两条，这数据不就错了？\n但你要是消费到第二次时，自己判断一下已消费了，直接扔了，不就只保留了一条数据！")]),v._v(" "),t("p",[v._v("一条数据重复出现两次，DB里就只有一条数据，这就保证了系统的幂等性。")]),v._v(" "),t("p",[v._v("幂等性，就一个数据或一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。")]),v._v(" "),t("p",[v._v("所以")]),v._v(" "),t("h1",{attrs:{id:"怎么保证消息队列消费的幂等性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#怎么保证消息队列消费的幂等性"}},[v._v("#")]),v._v(" 怎么保证消息队列消费的幂等性？")]),v._v(" "),t("p",[v._v("还是得结合业务来思考，大体思路如下：")]),v._v(" "),t("ul",[t("li",[v._v("写DB，你先根据主键查一下，如果这数据都有了，你就别插入了，update之")]),v._v(" "),t("li",[v._v("写redis，那没问题了，反正每次都是set，天然幂等")]),v._v(" "),t("li",[v._v("其它场景，你需要让生产者发送每条消息时，里面加一个全局唯一id，然后你这里消费到了之后，先根据这个id去redis查一下，之前消费过吗？\n"),t("ul",[t("li",[v._v("如果没有消费过\n你就处理，然后这个id写redis")]),v._v(" "),t("li",[v._v("如果消费过了\n那你就别处理了，保证别重复处理相同的消息")])])])]),v._v(" "),t("p",[v._v("还有比如基于DB的唯一键保证重复数据不会重复插入多条。")])])}),[],!1,null,null,null);_.default=s.exports}}]);