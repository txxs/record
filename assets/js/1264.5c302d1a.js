(window.webpackJsonp=window.webpackJsonp||[]).push([[1264],{1660:function(e,t,r){"use strict";r.r(t);var s=r(13),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"_1-server"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-server"}},[e._v("#")]),e._v(" 1 Server")]),e._v(" "),r("h2",{attrs:{id:"info"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#info"}},[e._v("#")]),e._v(" info")]),e._v(" "),r("p",[e._v("以一种易于理解和阅读的格式，返回关于Redis服务器的各种信息和统计数值\n"),r("img",{attrs:{src:"https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzQ2ODU5NjgtNzM4MTAxNTc5OGVjZDZiMC5wbmc?x-oss-process=image/format,png",alt:""}})]),e._v(" "),r("h2",{attrs:{id:"select"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#select"}},[e._v("#")]),e._v(" select")]),e._v(" "),r("p",[e._v("选择一个数据库，下标值从0开始，一个新连接默认连接的数据库是DB0\n"),r("img",{attrs:{src:"https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzQ2ODU5NjgtNmU1MDM5MTM3OGI3MzE2ZS5wbmc?x-oss-process=image/format,png",alt:""}})]),e._v(" "),r("h2",{attrs:{id:"flushdb"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#flushdb"}},[e._v("#")]),e._v(" flushdb")]),e._v(" "),r("p",[e._v("删除当前数据库里面的所有数据\n这个命令永远不会出现失败\n这个操作的时间复杂度是O(N),N是当前数据库的keys数量")]),e._v(" "),r("h2",{attrs:{id:"flushall"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#flushall"}},[e._v("#")]),e._v(" flushall")]),e._v(" "),r("p",[e._v("删除所有数据库里面的所有数据，注意不是当前数据库，而是所有数据库\n这个命令永远不会出现失败\n这个操作的时间复杂度是O(N),N是数据库的数量")]),e._v(" "),r("h2",{attrs:{id:"ping"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ping"}},[e._v("#")]),e._v(" ping")]),e._v(" "),r("p",[e._v("如果后面没有参数时返回PONG，否则会返回后面带的参数\n这个命令经常用来测试一个连接是否还是可用的，或者用来测试一个连接的延时\n如果客户端处于频道订阅模式下，它将是一个multi-bulk返回，第一次时返回”pong”，之后返回空（empty bulk），除非命令后面更随了参数\n##quit\n请求服务器关闭连接。连接将会尽可能快的将未完成的客户端请求完成处理")]),e._v(" "),r("h2",{attrs:{id:"save"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#save"}},[e._v("#")]),e._v(" save")]),e._v(" "),r("p",[e._v("执行一个同步操作，以RDB文件的方式保存所有数据的快照 很少在生产环境直接使用SAVE 命令，因为它会阻塞所有的客户端的请求，可以使用"),r("a",{attrs:{href:"http://www.redis.cn/commands/bgsave.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("BGSAVE"),r("OutboundLink")],1),e._v(" 命令代替. 如果在"),r("a",{attrs:{href:"http://www.redis.cn/commands/bgsave.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("BGSAVE"),r("OutboundLink")],1),e._v("命令的保存数据的子进程发生错误的时,用 SAVE命令保存最新的数据是最后的手段,详细的说明请参考持久化文档")]),e._v(" "),r("h2",{attrs:{id:"dbsize"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dbsize"}},[e._v("#")]),e._v(" dbsize")]),e._v(" "),r("blockquote",[r("p",[e._v("自 1.0.0 起可用。")])]),e._v(" "),r("p",[e._v("返回当前数据里面keys的数量\n"),r("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200906175405753.png#pic_center",alt:""}})]),e._v(" "),r("h1",{attrs:{id:"_2-keys-命令集"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-keys-命令集"}},[e._v("#")]),e._v(" 2 keys 命令集")]),e._v(" "),r("h2",{attrs:{id:"_2-1-keys"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-keys"}},[e._v("#")]),e._v(" 2.1 keys")]),e._v(" "),r("blockquote",[r("p",[e._v("1.0.0 起可用。\n时间复杂度：O（N）与N是数据库中的键数，假设数据库中的键名称和给定的模式的长度有限。")])]),e._v(" "),r("p",[e._v("返回所有键匹配模式。\n虽然此操作的时间复杂性为 O（N），但常量时间相当低。例如，在入门级笔记本电脑上运行的 Redis 可以在 40 毫秒内扫描 100 万个key数据库。")]),e._v(" "),r("p",[e._v("注意，将 KEYS 视为一个命令，该命令应仅在生产环境中使用。当对大型数据库执行时，可能会破坏性能。此命令用于调试和特殊操作，例如更改key空间布局。不要在常规应用程序代码中使用 KEYS。如果你想在key空间子集中查找key，请考虑使用 SCAN 命令或sets结构。")]),e._v(" "),r("ul",[r("li",[e._v("keys * 遍历所有 key。一般不在生产环境使用\n"),r("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200906173839841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70#pic_center",alt:""}})])]),e._v(" "),r("p",[e._v("那何时使用该命令呢？")]),e._v(" "),r("ul",[r("li",[e._v("热备从节点")]),e._v(" "),r("li",[e._v("使用scan替代吧")])]),e._v(" "),r("h2",{attrs:{id:"_2-2-set"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-set"}},[e._v("#")]),e._v(" 2.2 set")]),e._v(" "),r("p",[e._v("将键key设定为指定的“字符串”值\n如果key\t已经保存了一个值，那么这个操作会直接覆盖原来的值，并且忽略原始类型\n当set命令执行成功之后，之前设置的过期时间都将失效\n如果SET命令正常执行那么回返回OK，否则如果加了NX 或者 XX选项，但是没有设置条件。那么会返回nil")]),e._v(" "),r("h2",{attrs:{id:"_2-3-del"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-del"}},[e._v("#")]),e._v(" 2.3 del")]),e._v(" "),r("p",[e._v("删除指定的一批keys，如果删除中的某些key不存在，则直接忽略。\n返回值:被删除的keys的数量")]),e._v(" "),r("h2",{attrs:{id:"_2-4-exists"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-exists"}},[e._v("#")]),e._v(" 2.4 exists")]),e._v(" "),r("blockquote",[r("p",[e._v("自 1.0.0 起可用。\n时间复杂度：O（1）")])]),e._v(" "),r("p",[e._v("如果key存在，则返回。")]),e._v(" "),r("p",[e._v("由于 Redis 3.0.3 可以指定多个键而不是单个键。在这种情况下，它将返回现有key的总数。请注意，为单个键返回 1 或 0 只是 variadic 使用的特殊情况，因此该命令完全向后兼容。")]),e._v(" "),r("p",[e._v("用户应该知道，如果在参数中多次提到相同的现有key，则将多次计数该key。因此，如果存在某些key，则存在某些key，则返回 2。")]),e._v(" "),r("h3",{attrs:{id:"返回值"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("ul",[r("li",[e._v("1 key存在")]),e._v(" "),r("li",[e._v("0 key不存在")])]),e._v(" "),r("h2",{attrs:{id:"_2-5-ttl-pttl"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-ttl-pttl"}},[e._v("#")]),e._v(" 2.5 ttl（pttl）")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200906202145593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70#pic_center",alt:""}})]),e._v(" "),r("p",[e._v("返回key剩余的过期时间。 这种反射能力允许Redis客户端检查指定key在数据集里面剩余的有效期。\n从Redis2.8开始，错误返回值的结果:")]),e._v(" "),r("ul",[r("li",[e._v("若key不存在或已过期，返回 "),r("code",[e._v("-2")])]),e._v(" "),r("li",[e._v("若key存在且没有设置过期时间，返回 "),r("code",[e._v("-1")])])]),e._v(" "),r("p",[e._v("与之相关的 PTTL 命令实现完全相同，返回相同的信息，只不过其时间单位是毫秒（仅适用于Redis 2.6及更高版本）。")]),e._v(" "),r("h2",{attrs:{id:"返回值-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-2"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[e._v("key有效的秒数（TTL in seconds），或者一个负值的错误 (参考上文)")]),e._v(" "),r("h2",{attrs:{id:"_2-6-expire-key-seconds"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-expire-key-seconds"}},[e._v("#")]),e._v(" 2.6 expire key seconds")]),e._v(" "),r("blockquote",[r("p",[e._v("自 1.0.0 起可用。\n时间复杂度：O（1）")])]),e._v(" "),r("p",[e._v("设置"),r("code",[e._v("key")]),e._v("的过期时间。超时后，将会自动删除该"),r("code",[e._v("key")]),e._v("。在Redis的术语中一个"),r("code",[e._v("key")]),e._v("的相关超时是volatile的。")]),e._v(" "),r("p",[e._v("超时后只有对"),r("code",[e._v("key")]),e._v("执行DEL、SET、GETSET时才会清除。 这意味着，从概念上讲所有改变"),r("code",[e._v("key")]),e._v("而不用新值替换的所有操作都将保持超时不变。 例如，使用 "),r("code",[e._v("INCR")]),e._v(" 递增key的值，执行 "),r("code",[e._v("LPUSH")]),e._v(" 将新值推到 list 中或用 "),r("code",[e._v("HSET")]),e._v(" 改变hash的"),r("code",[e._v("field")]),e._v("，这些操作都使超时保持不变。")]),e._v(" "),r("ul",[r("li",[e._v("使用 "),r("code",[e._v("PERSIST")]),e._v(" 命令可以清除超时，使其变成一个永久"),r("code",[e._v("key")])]),e._v(" "),r("li",[e._v("若 "),r("code",[e._v("key")]),e._v(" 被 "),r("code",[e._v("RENAME")]),e._v(" 命令修改，相关的超时时间会转移到新"),r("code",[e._v("key")])]),e._v(" "),r("li",[e._v("若 "),r("code",[e._v("key")]),e._v(" 被 "),r("code",[e._v("RENAME")]),e._v(" 命令修改，比如原来就存在 "),r("code",[e._v("Key_A")]),e._v("，然后调用 "),r("code",[e._v("RENAME Key_B Key_A")]),e._v(" 命令，这时不管原来 "),r("code",[e._v("Key_A")]),e._v(" 是永久的还是设为超时的，都会由"),r("code",[e._v("Key_B")]),e._v("的有效期状态覆盖")])]),e._v(" "),r("p",[e._v("注意，使用非正超时调用 EXPIRE/PEXPIRE 或具有过去时间的 EXPIREAT/PEXPIREAT 将导致key被删除而不是过期（因此，发出的key事件将是 del，而不是过期）。")]),e._v(" "),r("h3",{attrs:{id:"刷新过期时间"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#刷新过期时间"}},[e._v("#")]),e._v(" 刷新过期时间")]),e._v(" "),r("p",[e._v("对已经有过期时间的"),r("code",[e._v("key")]),e._v("执行"),r("code",[e._v("EXPIRE")]),e._v("操作，将会更新它的过期时间。有很多应用有这种业务场景，例如记录会话的session。")]),e._v(" "),r("h3",{attrs:{id:"redis-之前的-2-1-3-的差异"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis-之前的-2-1-3-的差异"}},[e._v("#")]),e._v(" Redis 之前的 2.1.3 的差异")]),e._v(" "),r("p",[e._v("在 Redis 版本之前 2.1.3 中，使用更改其值的命令更改具有过期集的密钥具有完全删除key的效果。由于现在修复的复制层中存在限制，因此需要此语义。")]),e._v(" "),r("p",[e._v("EXPIRE 将返回 0，并且不会更改具有超时集的键的超时。")]),e._v(" "),r("h3",{attrs:{id:"返回值-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-3"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("1")]),e._v(" 如果成功设置过期时间。")]),e._v(" "),r("li",[r("code",[e._v("0")]),e._v(" 如果"),r("code",[e._v("key")]),e._v("不存在或者不能设置过期时间。")])]),e._v(" "),r("h3",{attrs:{id:"示例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[e._v("#")]),e._v(" 示例")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200906190447334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70#pic_center",alt:""}})]),e._v(" "),r("p",[e._v("假设有一 Web 服务，对用户最近访问的最新 N 页感兴趣，这样每个相邻页面视图在上一个页面之后不超过 60 秒。从概念上讲，可以将这组页面视图视为用户的导航会话，该会话可能包含有关ta当前正在寻找的产品的有趣信息，以便你可以推荐相关产品。")]),e._v(" "),r("p",[e._v("可使用以下策略轻松在 Redis 中对此模式建模：每次用户执行页面视图时，您都会调用以下命令：")]),e._v(" "),r("div",{staticClass:"language-shell line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-shell"}},[r("code",[e._v("MULTI\nRPUSH pagewviews.user:"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("userid"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" http://"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),e._v(".\nEXPIRE pagewviews.user:"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("userid"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("60")]),e._v("\nEXEC\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br")])]),r("p",[e._v("如果用户空闲超过 60 秒，则将删除该key，并且仅记录差异小于 60 秒的后续页面视图。\n此模式很容易修改，使用 INCR 而不是使用 RPUSH 的列表。")]),e._v(" "),r("h3",{attrs:{id:"带过期时间的-key"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#带过期时间的-key"}},[e._v("#")]),e._v(" 带过期时间的 key")]),e._v(" "),r("p",[e._v("通常，创建 Redis 键时没有关联的存活时间。key将永存，除非用户以显式方式（例如 DEL 命令）将其删除。\nEXPIRE 族的命令能够将过期项与给定key关联，但代价是该key使用的额外内存。当key具有过期集时，Redis 将确保在经过指定时间时删除该key。\n可使用 EXPIRE 和 PERSIST 命令（或其他严格命令）更新或完全删除生存的关键时间。")]),e._v(" "),r("h3",{attrs:{id:"过期精度"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#过期精度"}},[e._v("#")]),e._v(" 过期精度")]),e._v(" "),r("p",[e._v("在 Redis 2.4 中，过期可能不准确，并且可能介于 0 到 1 秒之间。\n由于 Redis 2.6，过期误差从 0 到 1 毫秒。")]),e._v(" "),r("h3",{attrs:{id:"过期和持久化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#过期和持久化"}},[e._v("#")]),e._v(" 过期和持久化")]),e._v(" "),r("p",[e._v("过期信息的键存储为绝对 Unix 时间戳（Redis 版本 2.6 或更高版本为毫秒）。这意味着即使 Redis 实例不处于活动状态，时间也在流动。\n要使过期工作良好，必须稳定计算机时间。若将 RDB 文件从两台计算机上移动，其时钟中具有大 desync，则可能会发生有趣的事情（如加载时加载到过期的所有key）。\n即使运行时的实例，也始终会检查计算机时钟，例如，如果将一个key设置为 1000 秒，然后在将来设置计算机时间 2000 秒，则该key将立即过期，而不是持续 1000 秒。")]),e._v(" "),r("h3",{attrs:{id:"redis-如何使key过期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis-如何使key过期"}},[e._v("#")]),e._v(" Redis 如何使key过期")]),e._v(" "),r("p",[e._v("键的过期方式有两种：被动方式和主动方式。")]),e._v(" "),r("p",[e._v("当某些客户端尝试访问key时，key会被动过期，并且该key已定时。\n当然，这是不够的，因为有过期的key，永远不会再访问。无论如何，这些key都应过期，因此请定期 Redis 在具有过期集的key之间随机测试几个key。已过期的所有key将从key空间中删除。")]),e._v(" "),r("p",[e._v("具体来说，如下 Redis 每秒 10 次：")]),e._v(" "),r("ol",[r("li",[e._v("测试 20 个带有过期的随机键")]),e._v(" "),r("li",[e._v("删除找到的所有已过期key")]),e._v(" "),r("li",[e._v("如果超过 25% 的key已过期，从步骤 1 重新开始")])]),e._v(" "),r("p",[e._v("这是一个微不足道的概率算法，基本上假设我们的样本代表整个key空间，继续过期，直到可能过期的key百分比低于 25%。\n这意味着在任何给定时刻，使用内存的已过期的最大键量等于最大写入操作量/秒除以 4。")]),e._v(" "),r("h3",{attrs:{id:"在复制链路和-aof-文件中处理过期的方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#在复制链路和-aof-文件中处理过期的方式"}},[e._v("#")]),e._v(" 在复制链路和 AOF 文件中处理过期的方式")]),e._v(" "),r("p",[e._v("为了在不牺牲一致性的情况下获得正确行为，当key过期时，DEL 操作将同时在 AOF 文件中合成并获取所有附加的从节点。这样，过期的这个处理过程集中到主节点中，还没有一致性错误的可能性。")]),e._v(" "),r("p",[e._v("但是，虽然连接到主节点的从节点不会独立过期key（但会等待来自master的 DEL），但它们仍将使用数据集中现有过期的完整状态，因此，当选择slave作为master时，它将能够独立过期key，完全充当master。")]),e._v(" "),r("h2",{attrs:{id:"_2-7-type"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-7-type"}},[e._v("#")]),e._v(" 2.7 type")]),e._v(" "),r("p",[e._v("返回"),r("code",[e._v("key")]),e._v("所存储的"),r("code",[e._v("value")]),e._v("的数据结构类型")]),e._v(" "),r("h3",{attrs:{id:"返回值-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-4"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[e._v("返回当前"),r("code",[e._v("key")]),e._v("的数据类型，如果"),r("code",[e._v("key")]),e._v("不存在时返回"),r("code",[e._v("none")])]),e._v(" "),r("h2",{attrs:{id:"rename"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rename"}},[e._v("#")]),e._v(" rename")]),e._v(" "),r("p",[e._v("将key重命名为newkey，如果key与newkey相同，将返回一个错误\n如果newkey已经存在，则值将被覆盖")]),e._v(" "),r("h3",{attrs:{id:"返回值-5"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-5"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.redis.cn/topics/protocol.html#simple-string-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("simple-string-reply"),r("OutboundLink")],1)]),e._v(" "),r("h2",{attrs:{id:"renamenx"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#renamenx"}},[e._v("#")]),e._v(" renamenx")]),e._v(" "),r("p",[e._v("当且仅当 newkey 不存在时，将 key 改名为 newkey\n当 key 不存在时，返回一个错误")]),e._v(" "),r("h3",{attrs:{id:"返回值-6"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-6"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.redis.cn/topics/protocol.html#integer-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("integer-reply"),r("OutboundLink")],1),e._v("：OK")]),e._v(" "),r("ul",[r("li",[e._v("修改成功时，返回 1 。")]),e._v(" "),r("li",[e._v("如果 newkey 已经存在，返回 0")])]),e._v(" "),r("h2",{attrs:{id:"randomkey"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#randomkey"}},[e._v("#")]),e._v(" randomkey")]),e._v(" "),r("p",[e._v("从当前数据库返回一个随机的key")]),e._v(" "),r("h1",{attrs:{id:"_3-string命令"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-string命令"}},[e._v("#")]),e._v(" 3 string命令")]),e._v(" "),r("h2",{attrs:{id:"setex"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#setex"}},[e._v("#")]),e._v(" setex")]),e._v(" "),r("p",[e._v("设置key对应字符串value，并且设置key在给定的seconds时间之后超时过期。这个命令等效于执行下面的命令")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("SET mykey value\nEXPIRE mykey seconds\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br")])]),r("p",[e._v("SETEX是原子的，也可以通过把上面两个命令放到"),r("a",{attrs:{href:"http://www.redis.cn/commands/multi.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("MULTI"),r("OutboundLink")],1),e._v("/"),r("a",{attrs:{href:"http://www.redis.cn/commands/exec.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("EXEC"),r("OutboundLink")],1),e._v("块中执行的方式重现。相比连续执行上面两个命令，它更快，因为当Redis当做缓存使用时，这个操作更加常用。")]),e._v(" "),r("h3",{attrs:{id:"返回值-7"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-7"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.redis.cn/topics/protocol.html#simple-string-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("simple-string-reply"),r("OutboundLink")],1),e._v("OK")]),e._v(" "),r("h2",{attrs:{id:"psetex"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#psetex"}},[e._v("#")]),e._v(" psetex")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.redis.cn/commands/psetex.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("PSETEX"),r("OutboundLink")],1),e._v("和"),r("a",{attrs:{href:"http://www.redis.cn/commands/setex.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("SETEX"),r("OutboundLink")],1),e._v("一样，唯一的区别是到期时间以毫秒为单位,而不是秒")]),e._v(" "),r("h2",{attrs:{id:"getset-具有原子性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#getset-具有原子性"}},[e._v("#")]),e._v(" getset(具有原子性)")]),e._v(" "),r("p",[e._v("自动将key对应到value并且返回原来key对应的value\n如果key存在但是对应的value不是字符串，就返回错误")]),e._v(" "),r("p",[e._v("GETSET可以和INCR一起使用实现支持重置的计数功能。\n举个例子：每当有事件发生的时候，一段程序都会调用INCR给key mycounter加1，但是有时我们需要获取计数器的值，并且自动将其重置为0。这可以通过GETSET mycounter “0”来实现：")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('INCR mycounter\nGETSET mycounter "0"\nGET mycounter\n')])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br")])]),r("h3",{attrs:{id:"返回值-8"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-8"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.redis.cn/topics/protocol.html#bulk-string-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("bulk-string-reply"),r("OutboundLink")],1),e._v(": 返回之前的旧值，如果之前"),r("code",[e._v("Key")]),e._v("不存在将返回"),r("code",[e._v("nil")])]),e._v(" "),r("h2",{attrs:{id:"mset"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mset"}},[e._v("#")]),e._v(" mset")]),e._v(" "),r("p",[e._v("对应给定的keys到他们相应的values上。\n"),r("code",[e._v("MSET")]),e._v("会用新的value替换已经存在的value，就像普通的"),r("a",{attrs:{href:"http://www.redis.cn/commands/set.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("SET"),r("OutboundLink")],1),e._v("命令一样\n"),r("code",[e._v("MSET")]),e._v("是原子的，所以所有给定的keys是一次性set的。客户端不可能看到这种一部分keys被更新而另外的没有改变的情况")]),e._v(" "),r("h3",{attrs:{id:"返回值-9"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-9"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.redis.cn/topics/protocol.html#simple-string-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("simple-string-reply"),r("OutboundLink")],1),e._v("：总是OK，因为MSET不会失败\n##mget\n返回所有指定的key的value。对于每个不对应string或者不存在的key，都返回特殊值"),r("code",[e._v("nil")]),e._v("。正因为此，这个操作从来不会失败。")]),e._v(" "),r("h3",{attrs:{id:"返回值-10"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-10"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.redis.cn/topics/protocol.html#array-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("array-reply"),r("OutboundLink")],1),e._v(": 指定的key对应的values的list")]),e._v(" "),r("h2",{attrs:{id:"setnx-防止set覆盖问题-具有原子性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#setnx-防止set覆盖问题-具有原子性"}},[e._v("#")]),e._v(" setnx(防止set覆盖问题,具有原子性)")]),e._v(" "),r("p",[e._v("将"),r("code",[e._v("key")]),e._v("设置值为"),r("code",[e._v("value")]),e._v("\n如果"),r("code",[e._v("key")]),e._v("不存在，这种情况下等同set\n当"),r("code",[e._v("key")]),e._v("存在时，什么也不做\n"),r("code",[e._v("SETNX")]),e._v("是”"),r("strong",[e._v("SET")]),e._v(" if "),r("strong",[e._v("N")]),e._v("ot e"),r("strong",[e._v("X")]),e._v("ists”的简写")]),e._v(" "),r("h3",{attrs:{id:"返回值-11"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-11"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.redis.cn/topics/protocol.html#integer-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("Integer reply"),r("OutboundLink")],1),e._v(", 特定值")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("1")]),e._v(" 如果key被设置了")]),e._v(" "),r("li",[r("code",[e._v("0")]),e._v(" 如果key没有被设置")])]),e._v(" "),r("h2",{attrs:{id:"msetnx"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#msetnx"}},[e._v("#")]),e._v(" msetnx")]),e._v(" "),r("p",[e._v("对应给定的keys到他们相应的values上\n只要有一个key已存在，"),r("code",[e._v("MSETNX")]),e._v("一个操作都不会执行\n由于这种特性，"),r("code",[e._v("MSETNX")]),e._v("可以实现要么所有的操作都成功，要么一个都不执行，这样可以用来设置不同的key，来表示一个唯一的对象的不同字段")]),e._v(" "),r("p",[r("code",[e._v("MSETNX")]),e._v("是原子的，所以所有给定的keys是一次性set的\n客户端不可能看到这种一部分keys被更新而另外的没有改变的情况")]),e._v(" "),r("h3",{attrs:{id:"返回值-12"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-12"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.redis.cn/topics/protocol.html#integer-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("integer-reply"),r("OutboundLink")],1),e._v("，只有以下两种值：")]),e._v(" "),r("ul",[r("li",[e._v("1 如果所有的key被set")]),e._v(" "),r("li",[e._v("0 如果没有key被set(至少其中有一个key是存在的)")])]),e._v(" "),r("h2",{attrs:{id:"incr"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#incr"}},[e._v("#")]),e._v(" incr")]),e._v(" "),r("p",[e._v("对存储在指定"),r("code",[e._v("key")]),e._v("的数值执行原子的加1操作\n如果指定的key不存在，那么在执行incr操作之前，会先将它的值设定为"),r("code",[e._v("0")])]),e._v(" "),r("h3",{attrs:{id:"返回值-13"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-13"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.redis.cn/topics/protocol.html#integer-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("integer-reply"),r("OutboundLink")],1),e._v(":执行递增操作后"),r("code",[e._v("key")]),e._v("对应的值\n##incrby\n将key对应的数字加decrement\n如果key不存在，操作之前，key就会被置为0。\n###返回值\n"),r("a",{attrs:{href:"http://www.redis.cn/topics/protocol.html#integer-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("integer-reply"),r("OutboundLink")],1),e._v("： 增加之后的value值")]),e._v(" "),r("h2",{attrs:{id:"decr"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#decr"}},[e._v("#")]),e._v(" decr")]),e._v(" "),r("p",[e._v("对key对应的数字做减1操作\n如果key不存在，那么在操作之前，这个key对应的值会被置为0")]),e._v(" "),r("h3",{attrs:{id:"返回值-14"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-14"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[e._v("数字：减小之后的value")]),e._v(" "),r("h2",{attrs:{id:"decrby"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#decrby"}},[e._v("#")]),e._v(" decrby")]),e._v(" "),r("p",[e._v("将key对应的数字减decrement\n如果key不存在，操作之前，key就会被置为0")]),e._v(" "),r("h3",{attrs:{id:"返回值-15"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-15"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[e._v("数字：减少之后的value值")]),e._v(" "),r("h2",{attrs:{id:"apend"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#apend"}},[e._v("#")]),e._v(" apend")]),e._v(" "),r("p",[e._v("如果 "),r("code",[e._v("key")]),e._v(" 已经存在，并且值为字符串，那么这个命令会把 "),r("code",[e._v("value")]),e._v(" 追加到原来值（value）的结尾\n如果 "),r("code",[e._v("key")]),e._v(" 不存在，那么它将首先创建一个空字符串的"),r("code",[e._v("key")]),e._v("，再执行追加操作，这种情况 "),r("a",{attrs:{href:"http://www.redis.cn/ommands/append.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("APPEND"),r("OutboundLink")],1),e._v(" 将类似于 "),r("a",{attrs:{href:"http://www.redis.cn/ommands/set.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("SET"),r("OutboundLink")],1),e._v(" 操作。")]),e._v(" "),r("h3",{attrs:{id:"返回值-16"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-16"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[r("RouterLink",{attrs:{to:"htp://www.redis.cn/topics/protocol.html#integer-reply"}},[e._v("Integer reply")]),e._v("：返回append后字符串值（value）的长度")],1),e._v(" "),r("h1",{attrs:{id:"_4-hashes"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-hashes"}},[e._v("#")]),e._v(" 4 hashes")]),e._v(" "),r("h2",{attrs:{id:"_3-1-hset-key-field-value-field-value"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-hset-key-field-value-field-value"}},[e._v("#")]),e._v(" 3.1 hset key field value [field value ...]")]),e._v(" "),r("blockquote",[r("p",[e._v("2.0.0提供。\n时间复杂度：O(1)对每个字段/值对添加，因此 O（N） 在调用具有多个字段/值对的命令时添加 N 个字段/值对。")])]),e._v(" "),r("p",[e._v("设置存储在键到值的哈希中的字段。如果key不存在，则创建一个持有哈希的新key。如果哈希中已存在字段，则覆盖该字段。")]),e._v(" "),r("p",[e._v("Redis 4.0.0 起，HSET 是万数值，允许多个字段/值对。")]),e._v(" "),r("p",[e._v("设置 key 指定的哈希集中指定字段的值\n如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联\n如果字段在哈希集中存在，它将被重写")]),e._v(" "),r("h3",{attrs:{id:"返回值-17"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-17"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[e._v("添加的字段数。")]),e._v(" "),r("ul",[r("li",[e._v("1：如果field是一个新的字段")]),e._v(" "),r("li",[e._v("0：如果filed原来在hash里已存在\n"),r("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200906173606528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70#pic_center",alt:""}})])]),e._v(" "),r("h2",{attrs:{id:"_3-2-hexists-key-field"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-hexists-key-field"}},[e._v("#")]),e._v(" 3.2 hexists key field")]),e._v(" "),r("p",[e._v("返回hash里面field是否存在")]),e._v(" "),r("h3",{attrs:{id:"返回值-18"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-18"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.redis.cn/topics/protocol.html#integer-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("integer-reply"),r("OutboundLink")],1),e._v(", 含义如下")]),e._v(" "),r("ul",[r("li",[e._v("1 hash里面包含该field")]),e._v(" "),r("li",[e._v("0 hash里面不包含该field或者key不存在")])]),e._v(" "),r("h2",{attrs:{id:"_3-hget-key-field"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-hget-key-field"}},[e._v("#")]),e._v(" 3. hget key field")]),e._v(" "),r("p",[e._v("返回 key 指定的哈希集中该字段所关联的值")]),e._v(" "),r("h3",{attrs:{id:"返回值-19"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-19"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.redis.cn/topics/protocol.html#bulk-string-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("bulk-string-reply"),r("OutboundLink")],1),e._v("：该字段所关联的值\n当字段不存在或者 key 不存在时返回nil")]),e._v(" "),r("h2",{attrs:{id:"_4-hgetall-key"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-hgetall-key"}},[e._v("#")]),e._v(" 4.  hgetall key")]),e._v(" "),r("p",[e._v("返回 key 指定的哈希集中所有的字段和值\n返回值中，每个字段名的下一个是它的值，所以返回值的长度是哈希集大小的两倍")]),e._v(" "),r("h3",{attrs:{id:"返回值-20"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-20"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.redis.cn/topics/protocol.html#array-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("array-reply"),r("OutboundLink")],1),e._v("：哈希集中字段和值的列表。当 key 指定的哈希集不存在时返回空列表。")]),e._v(" "),r("h2",{attrs:{id:"hkeys-key"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hkeys-key"}},[e._v("#")]),e._v(" hkeys key")]),e._v(" "),r("p",[e._v("返回 key 指定的哈希集中所有字段的名字")]),e._v(" "),r("h3",{attrs:{id:"返回值-21"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-21"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.redis.cn/topics/protocol.html#array-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("array-reply"),r("OutboundLink")],1),e._v("：哈希集中的字段列表，当 key 指定的哈希集不存在时返回空列表")]),e._v(" "),r("h2",{attrs:{id:"hvals-key"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hvals-key"}},[e._v("#")]),e._v(" hvals key")]),e._v(" "),r("p",[e._v("返回 key 指定的哈希集中所有字段的值")]),e._v(" "),r("h3",{attrs:{id:"返回值-22"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-22"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.redis.cn/topics/protocol#array-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("array-reply"),r("OutboundLink")],1),e._v("：哈希集中的值的列表，当 key 指定的哈希集不存在时返回空列表。")]),e._v(" "),r("h2",{attrs:{id:"_7-hlen"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-hlen"}},[e._v("#")]),e._v(" 7.  hlen")]),e._v(" "),r("p",[e._v("返回 "),r("code",[e._v("key")]),e._v(" 指定的哈希集包含的字段的数量")]),e._v(" "),r("h3",{attrs:{id:"返回值-23"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-23"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.redis.cn/topics/protocol.html#integer-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("integer-reply"),r("OutboundLink")],1),e._v("： 哈希集中字段的数量，当 "),r("code",[e._v("key")]),e._v(" 指定的哈希集不存在时返回 0")]),e._v(" "),r("h2",{attrs:{id:"_8-hmget"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-hmget"}},[e._v("#")]),e._v(" 8. hmget")]),e._v(" "),r("p",[e._v("返回 "),r("code",[e._v("key")]),e._v(" 指定的哈希集中指定字段的值。\n对于哈希集中不存在的每个字段，返回 "),r("code",[e._v("nil")]),e._v(" 值。因为不存在的keys被认为是一个空的哈希集，对一个不存在的 "),r("code",[e._v("key")]),e._v(" 执行 "),r("a",{attrs:{href:"http://www.redis.cn/commands/hmget.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("HMGET"),r("OutboundLink")],1),e._v(" 将返回一个只含有 "),r("code",[e._v("nil")]),e._v(" 值的列表")]),e._v(" "),r("h3",{attrs:{id:"返回值-24"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-24"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.redis.cn/topics/protocol.html#array-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("array-reply"),r("OutboundLink")],1),e._v("：含有给定字段及其值的列表，并保持与请求相同的顺序。\n##9. hmset key field value [field value ...]\n设置 key 指定的哈希集中指定字段的值。该命令将重写所有在哈希集中存在的字段。如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联")]),e._v(" "),r("h2",{attrs:{id:"_10-hsetnx-key-field-value"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-hsetnx-key-field-value"}},[e._v("#")]),e._v(" 10. hsetnx key field value")]),e._v(" "),r("p",[e._v("只在 key 指定的哈希集中不存在指定的字段时，设置字段的值\n如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联\n如果字段已存在，该操作无效果")]),e._v(" "),r("h1",{attrs:{id:"_4-list"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-list"}},[e._v("#")]),e._v(" 4 list")]),e._v(" "),r("p",[e._v("双向列表，适用于最新列表，关注列表")]),e._v(" "),r("h2",{attrs:{id:"_1-lpush"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-lpush"}},[e._v("#")]),e._v(" 1. lpush")]),e._v(" "),r("p",[e._v("将指定的值插入列表头")]),e._v(" "),r("ul",[r("li",[e._v("key 不存在， push 前会创建一个空列表")]),e._v(" "),r("li",[e._v("key 对应的值不是一个 list 的话，那么会返回一个错误")])]),e._v(" "),r("p",[e._v("可以使用一个命令把多个元素 push 进入列表，只需在命令末尾加上多个指定的参数\n元素是从最左端的到最右端的、一个接一个被插入到 list 的头部")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("lpush mylist a b c\n返回的列表是 c 为第一个元素， b 为第二个元素， a 为第三个元素\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br")])]),r("h3",{attrs:{id:"返回值-25"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-25"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[e._v("push 后的 list 长")]),e._v(" "),r("h3",{attrs:{id:"_2-llen"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-llen"}},[e._v("#")]),e._v(" 2. llen")]),e._v(" "),r("p",[e._v("返回存储在 key 里的list的长度\n如果 key 不存在，那么就被看作是空list，并且返回长度为 0\n当存储在 key 里的值不是一个list的话，会返回error")]),e._v(" "),r("h3",{attrs:{id:"返回值-26"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-26"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[e._v("key对应的list的长")]),e._v(" "),r("h2",{attrs:{id:"_3-lrange-key-start-stop"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-lrange-key-start-stop"}},[e._v("#")]),e._v(" 3. lrange key start stop")]),e._v(" "),r("p",[e._v("返回存储在 key 的列表里指定范围内的元素\nstart 和 end 偏移量都是基于0的下标，即list的第一个元素下标是0（list的表头），第二个元素下标是1，以此类推")]),e._v(" "),r("p",[e._v("偏移量也可以是负数，表示偏移量是从list尾部开始计数。 例如， -1 表示列表的最后一个元素，-2 是倒数第二个，以此类推。")]),e._v(" "),r("p",[e._v("###在不同编程语言里，关于求范围函数的一致性\n需要注意的是，如果你有一个list，里面的元素是从0到100，那么 "),r("code",[e._v("LRANGE list 0 10")]),e._v(" 这个命令会返回11个元素，即最右边的那个元素也会被包含在内。 在你所使用的编程语言里，这一点"),r("strong",[e._v("可能是也可能不是")]),e._v("跟那些求范围有关的函数都是一致的。（像Ruby的 Range.new，Array#slice 或者Python的 range() 函数。）\n###超过范围的下标\n当下标超过list范围的时候不会产生error。 如果start比list的尾部下标大的时候，会返回一个空列表。 如果stop比list的实际尾部大的时候，Redis会当它是最后一个元素的下标。\n###返回值\n指定范围里的列表元素\n##4. lset key index value\n设置 index 位置的list元素的值为 value\n当index超出范围时会返回一个error\n##5.  lindex key index\n返回列表里的元素的索引 index 存储在 key 里面。\n下标是从0开始,-1 表示最后一个元素\n当 key 位置的值不是一个列表的时候，会返回一个error")]),e._v(" "),r("h3",{attrs:{id:"返回值-27"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-27"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.redis.cn/topics/protocol.html#bulk-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("bulk-reply"),r("OutboundLink")],1),e._v("：请求的对应元素，或者当 index 超过范围的时候返回 nil\n##6. lpop\n移除并且返回 key 对应的 list 的第一个元素")]),e._v(" "),r("h3",{attrs:{id:"返回值-28"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-28"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[e._v("bulk-string-reply返回第一个元素的值，或者当 key 不存在时返回 nil。")]),e._v(" "),r("h2",{attrs:{id:"_7-rpop"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-rpop"}},[e._v("#")]),e._v(" 7 rpop")]),e._v(" "),r("p",[e._v("移除并返回存于 key 的 list 的最后一个元素。")]),e._v(" "),r("h3",{attrs:{id:"返回值-29"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-29"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[e._v("bulk-string-reply最后一个元素的值，或者当 key 不存在的时候返回 nil")]),e._v(" "),r("h2",{attrs:{id:"_8-bl-pop-key-key-timeout"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-bl-pop-key-key-timeout"}},[e._v("#")]),e._v(" 8 bl-pop key [key ...] timeout")]),e._v(" "),r("p",[e._v("阻塞列表的弹出\n是命令 l-pop的阻塞版本,当给定列表内没有元素可供弹出时, 连接将被阻塞\n当给定多个 key 参数时,按参数 key 的先后顺序依次检查各个列表,弹出第一个非空列表的头元素")]),e._v(" "),r("h3",{attrs:{id:"_8-1-非阻塞行为"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-非阻塞行为"}},[e._v("#")]),e._v(" 8.1 非阻塞行为")]),e._v(" "),r("p",[e._v("被调用时，如果给定 key 内至少有一个非空列表，那么弹出遇到的第一个非空列表的头元素，并和被弹出元素所属的列表的名字 key 一起，组成结果返回给调用者")]),e._v(" "),r("p",[e._v("设 key list1 不存在，而 list2 和 list3 都是非空列表")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("BLPOP list1 list2 list3 0\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br")])]),r("p",[e._v("BLPOP 保证返回一个存在于 list2 里的元素（因为它是从 list1 –> list2 –> list3 这个顺序查起的第一个非空列表）。")]),e._v(" "),r("h3",{attrs:{id:"_8-2-阻塞行为"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-阻塞行为"}},[e._v("#")]),e._v(" 8.2  阻塞行为")]),e._v(" "),r("p",[e._v("如果所有给定 key 都不存在或包含空列表，那么 "),r("a",{attrs:{href:"http://www.redis.cn/commands/blpop.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("BLPOP"),r("OutboundLink")],1),e._v(" 命令将阻塞连接， 直到有另一个客户端对给定的这些 key 的任意一个执行 "),r("a",{attrs:{href:"http://www.redis.cn/commands/lpush.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("LPUSH"),r("OutboundLink")],1),e._v(" 或 "),r("a",{attrs:{href:"http://www.redis.cn/commands/rpush.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("RPUSH"),r("OutboundLink")],1),e._v(" 命令为止。")]),e._v(" "),r("p",[e._v("一旦有新的数据出现在其中一个列表里，那么这个命令会解除阻塞状态，并且返回 key 和弹出的元素值。")]),e._v(" "),r("p",[e._v("当命令引起客户端阻塞并且设置了一个非零的超时参数 "),r("code",[e._v("timeout")]),e._v(" 时, 若经过了指定的 "),r("code",[e._v("timeout")]),e._v(" 仍没有出现一个针对某一特定 key 的 push 操作，则客户端会解除阻塞状态并且返回一个 nil 的多组合值(multi-bulk value)")]),e._v(" "),r("p",[r("strong",[e._v("timeout 参数表示的是一个指定阻塞的最大秒数的整型值")]),e._v("\n当 timeout 为 0 是表示阻塞时间无限制")]),e._v(" "),r("p",[e._v("###8.3 什么 key 会先被处理？是什么客户端？什么元素？优先顺序细节。")]),e._v(" "),r("ul",[r("li",[e._v("当客户端为多个 key 尝试阻塞的时候，若至少存在一个 key 拥有元素，那么返回的键值对(key/element pair)就是从左到右数第一个拥有一个或多个元素的key。\n在这种情况下客户端不会被阻塞")]),e._v(" "),r("li",[e._v("当多个客户端为同一个 key 阻塞的时候，第一个被处理的客户端是等待最长时间的那个（即第一个因为该key而阻塞的客户端）。 一旦一个客户端解除阻塞那么它就不会保持任何优先级，当它因为下一个 BLPOP 命令而再次被阻塞的时候，会在处理完那些 被同个 key 阻塞的客户端后才处理它（即从第一个被阻塞的处理到最后一个被阻塞的）。")]),e._v(" "),r("li",[e._v("当一个客户端同时被多个 key 阻塞时，若多个 key 的元素同时可用（可能是因为事务或者某个Lua脚本向多个list添加元素）， 那么客户端会解除阻塞，并使用第一个接收到 push 操作的 key（假设它拥有足够的元素为我们的客户端服务，因为有可能存在其他客户端同样是被这个key阻塞着）。 从根本上来说，在执行完每个命令之后，Redis 会把一个所有 key 都获得数据并且至少使一个客户端阻塞了的 list 运行一次。 这个 list 按照新数据的接收时间进行整理，即是从第一个接收数据的 key 到最后一个。在处理每个 key 的时候，只要这个 key 里有元素， Redis就会对所有等待这个key的客户端按照“先进先出”(FIFO)的顺序进行服务。若这个 key 是空的，或者没有客户端在等待这个 key， 那么将会去处理下一个从之前的命令或事务或脚本中获得新数据的 key，如此等等。")])]),e._v(" "),r("h2",{attrs:{id:"当多个元素被-push-进入一个-list-时-blpop-的行为"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#当多个元素被-push-进入一个-list-时-blpop-的行为"}},[e._v("#")]),e._v(" 当多个元素被 push 进入一个 list 时 BLPOP 的行为")]),e._v(" "),r("p",[e._v("有时候一个 list 会在同一概念的命令的情况下接收到多个元素：")]),e._v(" "),r("ul",[r("li",[e._v("像 LPUSH mylist a b c 这样的可变 push 操作。")]),e._v(" "),r("li",[e._v("在对一个向同一个 list 进行多次 push 操作的 MULTI 块执行完 EXEC 语句后。")]),e._v(" "),r("li",[e._v("使用 Redis 2.6 或者更新的版本执行一个 Lua 脚本。")])]),e._v(" "),r("p",[e._v("当多个元素被 push 进入一个被客户端阻塞着的 list 的时候，Redis 2.4 和 Redis 2.6 或者更新的版本所采取行为是不一样的。")]),e._v(" "),r("p",[e._v("对于 Redis 2.6 来说，所采取的行为是先执行多个 push 命令，然后在执行了这个命令之后再去服务被阻塞的客户端。看看下面命令顺序。")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("Client A:   BLPOP foo 0\nClient B:   LPUSH foo a b c\n\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br")])]),r("p",[e._v("如果上面的情况是发生在 Redis 2.6 或更高版本的服务器上，客户端 A 会接收到 c 元素，因为在 "),r("a",{attrs:{href:"http://www.redis.cn/commands/lpush.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("LPUSH"),r("OutboundLink")],1),e._v(" 命令执行后，list 包含了 c,b,a 这三个元素，所以从左边取一个元素就会返回 c。")]),e._v(" "),r("p",[e._v("相反，Redis 2.4 是以不同的方式工作的：客户端会在 push 操作的上下文中被服务，所以当 LPUSH foo a b c 开始往 list 中 push 第一个元素，它就被传送给客户端A，也就是客户端A会接收到 a（第一个被 push 的元素）。")]),e._v(" "),r("p",[e._v("Redis 2.4的这种行为会在复制或者持续把数据存入AOF文件的时候引发很多问题，所以为了防止这些问题，很多更一般性的、并且在语义上更简单的行为被引入到 Redis 2.6 中。")]),e._v(" "),r("p",[e._v("需要注意的是，一个Lua脚本或者一个 "),r("a",{attrs:{href:"http://www.redis.cn/commands/multi.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("MULTI"),r("OutboundLink")],1),e._v(" / "),r("a",{attrs:{href:"http://www.redis.cn/commands/exec.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("EXEC"),r("OutboundLink")],1),e._v(" 块可能会 push 一堆元素进入一个 list 后，再 删除这个 list。 在这种情况下，被阻塞的客户端完全不会被服务，并且只要在执行某个单一命令、事务或者脚本后 list 中没有出现元素，它就会被继续阻塞下去。")]),e._v(" "),r("h2",{attrs:{id:"在一个-multi-exec-事务中的-blpop"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#在一个-multi-exec-事务中的-blpop"}},[e._v("#")]),e._v(" 在一个 MULTI / EXEC 事务中的 BLPOP")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.redis.cn/commands/blpop.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("BLPOP"),r("OutboundLink")],1),e._v(" 可以用于流水线（pipeline，发送多个命令并且批量读取回复），特别是当它是流水线里的最后一个命令的时候，这种设定更加有意义。")]),e._v(" "),r("p",[e._v("在一个 "),r("a",{attrs:{href:"http://www.redis.cn/commands/multi.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("MULTI"),r("OutboundLink")],1),e._v(" / "),r("a",{attrs:{href:"http://www.redis.cn/commands/exec.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("EXEC"),r("OutboundLink")],1),e._v(" 块里面使用 "),r("a",{attrs:{href:"http://www.redis.cn/commands/blpop.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("BLPOP"),r("OutboundLink")],1),e._v(" 并没有很大意义，因为它要求整个服务器被阻塞以保证块执行时的原子性，这就阻止了其他客户端执行一个 push 操作。 因此，一个在 "),r("a",{attrs:{href:"http://www.redis.cn/commands/multi.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("MULTI"),r("OutboundLink")],1),e._v(" / "),r("a",{attrs:{href:"http://www.redis.cn/commands/exec.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("EXEC"),r("OutboundLink")],1),e._v(" 里面的 "),r("a",{attrs:{href:"http://www.redis.cn/commands/blpop.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("BLPOP"),r("OutboundLink")],1),e._v(" 命令会在 list 为空的时候返回一个 "),r("code",[e._v("nil")]),e._v(" 值，这跟超时(timeout)的时候发生的一样。")]),e._v(" "),r("p",[e._v("如果你喜欢科幻小说，那么想象一下时间是以无限的速度在 MULTI / EXEC 块中流逝……")]),e._v(" "),r("p",[e._v("##返回值")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.redis.cn/topics/protocol.html#multi-bulk-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("多批量回复(multi-bulk-reply)"),r("OutboundLink")],1),e._v(": 具体来说:")]),e._v(" "),r("ul",[r("li",[e._v("当没有元素的时候会弹出一个 nil 的多批量值，并且 timeout 过期。")]),e._v(" "),r("li",[e._v("当有元素弹出时会返回一个双元素的多批量值，其中第一个元素是弹出元素的 key，第二个元素是 value。")])]),e._v(" "),r("h2",{attrs:{id:"例子"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#例子"}},[e._v("#")]),e._v(" 例子")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('redis> DEL list1 list2\n(integer) 0\nredis> RPUSH list1 a b c\n(integer) 3\nredis> BLPOP list1 list2 0\n1) "list1"\n2) "a"\n\n')])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br"),r("span",{staticClass:"line-number"},[e._v("8")]),r("br")])]),r("h2",{attrs:{id:"可靠的队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#可靠的队列"}},[e._v("#")]),e._v(" 可靠的队列")]),e._v(" "),r("p",[e._v("当 "),r("a",{attrs:{href:"http://www.redis.cn/commands/blpop.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("BLPOP"),r("OutboundLink")],1),e._v(" 返回一个元素给客户端的时候，它也从 list 中把该元素移除。这意味着该元素就只存在于客户端的上下文中：如果客户端在处理这个返回元素的过程崩溃了，那么这个元素就永远丢失了。")]),e._v(" "),r("p",[e._v("在一些我们希望是更可靠的消息传递系统中的应用上，这可能会导致一些问题。在这种时候，请查看 "),r("a",{attrs:{href:"http://www.redis.cn/commands/brpoplpush.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("BRPOPLPUSH"),r("OutboundLink")],1),e._v(" 命令，这是 "),r("a",{attrs:{href:"http://www.redis.cn/commands/blpop.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("BLPOP"),r("OutboundLink")],1),e._v(" 的一个变形，它会在把返回元素传给客户端之前先把该元素加入到一个目标 list 中。")]),e._v(" "),r("h2",{attrs:{id:"模式-事件提醒"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模式-事件提醒"}},[e._v("#")]),e._v(" 模式：事件提醒")]),e._v(" "),r("p",[e._v("用来阻塞 list 的操作有可能是不同的阻塞原语。 比如在某些应用里，你也许会为了等待新元素进入 Redis Set 而阻塞队列，直到有个新元素加入到 Set 中，这样就可以在不轮询的情况下获得元素。 这就要求要有一个 "),r("a",{attrs:{href:"http://www.redis.cn/commands/spop.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("SPOP"),r("OutboundLink")],1),e._v(" 的阻塞版本，而这事实上并不可用。但是我们可以通过阻塞 list 操作轻易完成这个任务。")]),e._v(" "),r("p",[e._v("消费者会做的：")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("LOOP forever\n    WHILE SPOP(key) returns elements\n        ... process elements ...\n    END\n    BRPOP helper_key\nEND\n\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br")])]),r("p",[e._v("而在生产者这角度我们可以这样简单地使用：")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("MULTI\nSADD key element\nLPUSH helper_key x\nEXEC\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br")])]),r("h1",{attrs:{id:"_5-set结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-set结构"}},[e._v("#")]),e._v(" 5 set结构")]),e._v(" "),r("p",[e._v("适用于无序的集合\n点赞点踩,抽奖,已读,共同好友")]),e._v(" "),r("h2",{attrs:{id:"_1-sadd-key-member-member"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-sadd-key-member-member"}},[e._v("#")]),e._v(" 1.  sadd key member [member ...]")]),e._v(" "),r("p",[e._v("**时间复杂度：**O(N)\n添加一个或多个指定的member元素到集合的 key中.指定的一个或者多个元素member 如果已经在集合key中存在则忽略.\n如果集合key 不存在，则新建集合key,并添加member元素到集合key中.\n##2. scard\n**时间复杂度：**O(1)\n返回集合存储的key的基数 (集合元素的数量)\n如果key不存在,则返回 0\n##3. smembers key\n**时间复杂度：**O(N)\n返回key集合所有的元素.\n该命令的作用与使用一个参数的"),r("a",{attrs:{href:"http://www.redis.cn/commands/sinter.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("SINTER"),r("OutboundLink")],1),e._v(" 命令作用相同.")]),e._v(" "),r("h2",{attrs:{id:"_4-sdiff-key-key"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-sdiff-key-key"}},[e._v("#")]),e._v(" 4. sdiff key [key ...]")]),e._v(" "),r("p",[e._v("**时间复杂度：**O(N)\n返回一个集合与给定集合的差集的元素\n不存在的key认为是空集.\n##5. sinner key [key ...]\n**时间复杂度：**O(N*M)\n返回指定所有的集合的成员的交集.\n###返回值\n"),r("a",{attrs:{href:"http://www.redis.cn/topics/protocol.html#array-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("array-reply"),r("OutboundLink")],1),e._v(": 结果集成员的列表.\n##6. sunion key [key ...]\n**时间复杂度：**O(N) where N is the total number of elements in all given sets.\n返回给定的多个集合的并集中的所有成员.\n不存在的key可以认为是空的集合.\n###返回值\n"),r("a",{attrs:{href:"http://www.redis.cn/topics/protocol#array-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("array-reply"),r("OutboundLink")],1),e._v(":并集的成员列表\n##7. srandmember key [count]\n**时间复杂度：**Without the count argument O(1), otherwise O(N) where N is the absolute value of the passed count\n仅提供key参数,那么随机返回key集合中的一个元素.")]),e._v(" "),r("p",[e._v("Redis 2.6开始, 可以接受 count 参数,如果count是整数且小于元素的个数，返回含有 count 个不同的元素的数组,如果count是个整数且大于集合中元素的个数时,仅返回整个集合的所有元素,当count是负数,则会返回一个包含count的绝对值的个数元素的数组，如果count的绝对值大于元素的个数,则返回的结果集里会出现一个元素出现多次的情况.")]),e._v(" "),r("p",[e._v("仅提供key参数时,该命令作用类似于SPOP命令, 不同的是SPOP命令会将被选择的随机元素从集合中移除, 而SRANDMEMBER仅仅是返回该随记元素,而不做任何操作.")]),e._v(" "),r("h3",{attrs:{id:"返回值-30"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-30"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.redis.cn/topics/protocol.html#bulk-string-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("bulk-string-reply"),r("OutboundLink")],1),e._v(": 不使用count 参数的情况下该命令返回随机的元素,如果key不存在则返回nil.\n"),r("a",{attrs:{href:"http://www.redis.cn/topics/protocol.html#array-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("array-reply"),r("OutboundLink")],1),e._v(": 使用count参数,则返回一个随机的元素数组,如果key不存在则返回一个空的数组.\n##8. sismember key member\n**时间复杂度：**O(1)\n返回成员 member 是否是存储的集合 key的成员.\n###返回值\n"),r("a",{attrs:{href:"http://www.redis.cn/topics/protocol.html#integer-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("integer-reply"),r("OutboundLink")],1),e._v(",详细说明")]),e._v(" "),r("ul",[r("li",[e._v("是则返回1")]),e._v(" "),r("li",[e._v("不是或者key不存在，则返回0\n##9. srem key member [member ...]\n**时间复杂度：**O(N)\n在key集合中移除指定的元素.\n不是key集合中的元素则忽略\n如果key集合不存在则被视为一个空的集合，该命令返回0.\n如果key的类型不是一个集合,则返回错误.")])]),e._v(" "),r("h3",{attrs:{id:"返回值-31"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-31"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[e._v("integer-reply:从集合中移除元素的个数，不包括不存在的成员\n##10. spop  key [count]\n时间复杂度：O(1)\n从键的set值存储中移除并返回count个随机元素\n#sorted set\n##1. zadd key [NX|XX] [CH] [INCR] score member [score member ...]\n将所有指定成员添加到键为key有序集合（sorted set）里\n##2. zcard key\n**时间复杂度：**O(1)\n返回key的有序集元素个数\n###返回值\n"),r("a",{attrs:{href:"http://www.redis.cn/topics/protocol#integer-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("integer-reply"),r("OutboundLink")],1),e._v(": key存在的时候，返回有序集的元素个数，否则返回0\n##3. zscoer key member\n**时间复杂度：**O(1)\n返回有序集key中，成员member的score值。\n如果member元素不是有序集key的成员，或key不存在，返回nil。\n###返回值\n"),r("a",{attrs:{href:"http://www.redis.cn/topics/protocol#bulk-string-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("bulk-string-reply"),r("OutboundLink")],1),e._v(": member成员的score值（double型浮点数），以字符串形式表示")]),e._v(" "),r("h2",{attrs:{id:"_4-zcount-key-min-max"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-zcount-key-min-max"}},[e._v("#")]),e._v(" 4. zcount key min max")]),e._v(" "),r("p",[e._v("**时间复杂度：**O(log(N)) with N being the number of elements in the sorted set.\n返回有序集key中，score值在min和max之间(默认包括score值等于min或max)的成员。\n###返回值\n"),r("a",{attrs:{href:"http://www.redis.cn/topics/protocol#integer-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("integer-reply"),r("OutboundLink")],1),e._v(": 指定分数范围的元素个数")]),e._v(" "),r("h2",{attrs:{id:"_5-zrank-key-member"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-zrank-key-member"}},[e._v("#")]),e._v(" 5. zrank key member")]),e._v(" "),r("p",[e._v("**时间复杂度：**O(log(N))\n返回有序集key中成员member的排名。其中有序集成员按score值递增(从小到大)顺序排列。排名以0为底，也就是说，score值最小的成员排名为0。\n使用ZREVRANK命令可以获得成员按score值递减(从大到小)排列的排名。\n###返回值")]),e._v(" "),r("ul",[r("li",[e._v("如果member是有序集key的成员，返回"),r("a",{attrs:{href:"http://www.redis.cn/topics/protocol#integer-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("integer-reply"),r("OutboundLink")],1),e._v("：member的排名。")]),e._v(" "),r("li",[e._v("如果member不是有序集key的成员，返回"),r("a",{attrs:{href:"http://www.redis.cn/topics/protocol#bulk-string-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("bulk-string-reply"),r("OutboundLink")],1),e._v(": "),r("code",[e._v("nil")]),e._v("。")])]),e._v(" "),r("h2",{attrs:{id:"_6-zincrby-key-increment-member"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-zincrby-key-increment-member"}},[e._v("#")]),e._v(" 6. zincrby key increment member")]),e._v(" "),r("p",[e._v("**时间复杂度：**O(log(N)) where N is the number of elements in the sorted set.\n为有序集key的成员member的score值加上增量increment。如果key中不存在member，就在key中添加一个member，score是increment（就好像它之前的score是0.0）。如果key不存在，就创建一个只含有指定member成员的有序集合。\n当key不是有序集类型时，返回一个错误。\nscore值必须是字符串表示的整数值或双精度浮点数，并且能接受double精度的浮点数。也有可能给一个负数来减少score的值。\n###返回值\n[Bulk string reply](http://www.redis.cn/topics/protocol#Bulk string reply): member成员的新score值，以字符串形式表示\n##7. zrange key start stop [WITHSCORES]")]),e._v(" "),r("p",[e._v("##8. ZREVRANGE key start stop [WITHSCORES]\n返回sorted set key中，指定区间内的成员。其中成员的位置按score值递减(从大到小)来排列。具有相同score值的成员按字典序的反序排列。 除了成员按score值递减的次序排列这一点外，"),r("a",{attrs:{href:"http://www.redis.cn/commands/zrevrange.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("ZREVRANGE"),r("OutboundLink")],1),e._v("命令的其他方面和"),r("a",{attrs:{href:"http://www.redis.cn/commands/zrange.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("ZRANGE"),r("OutboundLink")],1),e._v("命令一样。\n##返回值\n"),r("a",{attrs:{href:"http://www.redis.cn/topics/protocol#array-reply",target:"_blank",rel:"noopener noreferrer"}},[e._v("array-reply"),r("OutboundLink")],1),e._v(": 指定范围的元素列表(可选是否含有分数)。")]),e._v(" "),r("p",[e._v("例子")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('redis> ZADD myzset 1 "one"\n(integer) 1\nredis> ZADD myzset 2 "two"\n(integer) 1\nredis> ZADD myzset 3 "three"\n(integer) 1\nredis> ZREVRANGE myzset 0 -1\n1) "three"\n2) "two"\n3) "one"\nredis> ZREVRANGE myzset 2 3\n1) "one"\nredis> ZREVRANGE myzset -2 -1\n1) "two"\n2) "one"\nredis> \n')])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br"),r("span",{staticClass:"line-number"},[e._v("8")]),r("br"),r("span",{staticClass:"line-number"},[e._v("9")]),r("br"),r("span",{staticClass:"line-number"},[e._v("10")]),r("br"),r("span",{staticClass:"line-number"},[e._v("11")]),r("br"),r("span",{staticClass:"line-number"},[e._v("12")]),r("br"),r("span",{staticClass:"line-number"},[e._v("13")]),r("br"),r("span",{staticClass:"line-number"},[e._v("14")]),r("br"),r("span",{staticClass:"line-number"},[e._v("15")]),r("br"),r("span",{staticClass:"line-number"},[e._v("16")]),r("br")])]),r("h2",{attrs:{id:"monitor"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#monitor"}},[e._v("#")]),e._v(" monitor")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.redis.cn/commands/monitor.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("MONITOR"),r("OutboundLink")],1),e._v(" 是一个调试命令，返回服务器处理的每一个命令，它能帮助我们了解在数据库上发生了什么操作，可以通过redis-cli和telnet命令使用.")]),e._v(" "),r("h1",{attrs:{id:"_6-redis-复制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-redis-复制"}},[e._v("#")]),e._v(" 6 Redis 复制")]),e._v(" "),r("h2",{attrs:{id:"psync"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#psync"}},[e._v("#")]),e._v(" PSYNC")]),e._v(" "),r("p",[e._v("2.8.0 起可用。")]),e._v(" "),r("p",[e._v("从主机启动复制流。\nPSYNC 命令由 Redis 从节点调用，用于从主副本启动复制流。")]),e._v(" "),r("h2",{attrs:{id:"wait"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#wait"}},[e._v("#")]),e._v(" wait")]),e._v(" "),r("p",[e._v("此命令阻塞当前客户端，直到所有以前的写命令都成功的传输和指定的slaves确认。如果超时，指定以毫秒为单位，即使指定的slaves还没有到达，命令任然返回。")]),e._v(" "),r("p",[e._v("命令始终返回之前写命令发送的slaves的数量，无论是在指定slaves的情况还是达到超时。")]),e._v(" "),r("p",[e._v("注意点:")]),e._v(" "),r("ol",[r("li",[e._v("当’WAIT’返回时，所有之前的写命令保证接收由WAIT返回的slaves的数量。")]),e._v(" "),r("li",[e._v("如果命令呗当做事务的一部分发送，该命令不阻塞，而是只尽快返回先前写命令的slaves的数量。")]),e._v(" "),r("li",[e._v("如果timeout是0那意味着永远阻塞。")]),e._v(" "),r("li",[e._v("由于WAIT返回的是在失败和成功的情况下的slaves的数量。客户端应该检查返回的slaves的数量是等于或更大的复制水平。")])]),e._v(" "),r("h3",{attrs:{id:"一致性-consistency-and-wait"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一致性-consistency-and-wait"}},[e._v("#")]),e._v(" 一致性（Consistency and WAIT）")]),e._v(" "),r("p",[e._v("WAIT 不能保证Redis强一致：尽管同步复制是复制状态机的一个部分，但是还需要其他条件。不过，在sentinel和Redis群集故障转移中，WAIT 能够增强数据的安全性。")]),e._v(" "),r("p",[e._v("如果写操作已经被传送给一个或多个slave节点，当master发生故障我们极大概率(不保证100%)提升一个受到写命令的slave节点为master:不管是Sentinel还是Redis Cluster 都会尝试选slave节点中最优(日志最新)的节点，提升为master。")]),e._v(" "),r("p",[e._v("尽管是选择最优节点，但是仍然会有丢失一个同步写操作可能行。")]),e._v(" "),r("h3",{attrs:{id:"实现细节"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实现细节"}},[e._v("#")]),e._v(" 实现细节")]),e._v(" "),r("p",[e._v("因为引入了部分同步，Redis slave节点在ping主节点时会携带已经处理的复制偏移量。 这被用在多个地方：")]),e._v(" "),r("ol",[r("li",[e._v("检测超时的slaves")]),e._v(" "),r("li",[e._v("断开连接后的部分复制")]),e._v(" "),r("li",[e._v("实现WAIT")])]),e._v(" "),r("p",[e._v("在WAIT实现的案例中，当客户端执行完一个写命令后，针对每一个复制客户端，Redis会为其记录写命令产生的复制偏移量。当执行命令WAIT时，Redis会检测 slaves节点是否已确认完成该操作或更新的操作。")]),e._v(" "),r("h3",{attrs:{id:"返回值-32"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值-32"}},[e._v("#")]),e._v(" 返回值")]),e._v(" "),r("p",[e._v("integer-reply: 当前连接的写操作会产生日志偏移，该命令会返回已处理至该偏移量的slaves的个数。")]),e._v(" "),r("p",[e._v("例子")]),e._v(" "),r("div",{staticClass:"language-shell line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-shell"}},[r("code",[r("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" SET foo bar\nOK\n"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" WAIT "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("integer"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" WAIT "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("1000")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("integer"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),e._v("\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br")])]),r("p",[e._v("在例子中，第一次调用WAIT并没有使用超时设置，并且设置写命令传输到一个slave节点，返回成功。第二次使用时，我们设置了超时值并要求写命令传输到两个节点。 因为只有一个slave节点有效，1秒后WAIT解除阻塞并返回1–传输成功的slave节点数。")])])}),[],!1,null,null,null);t.default=a.exports}}]);