(window.webpackJsonp=window.webpackJsonp||[]).push([[1140],{1535:function(e,t,a){"use strict";a.r(t);var r=a(13),_=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("很多同学更新缓存时，"),a("strong",[e._v("先删除缓存，再更新数据库")]),e._v("，而后续操作会把数据再装载到缓存。")]),e._v(" "),a("p",[a("strong",[e._v("这个逻辑是错误的")]),e._v("。最简单的两个并发操作：更新&查询。\n更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存，然后更新操作更新了数据库。于是，缓存中的数据还是老数据，导致缓存中的数据是脏的，而且还一直这样脏下去。所以特此总结一下几个缓存更新的Design Pattern。")]),e._v(" "),a("p",[e._v("先不讨论更新缓存和更新数据这两个事是一个事务的事，或是会有失败的可能，先假设更新数据库和更新缓存都可以成功的情况。")]),e._v(" "),a("h1",{attrs:{id:"_1-cache-aside-旁路缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-cache-aside-旁路缓存"}},[e._v("#")]),e._v(" 1  Cache Aside（旁路缓存）")]),e._v(" "),a("p",[e._v("最常用的模式：")]),e._v(" "),a("ul",[a("li",[e._v("失效\n应用先从cache取数据，没有得到，则从DB取数据，成功后，放入cache")]),e._v(" "),a("li",[e._v("命中\n应用程序从cache中取数据，取到后返回")]),e._v(" "),a("li",[e._v("更新\n先把数据存到DB，成功后，再让缓存失效\n"),a("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/a583a805ba22360ab0e5dd257ef37b1c.png",alt:"Cache-Aside-Design-Pattern-Flow-Diagram"}}),e._v(" "),a("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/897b76d9ef2bec14e800c75753653d3a.png",alt:"Updating Data using the Cache-Aside Pattern - Flow Diagram"}})])]),e._v(" "),a("p",[e._v("注意，是先更新DB，成功后，让缓存失效。")]),e._v(" "),a("p",[e._v("一个查询操作，一个更新操作的并发\n首先，没有了删除cache数据的操作，而是先更新数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。而不会像文章开头的那个逻辑产生的问题，后续的查询操作一直都在取老的数据。")]),e._v(" "),a("p",[e._v("这是标准的design pattern，包括Facebook的论文《"),a("a",{attrs:{href:"https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Scaling Memcache at Facebook"),a("OutboundLink")],1),e._v("》也使用了这个策略。为什么不是写DB后更新缓存？可以看一下Quora上的这个问答《"),a("a",{attrs:{href:"https://www.quora.com/Why-does-Facebook-use-delete-to-remove-the-key-value-pair-in-Memcached-instead-of-updating-the-Memcached-during-write-request-to-the-backend",target:"_blank",rel:"noopener noreferrer"}},[e._v("Why does Facebook use delete to remove the key-value pair in Memcached instead of updating the Memcached during write request to the backend?"),a("OutboundLink")],1),e._v("》，主要是怕两个并发的写操作导致脏数据。")]),e._v(" "),a("p",[e._v("那Cache Aside有并发问题吗？\n有。比如，一个是"),a("code",[e._v("读操作")]),e._v("，但是没有命中缓存，然后就到数据库中取数据，此时来了一个"),a("code",[e._v("写操作")]),e._v("，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。")]),e._v(" "),a("p",[e._v("这个情形理论上会出现，不过，实际上出现的概率可能非常低，因为需要发生在读缓存时缓存失效，而且并发着有一个写操作。\n而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大")]),e._v(" "),a("p",[e._v("这也就是Quora上的那个答案里说的，要么通过2PC或是Paxos协议保证一致性，要么就是拼命的降低并发时脏数据的概率，而Facebook使用了这个降低概率的玩法，因为2PC太慢，而Paxos太复杂。当然，最好还是为缓存设置上过期时间。")]),e._v(" "),a("h1",{attrs:{id:"_2-read-write-through-pattern"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-read-write-through-pattern"}},[e._v("#")]),e._v(" 2 Read/Write Through Pattern")]),e._v(" "),a("p",[e._v("上面的Cache Aside，应用代码需要维护两个数据存储，一个是缓存，一个是数据库,应用程序比较啰嗦。\n而"),a("code",[e._v("Read/Write Through")]),e._v("是把更新数据库的操作由缓存自己代理，所以，对于应用层来说，就简单很多。\n可理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的Cache。")]),e._v(" "),a("h2",{attrs:{id:"_2-1-read-through"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-read-through"}},[e._v("#")]),e._v(" 2.1  Read Through")]),e._v(" "),a("p",[e._v("Read Through 就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出）")]),e._v(" "),a("ul",[a("li",[e._v("Cache Aside是由"),a("code",[e._v("调用方负责")]),e._v("把数据加载入缓存")]),e._v(" "),a("li",[e._v("Read Through则用"),a("code",[e._v("缓存服务")]),e._v("自己来加载，从而对应用方是透明的")])]),e._v(" "),a("h2",{attrs:{id:"_2-2-write-through"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-write-through"}},[e._v("#")]),e._v(" 2.2  Write Through")]),e._v(" "),a("p",[e._v("和Read Through相仿，不过是在更新数据时发生\n当有数据更新时")]),e._v(" "),a("ul",[a("li",[e._v("如果没有命中缓存，直接更新数据库，然后返回")]),e._v(" "),a("li",[e._v("如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）")])]),e._v(" "),a("p",[e._v("下图中的Memory可以理解为就是我们例子里的数据库\n"),a("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/642013cf5ea3b5ec2859a4c0feabccd6.png",alt:"A write-through cache with no-write allocation"}})]),e._v(" "),a("h1",{attrs:{id:"_3-write-behind-异步写回"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-write-behind-异步写回"}},[e._v("#")]),e._v(" 3 Write Behind（异步写回）")]),e._v(" "),a("p",[e._v("又叫 Write Back。在更新数据时，只更新缓存，不更新DB，而我们的缓存会异步批量更新DB")]),e._v(" "),a("h2",{attrs:{id:"优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[e._v("#")]),e._v(" 优点")]),e._v(" "),a("ul",[a("li",[e._v("让数据的I/O操作飞快无比（因为直接操作内存嘛 ）")]),e._v(" "),a("li",[e._v("因为异步，write back还可以合并对同一个数据的多次操作，所以性能的提高是相当可观")])]),e._v(" "),a("h2",{attrs:{id:"缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[e._v("#")]),e._v(" 缺点")]),e._v(" "),a("p",[e._v("数据不是强一致性的，而且可能会丢失（我们知道Unix/Linux非正常关机会导致数据丢失，就是因为这个事）。")]),e._v(" "),a("p",[e._v("另外，Write Back实现逻辑比较复杂，因为他需要track哪些数据是被更新的，需要刷到持久层。\nos的write back会在仅当这个cache需要失效时，才会被真正持久化，比如，内存不够了，或是进程退出了等情况，这又叫lazy write。")]),e._v(" "),a("p",[e._v("比如在向磁盘中写数据时采用的也是这种策略。无论是：")]),e._v(" "),a("ul",[a("li",[e._v("os层面的 Page Cache")]),e._v(" "),a("li",[e._v("日志的异步刷盘")]),e._v(" "),a("li",[e._v("消息队列中消息的异步写入磁盘")])]),e._v(" "),a("p",[e._v("大多采用了这种策略。因为这个策略在性能优势明显，直接写内存，避免了直接写磁盘造成的随机写。")]),e._v(" "),a("ul",[a("li",[e._v("A write-back cache with write allocation\n"),a("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/3210481d0a1230f6d75eb45058776f43.png",alt:""}})])])])}),[],!1,null,null,null);t.default=_.exports}}]);