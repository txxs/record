(window.webpackJsonp=window.webpackJsonp||[]).push([[673],{1069:function(a,e,n){"use strict";n.r(e);var t=n(13),s=Object(t.a)({},(function(){var a=this,e=a.$createElement,n=a._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("p",[a._v("#1 同步容器类\n同步容器类包括Vector和HashTable，二者是早期JDK一部分，此外还包括在JDK 1.2中添加的一些功能相似的类，这些的同步封装器类是由Collections.synchronizedXxx等工厂方法创建的。这些类实现线程安全的方式是：将他们的状态封装起来，并对每个共有方法进行同步，使得每次只有一个线程能访问容器的状态。")]),a._v(" "),n("h2",{attrs:{id:"_1-1-同步容器类的问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-同步容器类的问题"}},[a._v("#")]),a._v(" 1.1 同步容器类的问题")]),a._v(" "),n("p",[a._v("同步容器类都是线程安全的，但在某些情况可能需额外客户端加锁来保护复合操作。\n容器上常见的复合操作包括：")]),a._v(" "),n("ul",[n("li",[a._v("迭代(反复访问元素，直到遍历完容器中所有元素)")]),a._v(" "),n("li",[a._v("跳转(根据指定顺序找到当前元素的下一个元素)以及条件运算")])]),a._v(" "),n("p",[a._v("在同步容器类中，这些复合操作在没有客户端加锁的情况下，仍是线程安全的，\n但当其他线程并发的修改容器时，他们可能会表现出意料之外的行为。")]),a._v(" "),n("h1",{attrs:{id:"_2-并发容器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-并发容器"}},[a._v("#")]),a._v(" 2 并发容器")]),a._v(" "),n("p",[a._v("Java5提供了多种并发容器来改进同步容器的性能。")]),a._v(" "),n("p",[a._v("同步容器将所有对容器状态的访问都串行化，以实现他们的线程安全性。\n这种方法的代价是严重降低并发性，当多个线程竞争容器的锁时，吞吐量将严重降低。")]),a._v(" "),n("p",[a._v("并发容器是针对多个线程并发访问设计的。在Java 5中增加了")]),a._v(" "),n("ul",[n("li",[a._v("ConcurrentHashMap，用来替代同步且基于散列的Map，增加了对一些常见符合操作的支持，例如“若没有则添加”、替换以及有条件删除等。")]),a._v(" "),n("li",[a._v("CopyOnWriteArrayList，用于在遍历操作为主要操作的情况下代替同步的List。")])]),a._v(" "),n("p",[n("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-8f68228c343b71ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}}),a._v("\ncopyOnWriteArrayList 和 copyOnWriteSet 一开始都共享同一个内容，当想要修改内容时,才会真正的把内容 copy 出去,形成一个新的内容后再改\n比如：当我们往一个容器添加元素时，不直接往当前容器添加，而是先将容器进行 copy，复制出一个新容器，再往新容器里加元素。添加完之后，再将原容器引用指向新容器。\n好处:对 copyOnWrite 容器进行并发读时,不需要加锁,因为当前容器不会增加新元素,读写分离\n"),n("code",[a._v("copyOnWriteArrayList#add")]),a._v("要加锁,否则多线程时会 copy N 个副本\ncopyOnWrite 适合于"),n("code",[a._v("读多写少")]),a._v("场景，但只能保证数据最终一致性,不保证实时一致性\n若你希望写入马上被读到，不要用 copyOnWrite 容器")]),a._v(" "),n("p",[n("strong",[a._v("通过并发容器来代替同步容器，可以极大地提供伸缩性并降低风险。")])]),a._v(" "),n("h2",{attrs:{id:"_2-1-cocurrenthashmap"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-cocurrenthashmap"}},[a._v("#")]),a._v(" 2.1 CocurrentHashMap")]),a._v(" "),n("p",[a._v("同步容器在执行每个操作期间都持有一个锁。在一些操作中，例如"),n("code",[a._v("HashMashMap.get")]),a._v("或"),n("code",[a._v("List.contains")]),a._v("，可能包含大量的工作：当遍历散列桶或链表来查找某个特定的对象时，必须在许多元素上调用equals。在基于散列的容器中，如果hashCode不能很均匀的分布散列值，那么容器中的元素就不会均匀的分布在整个容器中。某些情况下，某个糟糕的散列函数还会把一个散列表变成线性链表。当遍历很长的链表并且在某些或者全部元素上调用equals方法时，会花费很长时间，而其他线程在这段时间内都不能访问容器。")]),a._v(" "),n("p",[a._v("ConcurrentHashMap使用一种粒度更细的称为分段锁的机制来实现更大程度的共享.\n在这种机制中，任意数量的读取线程可以并发的访问Map，执行读操作的线程和执行写操作的线程可以并发的访问Map，并且一定数量的写线程可以并发的修改Map.")]),a._v(" "),n("p",[a._v('ConcurrentHashMap与其他并发容器一起增强了同步容器:迭代器不会抛出ConcurrentModificationException,因此迭代过程无需加锁.\n其迭代器具有"弱一致性",而并非"及时失败".可以容忍并发的修改,当创建迭代器时会遍历已有的元素,并可以(但不保证)在迭代器被构造后将修改操作反映给容器.')]),a._v(" "),n("p",[a._v("只有当需要加锁Map以进行独占访问时,才应该放弃使用ConcurrentHashMap.")]),a._v(" "),n("h2",{attrs:{id:"_2-2-额外的原子map操作"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-额外的原子map操作"}},[a._v("#")]),a._v(" 2.2 额外的原子Map操作")]),a._v(" "),n("p",[a._v('由于ConcurrentHashMap不能被加锁来执行独占访问,因此 无法使用客户端加锁来创建新的原子操作.\n一些常见的复合操作,eg."若没有则添加","若相等则移除"等,都已经实现为原子操作并且在ConcurrentMap接口中声明,如下面代码所示.')]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("public interface ConcurrentMap<K, V> extends Map<K, V> {\n     //仅当K没有相应的映射值时才插入\n\t V putIfAbsent(K key, V value);\n\t \n     //仅当K被映射到V时才移除\n     boolean remove(Object key, Object value);\n     \n\t //仅当K被映射到oldValue时才替换为newValue\n\t boolean replace(K key, V oldValue, V newValue);\n\t \n\t //仅当K被映射到某个值时才被替换为newValue\n\t  V replace(K key, V value);\n}\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br")])])])}),[],!1,null,null,null);e.default=s.exports}}]);