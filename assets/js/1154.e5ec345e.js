(window.webpackJsonp=window.webpackJsonp||[]).push([[1154],{1549:function(t,s,e){"use strict";e.r(s);var a=e(13),r=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("很多语言都内置了RPC技术。\nJava RMI\n.NET Remoting\n远古时期，就有很多尝试：")]),t._v(" "),e("ul",[e("li",[t._v("Corba（Common ObjectRequest Broker Architecture）公共对象请求代理体系结构，OMG组织在1991年提出的公用对象请求代理程序结构的技术规范。底层结构是基于面向对象模型的，由OMG接口描述语言(OMG Interface Definition Language，OMG IDL)、对象请求代理(Objec tRequest Broker，ORB)和IIOP标准协议（Internet Inter ORB Protocol，也称网络ORB交换协议）3个关键模块组成。")]),t._v(" "),e("li",[t._v("COM（Component Object Model，组件对象模型）是微软公司于1993年提出的一种组件技术，它是一种平台无关、语言中立、位置透明、支持网络的中间件技术。很多老一辈程序员心目中的神书《COM本质论》。")])]),t._v(" "),e("h1",{attrs:{id:"_1-从使用者考虑"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-从使用者考虑"}},[t._v("#")]),t._v(" 1 从使用者考虑")]),t._v(" "),e("p",[t._v("定义过程接口\n"),e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191114132816733.png",alt:""}})]),t._v(" "),e("p",[t._v("客户端使用生成的stub代理对象\n"),e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191114132906197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70",alt:""}})]),t._v(" "),e("h1",{attrs:{id:"_2-客户端的设计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-客户端的设计"}},[t._v("#")]),t._v(" 2 客户端的设计")]),t._v(" "),e("p",[t._v("客户端生成过程接口的代理对象。")]),t._v(" "),e("p",[t._v("客户端代理工厂，用JDK动态代理（或者 AOP 实现）即可生成接口的代理对象。\n"),e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191114132958985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70",alt:""}})]),t._v(" "),e("ul",[e("li",[e("p",[t._v("ClientStubInvocationHandler\n"),e("img",{attrs:{src:"https://img-blog.csdnimg.cn/2019111413331941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70",alt:""}})])]),t._v(" "),e("li",[e("p",[t._v("消息协议是固定不变的吗?它与什么有关?\n看框架对协议的支持广度，如果支持多种协议，就是会灵活变化的，它与具体的服务相关，\nA服务提供者可能选用的是协议1，B服务提供者可能选用协议2。")])]),t._v(" "),e("li",[e("p",[t._v("某服务是用的什么消息协议这个信息从哪来?\n从获取的服务信息中来，因此需要一个服务信息发现者。")])])]),t._v(" "),e("p",[e("code",[t._v("把发现者设计出来, 要求:可灵活支持多种发现机制")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191115003249371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70",alt:""}}),t._v(" "),e("img",{attrs:{src:"https://img-blog.csdnimg.cn/2019111500530155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70",alt:""}})]),t._v(" "),e("ul",[e("li",[t._v("想要做到可以支持多种协议，类该如何设计?面向接口、策略模式、组合\n"),e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191115005522357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70",alt:""}})])]),t._v(" "),e("p",[t._v("问题:\n➢ marshalling和unmarshalling方法该定义怎样的参数与返回值?\n➢ 编组、解组的操作对象是请求、响应，请求、响应的内容是不同的。编组、解组两个方法是否满足?")]),t._v(" "),e("h2",{attrs:{id:"设计客户端协议层"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计客户端协议层"}},[t._v("#")]),t._v(" 设计客户端协议层")]),t._v(" "),e("p",[t._v("定义框架标准的请求, 响应类")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191115005858703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70",alt:""}})]),t._v(" "),e("ol",{attrs:{start:"7"}},[e("li",[t._v("将协议层扩展为四个"),e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191115010053143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70",alt:""}}),t._v("\n消息协议独立为一层(客户端、服务端均需要)")])]),t._v(" "),e("p",[t._v("网络层\n发送请求,获得响应"),e("br"),t._v("\n要发起网络请求,则须知道服务地址\n"),e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191115123239178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70",alt:""}})]),t._v(" "),e("ul",[e("li",[t._v("客户端完整类图\n"),e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191115123823652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70",alt:""}})])]),t._v(" "),e("p",[t._v("在实现过程中，协议层涉及一个重要概念")]),t._v(" "),e("ul",[e("li",[t._v("参数序列化、反序列")])]),t._v(" "),e("h1",{attrs:{id:"_3-设计服务端"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-设计服务端"}},[t._v("#")]),t._v(" 3 设计服务端")]),t._v(" "),e("h2",{attrs:{id:"_3-1-rpcserver"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-rpcserver"}},[t._v("#")]),t._v(" 3.1 RPCServer")]),t._v(" "),e("p",[t._v("客户端请求过来了，服务端首先需要通过RPCServer接收请求。\n"),e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191115235722470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70",alt:""}})]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191115235736165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70",alt:""}})]),t._v(" "),e("ul",[e("li",[t._v("RPCServer\n"),e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191116001129440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70",alt:""}})])]),t._v(" "),e("h2",{attrs:{id:"_3-2-思考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-思考"}},[t._v("#")]),t._v(" 3.2 思考")]),t._v(" "),e("p",[t._v("RPCServer接收到客户端请求后，还需要做哪些工作?\n"),e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191115235943756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70",alt:""}})]),t._v(" "),e("p",[t._v("网络层在RPCServer中提供多线程来处理请求，消息协议层复用客户端设计的。\n(设计一个"),e("code",[t._v("请求处理类")]),t._v("，来完成网络层以上的事情。)")]),t._v(" "),e("h2",{attrs:{id:"_3-3-requesthandler"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-requesthandler"}},[t._v("#")]),t._v(" 3.3 RequestHandler")]),t._v(" "),e("p",[t._v("RPCServer接收到请求后，将请求交给RequestHandler来处理\nRequestHandler调用协议层来解组请求消息为Request对象，然后调用过程!\n"),e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191116000813865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70",alt:""}})]),t._v(" "),e("h3",{attrs:{id:"人性的拷问"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#人性的拷问"}},[t._v("#")]),t._v(" 人性的拷问")]),t._v(" "),e("p",[t._v("➢ RequestHandler如何得到过程对象?\n➢ Request中有什么?\n➢ 服务名、方法名、参数类型、参数值\n➢ 是否需要一个过程注册模块?")]),t._v(" "),e("p",[t._v("看看之后的设计\n"),e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191116002808402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70",alt:""}})]),t._v(" "),e("p",[t._v("➢ "),e("code",[t._v("过程注册模块")]),t._v(":让用户将他们的过程注册到RPC框架\n➢ "),e("code",[t._v("过程暴露模块")]),t._v(":想对外发布(暴露)服务注册、暴露可以由同一个类实现")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191116003017951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70",alt:""}})]),t._v(" "),e("ol",[e("li",[t._v("RPCServer 中实现网络层: Netty, 使用RequestHandler")]),t._v(" "),e("li",[t._v("ServiceRegister 模块实现服务注册、发布。")]),t._v(" "),e("li",[t._v("RequestHandler 中实现消息协议处理、过程调用")])]),t._v(" "),e("h2",{attrs:{id:"代码实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码实现"}},[t._v("#")]),t._v(" 代码实现")]),t._v(" "),e("ul",[e("li",[t._v("首先,用户需要设置你的端口和协议哦\n"),e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191116003532999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70",alt:""}})])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191116003822920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70",alt:""}})]),t._v(" "),e("blockquote",[e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/Wasabi1234/rpc-framework",target:"_blank",rel:"noopener noreferrer"}},[t._v("相关源码"),e("OutboundLink")],1)])])])])}),[],!1,null,null,null);s.default=r.exports}}]);