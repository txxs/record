(window.webpackJsonp=window.webpackJsonp||[]).push([[1305],{1699:function(i,s,t){"use strict";t.r(s);var l=t(13),e=Object(l.a)({},(function(){var i=this,s=i.$createElement,t=i._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":i.$parent.slotKey}},[t("h1",{attrs:{id:"table-of-contents"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#table-of-contents"}},[i._v("#")]),i._v(" Table of Contents")]),i._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[i._v("  * [quicklist概述](#quicklist概述)\n  * [quicklist的数据结构定义](#quicklist的数据结构定义)\n  * [quicklist的创建](#quicklist的创建)\n  * [quicklist的push操作](#quicklist的push操作)\n  * [quicklist的其它操作](#quicklist的其它操作)\n")])])]),t("p",[i._v("本文转自互联网")]),i._v(" "),t("p",[i._v("本文将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看")]),i._v(" "),t("blockquote",[t("p",[i._v("https://github.com/h2pl/Java-Tutorial")])]),i._v(" "),t("p",[i._v("喜欢的话麻烦点下Star哈")]),i._v(" "),t("p",[i._v("本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。")]),i._v(" "),t("p",[i._v("该系列博文会告诉你如何从入门到进阶，Redis基本的使用方法，Redis的基本数据结构，以及一些进阶的使用方法，同时也需要进一步了解Redis的底层数据结构，再接着，还会带来Redis主从复制、集群、分布式锁等方面的相关内容，以及作为缓存的一些使用方法和注意事项，以便让你更完整地了解整个Redis相关的技术体系，形成自己的知识框架。")]),i._v(" "),t("p",[i._v("如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。")]),i._v(" "),t("p",[i._v("本文是《"),t("a",{attrs:{href:"http://zhangtielei.com/posts/blog-redis-dict.html",target:"_blank",rel:"noopener noreferrer"}},[i._v("Redis内部数据结构详解"),t("OutboundLink")],1),i._v("》系列的第五篇。在本文中，我们介绍一个Redis内部数据结构——quicklist。Redis对外暴露的list数据类型，它底层实现所依赖的内部数据结构就是quicklist。")]),i._v(" "),t("p",[i._v("我们在讨论中还会涉及到两个Redis配置（在redis.conf中的ADVANCED CONFIG部分）：")]),i._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[i._v("list-max-ziplist-size -2\nlist-compress-depth 0\n\n")])]),i._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[i._v("1")]),t("br"),t("span",{staticClass:"line-number"},[i._v("2")]),t("br"),t("span",{staticClass:"line-number"},[i._v("3")]),t("br")])]),t("p",[i._v("我们在讨论中会详细解释这两个配置的含义。")]),i._v(" "),t("p",[i._v("注：本文讨论的quicklist实现基于Redis源码的3.2分支。")]),i._v(" "),t("h4",{attrs:{id:"quicklist概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#quicklist概述"}},[i._v("#")]),i._v(" quicklist概述")]),i._v(" "),t("p",[i._v("Redis对外暴露的上层list数据类型，经常被用作队列使用。比如它支持的如下一些操作：")]),i._v(" "),t("ul",[t("li",[t("code",[i._v("lpush")]),i._v(": 在左侧（即列表头部）插入数据。")]),i._v(" "),t("li",[t("code",[i._v("rpop")]),i._v(": 在右侧（即列表尾部）删除数据。")]),i._v(" "),t("li",[t("code",[i._v("rpush")]),i._v(": 在右侧（即列表尾部）插入数据。")]),i._v(" "),t("li",[t("code",[i._v("lpop")]),i._v(": 在左侧（即列表头部）删除数据。")])]),i._v(" "),t("p",[i._v("这些操作都是O(1)时间复杂度的。")]),i._v(" "),t("p",[i._v("当然，list也支持在任意中间位置的存取操作，比如"),t("code",[i._v("lindex")]),i._v("和"),t("code",[i._v("linsert")]),i._v("，但它们都需要对list进行遍历，所以时间复杂度较高，为O(N)。")]),i._v(" "),t("p",[i._v("概况起来，list具有这样的一些特点：它是一个能维持数据项先后顺序的列表（各个数据项的先后顺序由插入位置决定），便于在表的两端追加和删除数据，而对于中间位置的存取具有O(N)的时间复杂度。这不正是一个双向链表所具有的特点吗？")]),i._v(" "),t("p",[i._v("list的内部实现quicklist正是一个双向链表。在quicklist.c的文件头部注释中，是这样描述quicklist的：")]),i._v(" "),t("blockquote",[t("p",[i._v("A doubly linked list of ziplists")])]),i._v(" "),t("p",[i._v("它确实是一个双向链表，而且是一个ziplist的双向链表。")]),i._v(" "),t("p",[i._v("这是什么意思呢？")]),i._v(" "),t("p",[i._v("我们知道，双向链表是由多个节点（Node）组成的。这个描述的意思是：quicklist的每个节点都是一个ziplist。ziplist我们已经在"),t("a",{attrs:{href:"http://zhangtielei.com/posts/blog-redis-ziplist.html",target:"_blank",rel:"noopener noreferrer"}},[i._v("上一篇"),t("OutboundLink")],1),i._v("介绍过。")]),i._v(" "),t("p",[i._v("ziplist本身也是一个能维持数据项先后顺序的列表（按插入位置），而且是一个内存紧缩的列表（各个数据项在内存上前后相邻）。比如，一个包含3个节点的quicklist，如果每个节点的ziplist又包含4个数据项，那么对外表现上，这个list就总共包含12个数据项。")]),i._v(" "),t("p",[i._v("quicklist的结构为什么这样设计呢？总结起来，大概又是一个空间和时间的折中：")]),i._v(" "),t("ul",[t("li",[i._v("双向链表便于在表的两端进行push和pop操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。")]),i._v(" "),t("li",[i._v("ziplist由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的realloc。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。")])]),i._v(" "),t("p",[i._v("于是，结合了双向链表和ziplist的优点，quicklist就应运而生了。")]),i._v(" "),t("p",[i._v("不过，这也带来了一个新问题：到底一个quicklist节点包含多长的ziplist合适呢？比如，同样是存储12个数据项，既可以是一个quicklist包含3个节点，而每个节点的ziplist又包含4个数据项，也可以是一个quicklist包含6个节点，而每个节点的ziplist又包含2个数据项。")]),i._v(" "),t("p",[i._v("这又是一个需要找平衡点的难题。我们只从存储效率上分析一下：")]),i._v(" "),t("ul",[t("li",[i._v("每个quicklist节点上的ziplist越短，则内存碎片越多。内存碎片多了，有可能在内存中产生很多无法被利用的小碎片，从而降低存储效率。这种情况的极端是每个quicklist节点上的ziplist只包含一个数据项，这就蜕化成一个普通的双向链表了。")]),i._v(" "),t("li",[i._v("每个quicklist节点上的ziplist越长，则为ziplist分配大块连续内存空间的难度就越大。有可能出现内存里有很多小块的空闲空间（它们加起来很多），但却找不到一块足够大的空闲空间分配给ziplist的情况。这同样会降低存储效率。这种情况的极端是整个quicklist只有一个节点，所有的数据项都分配在这仅有的一个节点的ziplist里面。这其实蜕化成一个ziplist了。")])]),i._v(" "),t("p",[i._v("可见，一个quicklist节点上的ziplist要保持一个合理的长度。那到底多长合理呢？这可能取决于具体应用场景。实际上，Redis提供了一个配置参数"),t("code",[i._v("list-max-ziplist-size")]),i._v("，就是为了让使用者可以来根据自己的情况进行调整。")]),i._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[i._v("list-max-ziplist-size -2\n\n")])]),i._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[i._v("1")]),t("br"),t("span",{staticClass:"line-number"},[i._v("2")]),t("br")])]),t("p",[i._v("我们来详细解释一下这个参数的含义。它可以取正值，也可以取负值。")]),i._v(" "),t("p",[i._v("当取正值的时候，表示按照数据项个数来限定每个quicklist节点上的ziplist长度。比如，当这个参数配置成5的时候，表示每个quicklist节点的ziplist最多包含5个数据项。")]),i._v(" "),t("p",[i._v("当取负值的时候，表示按照占用字节数来限定每个quicklist节点上的ziplist长度。这时，它只能取-1到-5这五个值，每个值含义如下：")]),i._v(" "),t("ul",[t("li",[i._v("-5: 每个quicklist节点上的ziplist大小不能超过64 Kb。（注：1kb => 1024 bytes）")]),i._v(" "),t("li",[i._v("-4: 每个quicklist节点上的ziplist大小不能超过32 Kb。")]),i._v(" "),t("li",[i._v("-3: 每个quicklist节点上的ziplist大小不能超过16 Kb。")]),i._v(" "),t("li",[i._v("-2: 每个quicklist节点上的ziplist大小不能超过8 Kb。（-2是Redis给出的默认值）")]),i._v(" "),t("li",[i._v("-1: 每个quicklist节点上的ziplist大小不能超过4 Kb。")])]),i._v(" "),t("p",[i._v("另外，list的设计目标是能够用来存储很长的数据列表的。比如，Redis官网给出的这个教程："),t("a",{attrs:{href:"http://redis.io/topics/twitter-clone",target:"_blank",rel:"noopener noreferrer"}},[i._v("Writing a simple Twitter clone with PHP and Redis"),t("OutboundLink")],1),i._v("，就是使用list来存储类似Twitter的timeline数据。")]),i._v(" "),t("p",[i._v("当列表很长的时候，最容易被访问的很可能是两端的数据，中间的数据被访问的频率比较低（访问起来性能也很低）。如果应用场景符合这个特点，那么list还提供了一个选项，能够把中间的数据节点进行压缩，从而进一步节省内存空间。Redis的配置参数"),t("code",[i._v("list-compress-depth")]),i._v("就是用来完成这个设置的。")]),i._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[i._v("list-compress-depth 0\n\n")])]),i._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[i._v("1")]),t("br"),t("span",{staticClass:"line-number"},[i._v("2")]),t("br")])]),t("p",[i._v("这个参数表示一个quicklist两端不被压缩的节点个数。注：这里的节点个数是指quicklist双向链表的节点个数，而不是指ziplist里面的数据项个数。实际上，一个quicklist节点上的ziplist，如果被压缩，就是整体被压缩的。")]),i._v(" "),t("p",[i._v("参数"),t("code",[i._v("list-compress-depth")]),i._v("的取值含义如下：")]),i._v(" "),t("ul",[t("li",[i._v("0: 是个特殊值，表示都不压缩。这是Redis的默认值。")]),i._v(" "),t("li",[i._v("1: 表示quicklist两端各有1个节点不压缩，中间的节点压缩。")]),i._v(" "),t("li",[i._v("2: 表示quicklist两端各有2个节点不压缩，中间的节点压缩。")]),i._v(" "),t("li",[i._v("3: 表示quicklist两端各有3个节点不压缩，中间的节点压缩。")]),i._v(" "),t("li",[i._v("依此类推…")])]),i._v(" "),t("p",[i._v("由于0是个特殊值，很容易看出quicklist的头节点和尾节点总是不被压缩的，以便于在表的两端进行快速存取。")]),i._v(" "),t("p",[i._v("Redis对于quicklist内部节点的压缩算法，采用的"),t("a",{attrs:{href:"http://oldhome.schmorp.de/marc/liblzf.html",target:"_blank",rel:"noopener noreferrer"}},[i._v("LZF"),t("OutboundLink")],1),i._v("——一种无损压缩算法。")]),i._v(" "),t("h4",{attrs:{id:"quicklist的数据结构定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#quicklist的数据结构定义"}},[i._v("#")]),i._v(" quicklist的数据结构定义")]),i._v(" "),t("p",[i._v("quicklist相关的数据结构定义可以在quicklist.h中找到：")]),i._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[i._v("typedef struct quicklistNode {\n    struct quicklistNode *prev;\n    struct quicklistNode *next;\n    unsigned char *zl;\n    unsigned int sz;             /* ziplist size in bytes */\n    unsigned int count : 16;     /* count of items in ziplist */\n    unsigned int encoding : 2;   /* RAW==1 or LZF==2 */\n    unsigned int container : 2;  /* NONE==1 or ZIPLIST==2 */\n    unsigned int recompress : 1; /* was this node previous compressed? */\n    unsigned int attempted_compress : 1; /* node can't compress; too small */\n    unsigned int extra : 10; /* more bits to steal for future usage */\n} quicklistNode;\n\ntypedef struct quicklistLZF {\n    unsigned int sz; /* LZF size in bytes*/\n    char compressed[];\n} quicklistLZF;\n\ntypedef struct quicklist {\n    quicklistNode *head;\n    quicklistNode *tail;\n    unsigned long count;        /* total count of all entries in all ziplists */\n    unsigned int len;           /* number of quicklistNodes */\n    int fill : 16;              /* fill factor for individual nodes */\n    unsigned int compress : 16; /* depth of end nodes not to compress;0=off */\n} quicklist;\n\n")])]),i._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[i._v("1")]),t("br"),t("span",{staticClass:"line-number"},[i._v("2")]),t("br"),t("span",{staticClass:"line-number"},[i._v("3")]),t("br"),t("span",{staticClass:"line-number"},[i._v("4")]),t("br"),t("span",{staticClass:"line-number"},[i._v("5")]),t("br"),t("span",{staticClass:"line-number"},[i._v("6")]),t("br"),t("span",{staticClass:"line-number"},[i._v("7")]),t("br"),t("span",{staticClass:"line-number"},[i._v("8")]),t("br"),t("span",{staticClass:"line-number"},[i._v("9")]),t("br"),t("span",{staticClass:"line-number"},[i._v("10")]),t("br"),t("span",{staticClass:"line-number"},[i._v("11")]),t("br"),t("span",{staticClass:"line-number"},[i._v("12")]),t("br"),t("span",{staticClass:"line-number"},[i._v("13")]),t("br"),t("span",{staticClass:"line-number"},[i._v("14")]),t("br"),t("span",{staticClass:"line-number"},[i._v("15")]),t("br"),t("span",{staticClass:"line-number"},[i._v("16")]),t("br"),t("span",{staticClass:"line-number"},[i._v("17")]),t("br"),t("span",{staticClass:"line-number"},[i._v("18")]),t("br"),t("span",{staticClass:"line-number"},[i._v("19")]),t("br"),t("span",{staticClass:"line-number"},[i._v("20")]),t("br"),t("span",{staticClass:"line-number"},[i._v("21")]),t("br"),t("span",{staticClass:"line-number"},[i._v("22")]),t("br"),t("span",{staticClass:"line-number"},[i._v("23")]),t("br"),t("span",{staticClass:"line-number"},[i._v("24")]),t("br"),t("span",{staticClass:"line-number"},[i._v("25")]),t("br"),t("span",{staticClass:"line-number"},[i._v("26")]),t("br"),t("span",{staticClass:"line-number"},[i._v("27")]),t("br")])]),t("p",[i._v("quicklistNode结构代表quicklist的一个节点，其中各个字段的含义如下：")]),i._v(" "),t("ul",[t("li",[i._v("prev: 指向链表前一个节点的指针。")]),i._v(" "),t("li",[i._v("next: 指向链表后一个节点的指针。")]),i._v(" "),t("li",[i._v("zl: 数据指针。如果当前节点的数据没有压缩，那么它指向一个ziplist结构；否则，它指向一个quicklistLZF结构。")]),i._v(" "),t("li",[i._v("sz: 表示zl指向的ziplist的总大小（包括"),t("code",[i._v("zlbytes")]),i._v(", "),t("code",[i._v("zltail")]),i._v(", "),t("code",[i._v("zllen")]),i._v(", "),t("code",[i._v("zlend")]),i._v("和各个数据项）。需要注意的是：如果ziplist被压缩了，那么这个sz的值仍然是压缩前的ziplist大小。")]),i._v(" "),t("li",[i._v("count: 表示ziplist里面包含的数据项个数。这个字段只有16bit。稍后我们会一起计算一下这16bit是否够用。")]),i._v(" "),t("li",[i._v("encoding: 表示ziplist是否压缩了（以及用了哪个压缩算法）。目前只有两种取值：2表示被压缩了（而且用的是"),t("a",{attrs:{href:"http://oldhome.schmorp.de/marc/liblzf.html",target:"_blank",rel:"noopener noreferrer"}},[i._v("LZF"),t("OutboundLink")],1),i._v("压缩算法），1表示没有压缩。")]),i._v(" "),t("li",[i._v("container: 是一个预留字段。本来设计是用来表明一个quicklist节点下面是直接存数据，还是使用ziplist存数据，或者用其它的结构来存数据（用作一个数据容器，所以叫container）。但是，在目前的实现中，这个值是一个固定的值2，表示使用ziplist作为数据容器。")]),i._v(" "),t("li",[i._v("recompress: 当我们使用类似lindex这样的命令查看了某一项本来压缩的数据时，需要把数据暂时解压，这时就设置recompress=1做一个标记，等有机会再把数据重新压缩。")]),i._v(" "),t("li",[i._v("attempted_compress: 这个值只对Redis的自动化测试程序有用。我们不用管它。")]),i._v(" "),t("li",[i._v("extra: 其它扩展字段。目前Redis的实现里也没用上。")])]),i._v(" "),t("p",[i._v("quicklistLZF结构表示一个被压缩过的ziplist。其中：")]),i._v(" "),t("ul",[t("li",[i._v("sz: 表示压缩后的ziplist大小。")]),i._v(" "),t("li",[i._v("compressed: 是个柔性数组（"),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Flexible_array_member",target:"_blank",rel:"noopener noreferrer"}},[i._v("flexible array member"),t("OutboundLink")],1),i._v("），存放压缩后的ziplist字节数组。")])]),i._v(" "),t("p",[i._v("真正表示quicklist的数据结构是同名的quicklist这个struct：")]),i._v(" "),t("ul",[t("li",[i._v("head: 指向头节点（左侧第一个节点）的指针。")]),i._v(" "),t("li",[i._v("tail: 指向尾节点（右侧第一个节点）的指针。")]),i._v(" "),t("li",[i._v("count: 所有ziplist数据项的个数总和。")]),i._v(" "),t("li",[i._v("len: quicklist节点的个数。")]),i._v(" "),t("li",[i._v("fill: 16bit，ziplist大小设置，存放"),t("code",[i._v("list-max-ziplist-size")]),i._v("参数的值。")]),i._v(" "),t("li",[i._v("compress: 16bit，节点压缩深度设置，存放"),t("code",[i._v("list-compress-depth")]),i._v("参数的值。")])]),i._v(" "),t("p",[t("a",{attrs:{href:"http://zhangtielei.com/assets/photos_redis/redis_quicklist_structure.png",target:"_blank",rel:"noopener noreferrer"}},[t("img",{attrs:{src:"http://zhangtielei.com/assets/photos_redis/redis_quicklist_structure.png",alt:"Redis quicklist 结构图"}}),t("OutboundLink")],1)]),i._v(" "),t("p",[i._v("上图是一个quicklist的结构图举例。图中例子对应的ziplist大小配置和节点压缩深度配置，如下：")]),i._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[i._v("list-max-ziplist-size 3\nlist-compress-depth 2\n\n")])]),i._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[i._v("1")]),t("br"),t("span",{staticClass:"line-number"},[i._v("2")]),t("br"),t("span",{staticClass:"line-number"},[i._v("3")]),t("br")])]),t("p",[i._v("这个例子中我们需要注意的几点是：")]),i._v(" "),t("ul",[t("li",[i._v("两端各有2个橙黄色的节点，是没有被压缩的。它们的数据指针zl指向真正的ziplist。中间的其它节点是被压缩过的，它们的数据指针zl指向被压缩后的ziplist结构，即一个quicklistLZF结构。")]),i._v(" "),t("li",[i._v("左侧头节点上的ziplist里有2项数据，右侧尾节点上的ziplist里有1项数据，中间其它节点上的ziplist里都有3项数据（包括压缩的节点内部）。这表示在表的两端执行过多次"),t("code",[i._v("push")]),i._v("和"),t("code",[i._v("pop")]),i._v("操作后的一个状态。")])]),i._v(" "),t("p",[i._v("现在我们来大概计算一下quicklistNode结构中的count字段这16bit是否够用。")]),i._v(" "),t("p",[i._v("我们已经知道，ziplist大小受到"),t("code",[i._v("list-max-ziplist-size")]),i._v("参数的限制。按照正值和负值有两种情况：")]),i._v(" "),t("ul",[t("li",[i._v("当这个参数取正值的时候，就是恰好表示一个quicklistNode结构中zl所指向的ziplist所包含的数据项的最大值。"),t("code",[i._v("list-max-ziplist-size")]),i._v("参数是由quicklist结构的fill字段来存储的，而fill字段是16bit，所以它所能表达的值能够用16bit来表示。")]),i._v(" "),t("li",[i._v("当这个参数取负值的时候，能够表示的ziplist最大长度是64 Kb。而ziplist中每一个数据项，最少需要2个字节来表示：1个字节的"),t("code",[i._v("prevrawlen")]),i._v("，1个字节的"),t("code",[i._v("data")]),i._v("（"),t("code",[i._v("len")]),i._v("字段和"),t("code",[i._v("data")]),i._v("合二为一；详见"),t("a",{attrs:{href:"http://zhangtielei.com/posts/blog-redis-ziplist.html",target:"_blank",rel:"noopener noreferrer"}},[i._v("上一篇"),t("OutboundLink")],1),i._v("）。所以，ziplist中数据项的个数不会超过32 K，用16bit来表达足够了。")])]),i._v(" "),t("p",[i._v("实际上，在目前的quicklist的实现中，ziplist的大小还会受到另外的限制，根本不会达到这里所分析的最大值。")]),i._v(" "),t("p",[i._v("下面进入代码分析阶段。")]),i._v(" "),t("h4",{attrs:{id:"quicklist的创建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#quicklist的创建"}},[i._v("#")]),i._v(" quicklist的创建")]),i._v(" "),t("p",[i._v("当我们使用"),t("code",[i._v("lpush")]),i._v("或"),t("code",[i._v("rpush")]),i._v("命令第一次向一个不存在的list里面插入数据的时候，Redis会首先调用"),t("code",[i._v("quicklistCreate")]),i._v("接口创建一个空的quicklist。")]),i._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[i._v("quicklist *quicklistCreate(void) {\n    struct quicklist *quicklist;\n\n    quicklist = zmalloc(sizeof(*quicklist));\n    quicklist->head = quicklist->tail = NULL;\n    quicklist->len = 0;\n    quicklist->count = 0;\n    quicklist->compress = 0;\n    quicklist->fill = -2;\n    return quicklist;\n}\n\n")])]),i._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[i._v("1")]),t("br"),t("span",{staticClass:"line-number"},[i._v("2")]),t("br"),t("span",{staticClass:"line-number"},[i._v("3")]),t("br"),t("span",{staticClass:"line-number"},[i._v("4")]),t("br"),t("span",{staticClass:"line-number"},[i._v("5")]),t("br"),t("span",{staticClass:"line-number"},[i._v("6")]),t("br"),t("span",{staticClass:"line-number"},[i._v("7")]),t("br"),t("span",{staticClass:"line-number"},[i._v("8")]),t("br"),t("span",{staticClass:"line-number"},[i._v("9")]),t("br"),t("span",{staticClass:"line-number"},[i._v("10")]),t("br"),t("span",{staticClass:"line-number"},[i._v("11")]),t("br"),t("span",{staticClass:"line-number"},[i._v("12")]),t("br")])]),t("p",[i._v("在很多介绍数据结构的书上，实现双向链表的时候经常会多增加一个空余的头节点，主要是为了插入和删除操作的方便。从上面"),t("code",[i._v("quicklistCreate")]),i._v("的代码可以看出，quicklist是一个不包含空余头节点的双向链表（"),t("code",[i._v("head")]),i._v("和"),t("code",[i._v("tail")]),i._v("都初始化为NULL）。")]),i._v(" "),t("h4",{attrs:{id:"quicklist的push操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#quicklist的push操作"}},[i._v("#")]),i._v(" quicklist的push操作")]),i._v(" "),t("p",[i._v("quicklist的push操作是调用"),t("code",[i._v("quicklistPush")]),i._v("来实现的。")]),i._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[i._v("void quicklistPush(quicklist *quicklist, void *value, const size_t sz,\n                   int where) {\n    if (where == QUICKLIST_HEAD) {\n        quicklistPushHead(quicklist, value, sz);\n    } else if (where == QUICKLIST_TAIL) {\n        quicklistPushTail(quicklist, value, sz);\n    }\n}\n\n/* Add new entry to head node of quicklist.\n *\n * Returns 0 if used existing head.\n * Returns 1 if new head created. */\nint quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {\n    quicklistNode *orig_head = quicklist->head;\n    if (likely(\n            _quicklistNodeAllowInsert(quicklist->head, quicklist->fill, sz))) {\n        quicklist->head->zl =\n            ziplistPush(quicklist->head->zl, value, sz, ZIPLIST_HEAD);\n        quicklistNodeUpdateSz(quicklist->head);\n    } else {\n        quicklistNode *node = quicklistCreateNode();\n        node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);\n\n        quicklistNodeUpdateSz(node);\n        _quicklistInsertNodeBefore(quicklist, quicklist->head, node);\n    }\n    quicklist->count++;\n    quicklist->head->count++;\n    return (orig_head != quicklist->head);\n}\n\n/* Add new entry to tail node of quicklist.\n *\n * Returns 0 if used existing tail.\n * Returns 1 if new tail created. */\nint quicklistPushTail(quicklist *quicklist, void *value, size_t sz) {\n    quicklistNode *orig_tail = quicklist->tail;\n    if (likely(\n            _quicklistNodeAllowInsert(quicklist->tail, quicklist->fill, sz))) {\n        quicklist->tail->zl =\n            ziplistPush(quicklist->tail->zl, value, sz, ZIPLIST_TAIL);\n        quicklistNodeUpdateSz(quicklist->tail);\n    } else {\n        quicklistNode *node = quicklistCreateNode();\n        node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);\n\n        quicklistNodeUpdateSz(node);\n        _quicklistInsertNodeAfter(quicklist, quicklist->tail, node);\n    }\n    quicklist->count++;\n    quicklist->tail->count++;\n    return (orig_tail != quicklist->tail);\n}\n\n")])]),i._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[i._v("1")]),t("br"),t("span",{staticClass:"line-number"},[i._v("2")]),t("br"),t("span",{staticClass:"line-number"},[i._v("3")]),t("br"),t("span",{staticClass:"line-number"},[i._v("4")]),t("br"),t("span",{staticClass:"line-number"},[i._v("5")]),t("br"),t("span",{staticClass:"line-number"},[i._v("6")]),t("br"),t("span",{staticClass:"line-number"},[i._v("7")]),t("br"),t("span",{staticClass:"line-number"},[i._v("8")]),t("br"),t("span",{staticClass:"line-number"},[i._v("9")]),t("br"),t("span",{staticClass:"line-number"},[i._v("10")]),t("br"),t("span",{staticClass:"line-number"},[i._v("11")]),t("br"),t("span",{staticClass:"line-number"},[i._v("12")]),t("br"),t("span",{staticClass:"line-number"},[i._v("13")]),t("br"),t("span",{staticClass:"line-number"},[i._v("14")]),t("br"),t("span",{staticClass:"line-number"},[i._v("15")]),t("br"),t("span",{staticClass:"line-number"},[i._v("16")]),t("br"),t("span",{staticClass:"line-number"},[i._v("17")]),t("br"),t("span",{staticClass:"line-number"},[i._v("18")]),t("br"),t("span",{staticClass:"line-number"},[i._v("19")]),t("br"),t("span",{staticClass:"line-number"},[i._v("20")]),t("br"),t("span",{staticClass:"line-number"},[i._v("21")]),t("br"),t("span",{staticClass:"line-number"},[i._v("22")]),t("br"),t("span",{staticClass:"line-number"},[i._v("23")]),t("br"),t("span",{staticClass:"line-number"},[i._v("24")]),t("br"),t("span",{staticClass:"line-number"},[i._v("25")]),t("br"),t("span",{staticClass:"line-number"},[i._v("26")]),t("br"),t("span",{staticClass:"line-number"},[i._v("27")]),t("br"),t("span",{staticClass:"line-number"},[i._v("28")]),t("br"),t("span",{staticClass:"line-number"},[i._v("29")]),t("br"),t("span",{staticClass:"line-number"},[i._v("30")]),t("br"),t("span",{staticClass:"line-number"},[i._v("31")]),t("br"),t("span",{staticClass:"line-number"},[i._v("32")]),t("br"),t("span",{staticClass:"line-number"},[i._v("33")]),t("br"),t("span",{staticClass:"line-number"},[i._v("34")]),t("br"),t("span",{staticClass:"line-number"},[i._v("35")]),t("br"),t("span",{staticClass:"line-number"},[i._v("36")]),t("br"),t("span",{staticClass:"line-number"},[i._v("37")]),t("br"),t("span",{staticClass:"line-number"},[i._v("38")]),t("br"),t("span",{staticClass:"line-number"},[i._v("39")]),t("br"),t("span",{staticClass:"line-number"},[i._v("40")]),t("br"),t("span",{staticClass:"line-number"},[i._v("41")]),t("br"),t("span",{staticClass:"line-number"},[i._v("42")]),t("br"),t("span",{staticClass:"line-number"},[i._v("43")]),t("br"),t("span",{staticClass:"line-number"},[i._v("44")]),t("br"),t("span",{staticClass:"line-number"},[i._v("45")]),t("br"),t("span",{staticClass:"line-number"},[i._v("46")]),t("br"),t("span",{staticClass:"line-number"},[i._v("47")]),t("br"),t("span",{staticClass:"line-number"},[i._v("48")]),t("br"),t("span",{staticClass:"line-number"},[i._v("49")]),t("br"),t("span",{staticClass:"line-number"},[i._v("50")]),t("br"),t("span",{staticClass:"line-number"},[i._v("51")]),t("br"),t("span",{staticClass:"line-number"},[i._v("52")]),t("br"),t("span",{staticClass:"line-number"},[i._v("53")]),t("br"),t("span",{staticClass:"line-number"},[i._v("54")]),t("br"),t("span",{staticClass:"line-number"},[i._v("55")]),t("br")])]),t("p",[i._v("不管是在头部还是尾部插入数据，都包含两种情况：")]),i._v(" "),t("ul",[t("li",[i._v("如果头节点（或尾节点）上ziplist大小没有超过限制（即"),t("code",[i._v("_quicklistNodeAllowInsert")]),i._v("返回1），那么新数据被直接插入到ziplist中（调用"),t("code",[i._v("ziplistPush")]),i._v("）。")]),i._v(" "),t("li",[i._v("如果头节点（或尾节点）上ziplist太大了，那么新创建一个quicklistNode节点（对应地也会新创建一个ziplist），然后把这个新创建的节点插入到quicklist双向链表中（调用"),t("code",[i._v("_quicklistInsertNodeAfter")]),i._v("）。")])]),i._v(" "),t("p",[i._v("在"),t("code",[i._v("_quicklistInsertNodeAfter")]),i._v("的实现中，还会根据"),t("code",[i._v("list-compress-depth")]),i._v("的配置将里面的节点进行压缩。它的实现比较繁琐，我们这里就不展开讨论了。")]),i._v(" "),t("h4",{attrs:{id:"quicklist的其它操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#quicklist的其它操作"}},[i._v("#")]),i._v(" quicklist的其它操作")]),i._v(" "),t("p",[i._v("quicklist的操作较多，且实现细节都比较繁杂，这里就不一一分析源码了，我们简单介绍一些比较重要的操作。")]),i._v(" "),t("p",[i._v("quicklist的pop操作是调用"),t("code",[i._v("quicklistPopCustom")]),i._v("来实现的。"),t("code",[i._v("quicklistPopCustom")]),i._v("的实现过程基本上跟quicklistPush相反，先从头部或尾部节点的ziplist中把对应的数据项删除，如果在删除后ziplist为空了，那么对应的头部或尾部节点也要删除。删除后还可能涉及到里面节点的解压缩问题。")]),i._v(" "),t("p",[i._v("quicklist不仅实现了从头部或尾部插入，也实现了从任意指定的位置插入。"),t("code",[i._v("quicklistInsertAfter")]),i._v("和"),t("code",[i._v("quicklistInsertBefore")]),i._v("就是分别在指定位置后面和前面插入数据项。这种在任意指定位置插入数据的操作，情况比较复杂，有众多的逻辑分支。")]),i._v(" "),t("ul",[t("li",[i._v("当插入位置所在的ziplist大小没有超过限制时，直接插入到ziplist中就好了；")]),i._v(" "),t("li",[i._v("当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小没有超过限制，那么就转而插入到相邻的那个quicklist链表节点的ziplist中；")]),i._v(" "),t("li",[i._v("当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小也超过限制，这时需要新创建一个quicklist链表节点插入。")]),i._v(" "),t("li",[i._v("对于插入位置所在的ziplist大小超过了限制的其它情况（主要对应于在ziplist中间插入数据的情况），则需要把当前ziplist分裂为两个节点，然后再其中一个节点上插入数据。")])]),i._v(" "),t("p",[t("code",[i._v("quicklistSetOptions")]),i._v("用于设置ziplist大小配置参数（"),t("code",[i._v("list-max-ziplist-size")]),i._v("）和节点压缩深度配置参数（"),t("code",[i._v("list-compress-depth")]),i._v("）。代码比较简单，就是将相应的值分别设置给quicklist结构的fill字段和compress字段。")]),i._v(" "),t("hr"),i._v(" "),t("p",[i._v("下一篇我们将介绍skiplist和它所支撑的Redis数据类型sorted set，敬请期待。")]),i._v(" "),t("p",[t("strong",[i._v("原创文章，转载请注明出处，并包含下面的二维码！否则拒绝转载！")]),i._v(" "),t("strong",[i._v("本文链接：")]),t("a",{attrs:{href:"http://zhangtielei.com/posts/blog-redis-quicklist.html",target:"_blank",rel:"noopener noreferrer"}},[i._v("http://zhangtielei.com/posts/blog-redis-quicklist.html"),t("OutboundLink")],1)]),i._v(" "),t("p",[t("img",{attrs:{src:"http://zhangtielei.com/assets/my_weixin_sign_sf_840.jpg",alt:"我的微信公众号: tielei-blog (张铁蕾)"}})])])}),[],!1,null,null,null);s.default=e.exports}}]);