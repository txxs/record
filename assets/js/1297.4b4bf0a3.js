(window.webpackJsonp=window.webpackJsonp||[]).push([[1297],{1689:function(s,a,e){"use strict";e.r(a);var t=e(13),v=Object(t.a)({},(function(){var s=this,a=s.$createElement,e=s._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"table-of-contents"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#table-of-contents"}},[s._v("#")]),s._v(" Table of Contents")]),s._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"#redis%E5%A4%8D%E5%88%B6%E6%A6%82%E8%AE%BA"}},[s._v("Redis复制概论")]),s._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"#redis%E5%A4%8D%E5%88%B6%E6%96%B9%E5%BC%8F"}},[s._v("Redis复制方式")])]),s._v(" "),e("li",[e("a",{attrs:{href:"#%E5%A4%8D%E5%88%B6%E4%BC%98%E7%82%B9"}},[s._v("复制优点")]),s._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"#1%E3%80%81%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7"}},[s._v("1、高可用性")])]),s._v(" "),e("li",[e("a",{attrs:{href:"#2%E3%80%81%E9%AB%98%E6%80%A7%E8%83%BD"}},[s._v("2、高性能")])]),s._v(" "),e("li",[e("a",{attrs:{href:"#3%E3%80%81%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%B1%95%E6%80%A7"}},[s._v("3、水平扩展性")])])])]),s._v(" "),e("li",[e("a",{attrs:{href:"#%E5%A4%8D%E5%88%B6%E7%BC%BA%E7%82%B9"}},[s._v("复制缺点")])]),s._v(" "),e("li",[e("a",{attrs:{href:"#%E5%A4%8D%E5%88%B6%E5%AE%9E%E6%97%B6%E6%80%A7%E5%92%8C%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E7%9F%9B%E7%9B%BE"}},[s._v("复制实时性和数据一致性矛盾")])])])]),s._v(" "),e("li",[e("a",{attrs:{href:"#redis%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E5%8F%8A%E7%89%B9%E6%80%A7"}},[s._v("Redis复制原理及特性")]),s._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"#slave%E6%8C%87%E5%90%91master"}},[s._v("slave指向master")])]),s._v(" "),e("li",[e("a",{attrs:{href:"#%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B"}},[s._v("复制过程")])]),s._v(" "),e("li",[e("a",{attrs:{href:"#%E5%A2%9E%E9%87%8F%E5%A4%8D%E5%88%B6"}},[s._v("增量复制")])]),s._v(" "),e("li",[e("a",{attrs:{href:"#%E5%85%8D%E6%8C%81%E4%B9%85%E5%8C%96%E5%A4%8D%E5%88%B6"}},[s._v("免持久化复制")])]),s._v(" "),e("li",[e("a",{attrs:{href:"#slave%E5%8F%AA%E8%AF%BB%E6%A8%A1%E5%BC%8F"}},[s._v("slave只读模式")])]),s._v(" "),e("li",[e("a",{attrs:{href:"#%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6"}},[s._v("半同步复制")])])])]),s._v(" "),e("li",[e("a",{attrs:{href:"#%E6%80%BB%E7%BB%93"}},[s._v("总结")])])]),s._v(" "),e("p",[s._v("本文转自互联网\n本文将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看")]),s._v(" "),e("blockquote",[e("p",[s._v("https://github.com/h2pl/Java-Tutorial")])]),s._v(" "),e("p",[s._v("喜欢的话麻烦点下Star哈")]),s._v(" "),e("p",[s._v("本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。")]),s._v(" "),e("p",[s._v("该系列博文会告诉你如何从入门到进阶，Redis基本的使用方法，Redis的基本数据结构，以及一些进阶的使用方法，同时也需要进一步了解Redis的底层数据结构，再接着，还会带来Redis主从复制、集群、分布式锁等方面的相关内容，以及作为缓存的一些使用方法和注意事项，以便让你更完整地了解整个Redis相关的技术体系，形成自己的知识框架。")]),s._v(" "),e("p",[s._v("如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。")]),s._v(" "),e("p",[s._v("转自网络，侵删")]),s._v(" "),e("p",[s._v("早期的RDBMS被设计为运行在单个CPU之上，读写操作都由经单个数据库实例完成，复制技术使得数据库的读写操作可以分散在运行于不同CPU之上的独立服务器上，Redis作为一个开源的、优秀的key-value缓存及持久化存储解决方案，也提供了复制功能，本文主要介绍Redis的复制原理及特性。")]),s._v(" "),e("h1",{attrs:{id:"redis复制概论"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis复制概论"}},[s._v("#")]),s._v(" Redis复制概论")]),s._v(" "),e("p",[s._v("数据库复制指的是发生在不同数据库实例之间，单向的信息传播的行为，通常由被复制方和复制方组成，被复制方和复制方之间建立网络连接，复制方式通常为被复制方主动将数据发送到复制方，复制方接收到数据存储在当前实例，最终目的是为了保证双方的数据一致、同步。")]),s._v(" "),e("p",[e("img",{attrs:{src:"http://static.oschina.net/uploads/space/2016/0529/130324_yGmz_1759553.png",alt:""}})]),s._v(" "),e("p",[s._v("复制示意图")]),s._v(" "),e("h2",{attrs:{id:"redis复制方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis复制方式"}},[s._v("#")]),s._v(" Redis复制方式")]),s._v(" "),e("p",[s._v("Redis的复制方式有两种，一种是主（master）-从（slave）模式，一种是从（slave）-从（slave）模式，因此Redis的复制拓扑图会丰富一些，可以像星型拓扑，也可以像个有向无环：")]),s._v(" "),e("p",[e("img",{attrs:{src:"http://static.oschina.net/uploads/space/2016/0529/131412_Ak0S_1759553.png",alt:""}})]),s._v(" "),e("p",[s._v("Redis集群复制结构图")]),s._v(" "),e("p",[s._v("通过配置多个Redis实例独立运行、定向复制，形成Redis集群，master负责写、slave负责读。")]),s._v(" "),e("h2",{attrs:{id:"复制优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#复制优点"}},[s._v("#")]),s._v(" 复制优点")]),s._v(" "),e("p",[s._v("通过配置多个Redis实例，数据备份在不同的实例上，主库专注写请求，从库负责读请求，这样的好处主要体现在下面几个方面：")]),s._v(" "),e("h3",{attrs:{id:"_1、高可用性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、高可用性"}},[s._v("#")]),s._v(" 1、高可用性")]),s._v(" "),e("p",[s._v("在一个Redis集群中，如果master宕机，slave可以介入并取代master的位置，因此对于整个Redis服务来说不至于提供不了服务，这样使得整个Redis服务足够安全。")]),s._v(" "),e("h3",{attrs:{id:"_2、高性能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、高性能"}},[s._v("#")]),s._v(" 2、高性能")]),s._v(" "),e("p",[s._v("在一个Redis集群中，master负责写请求，slave负责读请求，这么做一方面通过将读请求分散到其他机器从而大大减少了master服务器的压力，另一方面slave专注于提供读服务从而提高了响应和读取速度。")]),s._v(" "),e("h3",{attrs:{id:"_3、水平扩展性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、水平扩展性"}},[s._v("#")]),s._v(" 3、水平扩展性")]),s._v(" "),e("p",[s._v("通过增加slave机器可以横向（水平）扩展Redis服务的整个查询服务的能力。")]),s._v(" "),e("h2",{attrs:{id:"复制缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#复制缺点"}},[s._v("#")]),s._v(" 复制缺点")]),s._v(" "),e("p",[s._v("复制提供了高可用性的解决方案，但同时引入了分布式计算的复杂度问题，认为有两个核心问题：")]),s._v(" "),e("ol",[e("li",[s._v("数据一致性问题，如何保证master服务器写入的数据能够及时同步到slave机器上。")]),s._v(" "),e("li",[s._v("编程复杂，如何在客户端提供读写分离的实现方案，通过客户端实现将读写请求分别路由到master和slave实例上。")])]),s._v(" "),e("p",[s._v("上面两个问题，尤其是第一个问题是Redis服务实现一直在演变，致力于解决的一个问题。")]),s._v(" "),e("h2",{attrs:{id:"复制实时性和数据一致性矛盾"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#复制实时性和数据一致性矛盾"}},[s._v("#")]),s._v(" 复制实时性和数据一致性矛盾")]),s._v(" "),e("p",[s._v("Redis提供了提高数据一致性的解决方案，本文后面会进行介绍，一致性程度的增加虽然使得我能够更信任数据，但是更好的一致性方案通常伴随着性能的损失，从而减少了吞吐量和服务能力。然而我们希望系统的性能达到最优，则必须要牺牲一致性的程度，因此Redis的复制实时性和数据一致性是存在矛盾的。")]),s._v(" "),e("h1",{attrs:{id:"redis复制原理及特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis复制原理及特性"}},[s._v("#")]),s._v(" Redis复制原理及特性")]),s._v(" "),e("h2",{attrs:{id:"slave指向master"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#slave指向master"}},[s._v("#")]),s._v(" slave指向master")]),s._v(" "),e("p",[s._v("举个例子，我们有四台redis实例，M1，R1、R2、R3，其中M1为master，R1、R2、R3分别为三台slave redis实例。在M1启动如下：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("./redis-server ../redis8000.conf --port 8000\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("p",[s._v("下面分别为R1、R2、R3的启动命令：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v(" ./redis-server ../redis8001.conf --port 8001 --slaveof 127.0.0.1 8000 ./redis-server ../redis8002.conf --port 8002 --slaveof 127.0.0.1 8000 ./redis-server ../redis8003.conf --port 8003 --slaveof 127.0.0.1 8000\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("这样，我们就成功的启动了四台Redis实例，master实例的服务端口为8000，R1、R2、R3的服务端口分别为8001、8002、8003，集群图如下：")]),s._v(" "),e("p",[e("img",{attrs:{src:"http://static.oschina.net/uploads/space/2016/0529/135124_AfX5_1759553.png",alt:""}})]),s._v(" "),e("p",[s._v("Redis集群复制拓扑")]),s._v(" "),e("p",[s._v("上面的命令在slave启动的时候就指定了master机器，我们也可以在slave运行的时候通过slaveof命令来指定master机器。")]),s._v(" "),e("h2",{attrs:{id:"复制过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#复制过程"}},[s._v("#")]),s._v(" 复制过程")]),s._v(" "),e("p",[s._v("Redis复制主要由SYNC命令实现，复制过程如下图：")]),s._v(" "),e("p",[e("img",{attrs:{src:"http://static.oschina.net/uploads/space/2016/0529/142921_LCDS_1759553.png",alt:""}})]),s._v(" "),e("p",[s._v("Redis复制过程")]),s._v(" "),e("p",[s._v("上图为Redis复制工作过程：")]),s._v(" "),e("ol",[e("li",[s._v("slave向master发送sync命令。")]),s._v(" "),e("li",[s._v("master开启子进程来讲dataset写入rdb文件，同时将子进程完成之前接收到的写命令缓存起来。")]),s._v(" "),e("li",[s._v("子进程写完，父进程得知，开始将RDB文件发送给slave。")]),s._v(" "),e("li",[s._v("master发送完RDB文件，将缓存的命令也发给slave。")]),s._v(" "),e("li",[s._v("master增量的把写命令发给slave。")])]),s._v(" "),e("p",[s._v("值得注意的是，当slave跟master的连接断开时，slave可以自动的重新连接master，在redis2.8版本之前，每当slave进程挂掉重新连接master的时候都会开始新的一轮全量复制。如果master同时接收到多个slave的同步请求，则master只需要备份一次RDB文件。")]),s._v(" "),e("h2",{attrs:{id:"增量复制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#增量复制"}},[s._v("#")]),s._v(" 增量复制")]),s._v(" "),e("p",[s._v("上面复制过程介绍的最后提到，slave和master断开了、当slave和master重新连接上之后需要全量复制，这个策略是很不友好的，从Redis2.8开始，Redis提供了增量复制的机制：")]),s._v(" "),e("p",[e("img",{attrs:{src:"http://static.oschina.net/uploads/space/2016/0529/150147_XvpH_1759553.png",alt:""}})]),s._v(" "),e("p",[s._v("增量复制机制")]),s._v(" "),e("p",[s._v("master除了备份RDB文件之外还会维护者一个环形队列，以及环形队列的写索引和slave同步的全局offset，环形队列用于存储最新的操作数据，当slave和maste断开重连之后，会把slave维护的offset，也就是上一次同步到哪里的这个值告诉master，同时会告诉master上次和当前slave连接的master的runid，满足下面两个条件，Redis不会全量复制：")]),s._v(" "),e("ol",[e("li",[s._v("slave传递的run id和master的run id一致。")]),s._v(" "),e("li",[s._v("master在环形队列上可以找到对呀offset的值。")])]),s._v(" "),e("p",[s._v("满足上面两个条件，Redis就不会全量复制，这样的好处是大大的提高的性能，不做无效的功。")]),s._v(" "),e("p",[s._v("增量复制是由psync命令实现的，slave可以通过psync命令来让Redis进行增量复制，当然最终是否能够增量复制取决于环形队列的大小和slave的断线时间长短和重连的这个master是否是之前的master。")]),s._v(" "),e("p",[s._v("环形队列大小配置参数：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("repl-backlog-size 1mb\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("Redis同时也提供了当没有slave需要同步的时候，多久可以释放环形队列：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("repl-backlog-ttl 3600\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("h2",{attrs:{id:"免持久化复制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#免持久化复制"}},[s._v("#")]),s._v(" 免持久化复制")]),s._v(" "),e("p",[s._v("免持久化机制官方叫做Diskless Replication，前面基于RDB文件写磁盘的方式可以看出，Redis必须要先将RDB文件写入磁盘，才进行网络传输，那么为什么不能直接通过网络把RDB文件传送给slave呢？免持久化复制就是做这个事情的，而且在Redis2.8.18版本开始支持，当然目前还是实验阶段。")]),s._v(" "),e("p",[s._v("值得注意的是，一旦基于Diskless Replication的复制传送开始，新的slave请求需要等待这次传输完毕才能够得到服务。")]),s._v(" "),e("p",[s._v("是否开启Diskless Replication的开关配置为：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("repo-diskless-sync no\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("为了让后续的slave能够尽量赶上本次复制，Redis提供了一个参数配置指定复制开始的时间延迟：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("repl-diskless-sync-delay 5\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("h2",{attrs:{id:"slave只读模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#slave只读模式"}},[s._v("#")]),s._v(" slave只读模式")]),s._v(" "),e("p",[s._v("自从Redis2.6版本开始，支持对slave的只读模式的配置，默认对slave的配置也是只读。只读模式的slave将会拒绝客户端的写请求，从而避免因为从slave写入而导致的数据不一致问题。")]),s._v(" "),e("h2",{attrs:{id:"半同步复制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#半同步复制"}},[s._v("#")]),s._v(" 半同步复制")]),s._v(" "),e("p",[s._v("和MySQL复制策略有点类似，Redis复制本身是异步的，但也提供了半同步的复制策略，半同步复制策略在Redis复制中的语义是这样的：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("允许用户给出这样的配置：在maste接受写操作的时候，只有当一定时间间隔内，至少有N台slave在线，否则写入无效。\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("上面功能的实现基于Redis下面特性：")]),s._v(" "),e("ol",[e("li",[s._v("Redis slaves每秒钟会ping一次master，告诉master当前slave复制到哪里了。")]),s._v(" "),e("li",[s._v("Redis master会记住每个slave复制到哪里了。")])]),s._v(" "),e("p",[s._v("我们可以通过下面配置来指定时间间隔和N这个值：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("min-slaves-to-write <number of slaves>min-slaves-max-lag <number of seconds>\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("当配置了上面两个参数之后，一旦对于一个写操作没有满足上面的两个条件，则master会报错，并且将本次写操作视为无效。这有点像CAP理论中的“C”，即一致性实现，虽然半同步策略不能够完全保证master和slave的数据一致性，但是相对减少了不一致性的窗口期。")]),s._v(" "),e("h1",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),e("p",[s._v("本文在理解Redis复制概念和复制的优缺点的基础之上介绍了当前Redis复制工作原理以及主要特性，希望能够帮助大家。")])])}),[],!1,null,null,null);a.default=v.exports}}]);