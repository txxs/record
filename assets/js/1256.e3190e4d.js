(window.webpackJsonp=window.webpackJsonp||[]).push([[1256],{1653:function(s,a,e){"use strict";e.r(a);var n=e(13),t=Object(n.a)({},(function(){var s=this,a=s.$createElement,e=s._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("p",[s._v("MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。事务可一次执行多个命令， 并且带有以下两个重要的保证：")]),s._v(" "),e("ul",[e("li",[s._v("事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断")]),s._v(" "),e("li",[s._v("事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行")])]),s._v(" "),e("p",[s._v("得益于单线程模型的内存处理，没有并发事务，所以无隔离级别概念。")]),s._v(" "),e("p",[s._v("EXEC 命令负责触发并执行事务中的所有命令：")]),s._v(" "),e("ul",[e("li",[s._v("如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行")]),s._v(" "),e("li",[s._v("如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行")])]),s._v(" "),e("p",[s._v("当使用 AOF 时， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。")]),s._v(" "),e("p",[s._v("然而，如果 Redis 服务器因为某些原因被管理员杀死或硬件故障，则可能只有部分事务命令会被成功落盘。")]),s._v(" "),e("p",[s._v("如果 Redis 在重新启动时发现 AOF 文件出了这样问题，则它会退出，并汇报一个错误。")]),s._v(" "),e("p",[s._v("使用redis-check-aof程序可修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器顺利启动。")]),s._v(" "),e("p",[s._v("从 2.2 版本开始，Redis 还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作。")]),s._v(" "),e("h1",{attrs:{id:"用法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用法"}},[s._v("#")]),s._v(" 用法")]),s._v(" "),e("p",[s._v("MULTI 命令用于开启一个事务，它总返回 OK 。\nMULTI 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列， 当 EXEC命令被调用时， 所有队列中的命令才会被执行。")]),s._v(" "),e("p",[s._v("调用 DISCARD ， 客户端可以清空事务队列， 并放弃执行事务。")]),s._v(" "),e("p",[s._v("以下是一个事务例子， 它原子地增加了 foo 和 bar 两个键的值：")]),s._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" MULTI\nOK\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" INCR foo\nQUEUED\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" INCR bar\nQUEUED\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" EXEC\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("integer"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("integer"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br")])]),e("p",[s._v("EXEC 命令的响应是一个数组， 数组中的每个元素都是执行事务中的命令所产生的回复。 其中， 回复元素的先后顺序和命令发送的先后顺序一致。")]),s._v(" "),e("p",[s._v("当客户端处于事务状态时， 所有传入的命令都会返回一个内容为 QUEUED 的状态回复（status reply）， 这些被入队的命令将在 EXEC 命令被调用时执行。")]),s._v(" "),e("h1",{attrs:{id:"事务中的错误"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事务中的错误"}},[s._v("#")]),s._v(" 事务中的错误")]),s._v(" "),e("p",[s._v("使用事务时可能会遇上以下两种错误：")]),s._v(" "),e("h2",{attrs:{id:"事务在执行-exec-之前"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事务在执行-exec-之前"}},[s._v("#")]),s._v(" 事务在执行 EXEC 之前")]),s._v(" "),e("p",[s._v("入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。")]),s._v(" "),e("p",[s._v("发生在 EXEC 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：")]),s._v(" "),e("ul",[e("li",[s._v("如果命令入队时返回 QUEUED ，则入队成功")]),s._v(" "),e("li",[s._v("否则，即入队失败\n如果有命令在入队时失败，则大部分客户端都会停止并取消该事务。")])]),s._v(" "),e("p",[s._v("但从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。")]),s._v(" "),e("p",[s._v("Redis 2.6.5 以前， Redis 只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。 而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的响应都只需要和服务器进行一次通讯。")]),s._v(" "),e("h2",{attrs:{id:"命令可能在-exec-调用之后失败"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#命令可能在-exec-调用之后失败"}},[s._v("#")]),s._v(" 命令可能在 EXEC 调用之后失败")]),s._v(" "),e("p",[s._v("事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。\n至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。")]),s._v(" "),e("p",[s._v("从协议的角度来看这个问题，会更容易理解一些。 以下例子中， LPOP 命令的执行将出错， 尽管调用它的语法是正确的：")]),s._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[s._v("Trying "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("127.0")]),s._v(".0.1"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v(".\nConnected to localhost.\nEscape character is "),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'^]'")]),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v(".")]),s._v("\nMULTI\n+OK\nSET a "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v("\nabc\n+QUEUED\nLPOP a\n+QUEUED\nEXEC\n*2\n+OK\n-ERR Operation against a key holding the wrong kind of value\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br")])]),e("p",[s._v("EXEC 返回两条bulk-string-reply： 第一条是 OK ，而第二条是 -ERR 。 至于怎样用合适的方法来表示事务中的错误， 则是由客户端自己决定的。")]),s._v(" "),e("ul",[e("li",[s._v("Redis 不会停止执行事务中的命令\n"),e("strong",[s._v("即使事务中有某条/某些命令执行失败了， 事务队列中的其他命令仍然会继续执行")]),s._v("。")])]),s._v(" "),e("p",[s._v("以下例子展示的是另一种情况， 当命令在入队时产生错误， 错误会立即被返回给客户端：")]),s._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[s._v("MULTI\n+OK\nINCR a b c\n-ERR wrong number of arguments "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'incr'")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("command")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("p",[s._v("因为调用 INCR 命令的参数格式不正确， 所以这个 INCR 命令入队失败。")]),s._v(" "),e("h1",{attrs:{id:"为什么-redis-不支持回滚-roll-back"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么-redis-不支持回滚-roll-back"}},[s._v("#")]),s._v(" 为什么 Redis 不支持回滚（roll back）")]),s._v(" "),e("p",[s._v("使用过MySQL的， 都会好奇为何 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”。")]),s._v(" "),e("h2",{attrs:{id:"优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[s._v("#")]),s._v(" 优点")]),s._v(" "),e("ul",[e("li",[s._v("Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现）或命令用在了错误类型的key：即从实用性来看，失败的命令是由编程错误导致，而这些错误应该在开发过程中被发现，而不该出现在生产环境。")]),s._v(" "),e("li",[s._v("因为无需支持回滚，所以 Redis 可保持简单快速")])]),s._v(" "),e("p",[s._v("有人认为 Redis 处理事务的做法会产生 bug ， 但注意通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 INCR 命令将value加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR ， 回滚是没有办法处理这些情况的。")]),s._v(" "),e("h1",{attrs:{id:"放弃事务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#放弃事务"}},[s._v("#")]),s._v(" 放弃事务")]),s._v(" "),e("p",[s._v("当执行 DISCARD 命令时， 事务会被放弃， 事务队列会被清空， 并且客户端会从事务状态中退出：")]),s._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" SET foo "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\nOK\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" MULTI\nOK\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" INCR foo\nQUEUED\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" DISCARD\nOK\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" GET foo\n"),e("span",{pre:!0,attrs:{class:"token string"}},[s._v('"1"')]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br")])]),e("h1",{attrs:{id:"check-and-set-操作实现乐观锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#check-and-set-操作实现乐观锁"}},[s._v("#")]),s._v(" check-and-set 操作实现乐观锁")]),s._v(" "),e("p",[s._v("WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。")]),s._v(" "),e("p",[s._v("被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败。")]),s._v(" "),e("h2",{attrs:{id:"案例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#案例"}},[s._v("#")]),s._v(" 案例")]),s._v(" "),e("p",[s._v("原子地为某值+1（假设 INCR 不存在）。\n可能会这样做：")]),s._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[s._v("val "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" GET mykey\nval "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" val + "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\nSET mykey "),e("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$val")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("p",[s._v("这个实现在只有一个客户端时执行得很好。 但多个客户端同时对同一个键操作时， 就会产生竞态。\n比如两个客户端 A 和 B 都读取了键原来的值， 比如 10 ， 则两个客户端都会将键的值设为 11 ， 但正确的结果应该是 12。")]),s._v(" "),e("p",[s._v("WATCH即可解决这类问题：")]),s._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[s._v("WATCH mykey\nval "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" GET mykey\nval "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" val + "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\nMULTI\nSET mykey "),e("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$val")]),s._v("\nEXEC\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])]),e("p",[s._v("在 WATCH 执行后， EXEC 执行前， 若有其他客户端修改了 mykey 的值， 则当前客户端事务失败。 程序需要做的， 就是不断重试该操作， 直到没有发生冲突。")]),s._v(" "),e("p",[s._v("这种锁称作乐观锁，大多数情况下， 不同的客户端会访问不同键， 碰撞情况一般很少， 所以通常并不需要重试。")]),s._v(" "),e("h2",{attrs:{id:"watch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#watch"}},[s._v("#")]),s._v(" WATCH")]),s._v(" "),e("p",[s._v("WATCH 使得 EXEC 命令需要有条件地执行：事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。")]),s._v(" "),e("p",[s._v("WATCH 命令可被调用多次。 对键的监视从 WATCH 执行之后开始生效， 直到调用 EXEC 为止。")]),s._v(" "),e("p",[s._v("用户还可以在单个 WATCH 命令中监视任意多个键，如下：")]),s._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[s._v("redis"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" WATCH key1 key2 key3\nOK\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("p",[s._v("当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。")]),s._v(" "),e("p",[s._v("另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。")]),s._v(" "),e("p",[s._v("使用无参的 UNWATCH 命令可以手动取消对所有键的监视。 对于一些需要改动多个键的事务， 有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。 当值达不到要求时， 就可以使用 UNWATCH 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。")]),s._v(" "),e("h3",{attrs:{id:"使用-watch-实现-zpop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-watch-实现-zpop"}},[s._v("#")]),s._v(" 使用 WATCH 实现 ZPOP")]),s._v(" "),e("p",[s._v("WATCH 可以用于创建 Redis 没有内置的原子操作。举个例子， 以下代码实现了原创的 ZPOP 命令， 它可以原子地弹出有序集合中分值（score）最小的元素：")]),s._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[s._v("WATCH zset\nelement "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" ZRANGE zset "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v("\nMULTI\nZREM zset element\nEXEC\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("p",[s._v("程序只要重复执行这段代码， 直到 EXEC 的返回值不是nil-reply响应即可。")]),s._v(" "),e("h1",{attrs:{id:"redis-脚本和事务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis-脚本和事务"}},[s._v("#")]),s._v(" Redis 脚本和事务")]),s._v(" "),e("p",[s._v("Redis 中的脚本本身就是一种事务， 所以任何在事务可完成的事， 在脚本里面也能完成。\n一般使用脚本还更简单更快。")]),s._v(" "),e("p",[s._v("因为脚本 Redis 2.6 才引入， 所以导致 Redis 同时存在两种处理事务的方案。")]),s._v(" "),e("p",[s._v("不过Redis并不打算在短时间内就移除事务， 因为事务提供了一种即使不使用脚本， 也可避免竞争条件的方法， 而且事务实现不复杂。")]),s._v(" "),e("p",[s._v("不过不远的将来， 可能所有用户都会只使用脚本实现事务。真这样，则Redis会废弃并移除事务。")])])}),[],!1,null,null,null);a.default=t.exports}}]);