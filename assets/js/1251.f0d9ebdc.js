(window.webpackJsonp=window.webpackJsonp||[]).push([[1251],{1646:function(e,a,s){"use strict";s.r(a);var _=s(13),t=Object(_.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("看看 Redis 作者在 Stack Overflow 问答给出的几个对比维度。")]),e._v(" "),s("h1",{attrs:{id:"_1-不应该太在意的维度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-不应该太在意的维度"}},[e._v("#")]),e._v(" 1 不应该太在意的维度")]),e._v(" "),s("h2",{attrs:{id:"_1-1-性能"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-性能"}},[e._v("#")]),e._v(" 1.1 性能")]),e._v(" "),s("ul",[s("li",[e._v("平均到单核的性能，在单条数据不大时，Redis更快。以前因为Redis是单线程的，只能使用一个核。而Memcached是多线程的，所以对一个实例来说，性能上肯定是Memcached占优势。但现在Redis 6.x 已经支持多线程，Redis 在这点也没劣势了。")]),e._v(" "),s("li",[e._v("memcached可通过单个可执行文件和TCP端口使用多个内核，而无需客户端的帮助的多线程、非阻塞 IO 模式。memcached可以更快地获得大约100k的大值数据。Redis最近对大值（不稳定的分支）进行了很多改进，但是在这种场景下，memcached仍然更快（不过这个回答已经是很多年前了，现在优化的应该也没劣势了）。\n这里的重点是："),s("code",[e._v("任何一个查询都不应该成为它们每秒可以提供的查询的瓶颈")]),e._v("。")])]),e._v(" "),s("h1",{attrs:{id:"_2-应该在意的维度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-应该在意的维度"}},[e._v("#")]),e._v(" 2 应该在意的维度")]),e._v(" "),s("h2",{attrs:{id:"_2-1-内存利用率"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-内存利用率"}},[e._v("#")]),e._v(" 2.1 内存利用率")]),e._v(" "),s("ul",[s("li",[e._v("对于简单的键/值对，memcached的内存利用率更高。")]),e._v(" "),s("li",[e._v("而如果Redis采用hash结构存储键/值对，由于其组合式的压缩，其内存利用率会高于Memcached。")])]),e._v(" "),s("h2",{attrs:{id:"_2-2-持久化和复制-可靠性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-持久化和复制-可靠性"}},[e._v("#")]),e._v(" 2.2 持久化和复制（可靠性）")]),e._v(" "),s("p",[e._v("MemCached 不支持数据持久化，断电或重启后数据消失，所以只能作为缓存使用，但其稳定性是有保证的。")]),e._v(" "),s("p",[e._v("Redis 支持数据持久化和数据恢复，允许单点故障，但是同时也会付出性能的代价。这样启动更快，不需要从关系数据库加载数据，从自己的 dump 文件加载即可。")]),e._v(" "),s("ul",[s("li",[e._v("Memcached都不支持。")]),e._v(" "),s("li",[e._v("仅在Redis中可用的两个功能。即使你的目标是建立缓存，它也可以帮助你在升级或重启后仍然保留数据。")])]),e._v(" "),s("h2",{attrs:{id:"_2-3-所需的数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-所需的数据类型"}},[e._v("#")]),e._v(" 2.3 所需的数据类型")]),e._v(" "),s("ul",[s("li",[e._v("Memcached是一个内存中键值存储，用于存储来自数据库调用，API调用或页面呈现结果的小数据块（字符串、对象）。通常需要将数据拿到客户端（即只能在客户端完成计算）来进行类似的修改再set回去，这大大增加了网络I/O的次数和数据大小。")]),e._v(" "),s("li",[e._v("在Redis中，提供更多复杂的数据类型，因此也能支持更多应用场景。即使仅考虑缓存场景，通常也可以在单个操作中完成更多操作，而无需在客户端处理数据（即Redis支持服务器端数据计算），该操作通常和普通的GET和SET一样快。因此，如果你不仅需要GET / SET，还需要更复杂的功能，则Redis可以提供很大帮助（请考虑使用时间轴缓存）。")])]),e._v(" "),s("h2",{attrs:{id:"_2-4-集群模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-集群模式"}},[e._v("#")]),e._v(" 2.4 集群模式")]),e._v(" "),s("ul",[s("li",[e._v("memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据")]),e._v(" "),s("li",[e._v("但是redis目前是原生支持cluster模式的，redis官方就是支持redis cluster集群模式的，比memcached来说要更好")])]),e._v(" "),s("h2",{attrs:{id:"_2-5-应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-应用场景"}},[e._v("#")]),e._v(" 2.5 应用场景")]),e._v(" "),s("p",[e._v("Memcached：动态系统中减轻数据库负载，提升性能；做缓存，适合多读少写。")]),e._v(" "),s("p",[e._v("Redis：适用于对读写效率要求都很高，数据处理业务复杂和对安全性要求较高的系统。")]),e._v(" "),s("h1",{attrs:{id:"_3-开发前的考量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-开发前的考量"}},[e._v("#")]),e._v(" 3 开发前的考量")]),e._v(" "),s("ul",[s("li",[e._v("Memcached 单个 KV 大小有限，一个 V 最大只支持 1M，而 Redis 最大支持 512M。")]),e._v(" "),s("li",[e._v("Memcached 只做缓存，对可靠性无要求；而 Redis 更倾向于内存数据库，因此对对可靠性方面要求比较高")]),e._v(" "),s("li",[e._v("Memcached 只是个单一 KV 缓存；而 Redis 则是一个数据结构内存数据库，支持多种数据类型，因此 Redis 除单纯缓存作用外，还可以处理一些简单的逻辑运算，Redis 不仅可以缓存，而且还可以作为数据库用")]),e._v(" "),s("li",[e._v("Redis 还可集群分布式，即集群本身均衡客户端请求，各个节点可以交流，可拓展行、可维护性更强大。而 Memcached 的集群则需通过第三方才能搭建")])]),e._v(" "),s("h1",{attrs:{id:"_4-总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-总结"}},[e._v("#")]),e._v(" 4 总结")]),e._v(" "),s("p",[e._v("没有场景，就难以选型，但Redis在很多事情上都是有意义的，因为即使你不想将其用作数据库，也可以通过使用更多功能来解决更多问题，不只是缓存，甚至是消息队列，排名等。")]),e._v(" "),s("blockquote",[s("p",[e._v("参考")]),e._v(" "),s("ul",[s("li",[e._v("https://stackoverflow.com/questions/2873249/is-memcached-a-dinosaur-in-comparison-to-redis")]),e._v(" "),s("li",[e._v("https://github.com/memcached/memcached/wiki")])])])])}),[],!1,null,null,null);a.default=t.exports}}]);