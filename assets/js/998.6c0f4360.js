(window.webpackJsonp=window.webpackJsonp||[]).push([[998],{1393:function(r,t,n){"use strict";n.r(t);var e=n(13),a=Object(e.a)({},(function(){var r=this,t=r.$createElement,n=r._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[n("h1",{attrs:{id:"本周小结-贪心算法系列一"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#本周小结-贪心算法系列一"}},[r._v("#")]),r._v(" 本周小结！（贪心算法系列一）")]),r._v(" "),n("h2",{attrs:{id:"周一"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#周一"}},[r._v("#")]),r._v(" 周一")]),r._v(" "),n("p",[r._v("本周正式开始了贪心算法，在"),n("a",{attrs:{href:"https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("关于贪心算法，你该了解这些！"),n("OutboundLink")],1),r._v("中，我们介绍了什么是贪心以及贪心的套路。")]),r._v(" "),n("p",[n("strong",[r._v("贪心的本质是选择每一阶段的局部最优，从而达到全局最优。")])]),r._v(" "),n("p",[r._v("有没有啥套路呢？")]),r._v(" "),n("p",[n("strong",[r._v("不好意思，贪心没套路，就刷题而言，如果感觉好像局部最优可以推出全局最优，然后想不到反例，那就试一试贪心吧！")])]),r._v(" "),n("p",[r._v("而严格的数据证明一般有如下两种：")]),r._v(" "),n("ul",[n("li",[r._v("数学归纳法")]),r._v(" "),n("li",[r._v("反证法")])]),r._v(" "),n("p",[r._v("数学就不在讲解范围内了，感兴趣的同学可以自己去查一查资料。")]),r._v(" "),n("p",[r._v("正式因为贪心算法有时候会感觉这是常识，本就应该这么做！ 所以大家经常看到网上有人说这是一道贪心题目，有人是这不是。")]),r._v(" "),n("p",[r._v("这里说一下我的依据："),n("strong",[r._v("如果找到局部最优，然后推出整体最优，那么就是贪心")]),r._v("，大家可以参考哈。")]),r._v(" "),n("h2",{attrs:{id:"周二"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#周二"}},[r._v("#")]),r._v(" 周二")]),r._v(" "),n("p",[r._v("在"),n("a",{attrs:{href:"https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("贪心算法：分发饼干"),n("OutboundLink")],1),r._v("中讲解了贪心算法的第一道题目。")]),r._v(" "),n("p",[r._v("这道题目很明显能看出来是用贪心，也是入门好题。")]),r._v(" "),n("p",[r._v("我在文中给出"),n("strong",[r._v("局部最优：大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优：喂饱尽可能多的小孩")]),r._v("。")]),r._v(" "),n("p",[r._v("很多录友都是用小饼干优先先喂饱小胃口的。")]),r._v(" "),n("p",[r._v("后来我想一想，虽然结果是一样的，但是大家的这个思考方式更好一些。")]),r._v(" "),n("p",[n("strong",[r._v("因为用小饼干优先喂饱小胃口的 这样可以尽量保证最后省下来的是大饼干（虽然题目没有这个要求）！")])]),r._v(" "),n("p",[r._v("所有还是小饼干优先先喂饱小胃口更好一些，也比较直观。")]),r._v(" "),n("p",[r._v("一些录友不清楚"),n("a",{attrs:{href:"https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("贪心算法：分发饼干"),n("OutboundLink")],1),r._v("中时间复杂度是怎么来的？")]),r._v(" "),n("p",[r._v("就是快排$O(n\\log n)$，遍历$O(n)$，加一起就是还是$O(n\\log n)$。")]),r._v(" "),n("h2",{attrs:{id:"周三"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#周三"}},[r._v("#")]),r._v(" 周三")]),r._v(" "),n("p",[r._v("接下来就要上一点难度了，要不然大家会误以为贪心算法就是常识判断一下就行了。")]),r._v(" "),n("p",[r._v("在"),n("a",{attrs:{href:"https://programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("贪心算法：摆动序列"),n("OutboundLink")],1),r._v("中，需要计算最长摇摆序列。")]),r._v(" "),n("p",[r._v("其实就是让序列有尽可能多的局部峰值。")]),r._v(" "),n("p",[r._v("局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。")]),r._v(" "),n("p",[r._v("整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。")]),r._v(" "),n("p",[r._v("在计算峰值的时候，还是有一些代码技巧的，例如序列两端的峰值如何处理。")]),r._v(" "),n("p",[r._v("这些技巧，其实还是要多看多用才会掌握。")]),r._v(" "),n("h2",{attrs:{id:"周四"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#周四"}},[r._v("#")]),r._v(" 周四")]),r._v(" "),n("p",[r._v("在"),n("a",{attrs:{href:"https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("贪心算法：最大子序和"),n("OutboundLink")],1),r._v("中，详细讲解了用贪心的方式来求最大子序列和，其实这道题目是一道动态规划的题目。")]),r._v(" "),n("p",[n("strong",[r._v("贪心的思路为局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。从而推出全局最优：选取最大“连续和”")])]),r._v(" "),n("p",[r._v("代码很简单，但是思路却比较难。还需要反复琢磨。")]),r._v(" "),n("p",[r._v("针对"),n("a",{attrs:{href:"https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("贪心算法：最大子序和"),n("OutboundLink")],1),r._v("文章中给出的贪心代码如下；")]),r._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[r._v("class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int result = INT32_MIN;\n        int count = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            count += nums[i];\n            if (count > result) { // 取区间累计的最大值（相当于不断确定最大子序终止位置）\n                result = count;\n            }\n            if (count <= 0) count = 0; // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和\n        }\n        return result;\n    }\n};\n")])]),r._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[r._v("1")]),n("br"),n("span",{staticClass:"line-number"},[r._v("2")]),n("br"),n("span",{staticClass:"line-number"},[r._v("3")]),n("br"),n("span",{staticClass:"line-number"},[r._v("4")]),n("br"),n("span",{staticClass:"line-number"},[r._v("5")]),n("br"),n("span",{staticClass:"line-number"},[r._v("6")]),n("br"),n("span",{staticClass:"line-number"},[r._v("7")]),n("br"),n("span",{staticClass:"line-number"},[r._v("8")]),n("br"),n("span",{staticClass:"line-number"},[r._v("9")]),n("br"),n("span",{staticClass:"line-number"},[r._v("10")]),n("br"),n("span",{staticClass:"line-number"},[r._v("11")]),n("br"),n("span",{staticClass:"line-number"},[r._v("12")]),n("br"),n("span",{staticClass:"line-number"},[r._v("13")]),n("br"),n("span",{staticClass:"line-number"},[r._v("14")]),n("br"),n("span",{staticClass:"line-number"},[r._v("15")]),n("br")])]),n("p",[r._v("不少同学都来问，如果数组全是负数这个代码就有问题了，如果数组里有int最小值这个代码就有问题了。")]),r._v(" "),n("p",[r._v("大家不要脑洞模拟哈，可以亲自构造一些测试数据试一试，就发现其实没有问题。")]),r._v(" "),n("p",[r._v("数组都为负数，result记录的就是最小的负数，如果数组里有int最小值，那么最终result就是int最小值。")]),r._v(" "),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[r._v("#")]),r._v(" 总结")]),r._v(" "),n("p",[r._v("本周我们讲解了"),n("a",{attrs:{href:"https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("贪心算法的理论基础"),n("OutboundLink")],1),r._v("，了解了贪心本质：局部最优推出全局最优。")]),r._v(" "),n("p",[r._v("然后讲解了第一道题目"),n("a",{attrs:{href:"https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("分发饼干"),n("OutboundLink")],1),r._v("，还是比较基础的，可能会给大家一种贪心算法比较简单的错觉，因为贪心有时候接近于常识。")]),r._v(" "),n("p",[r._v("其实我还准备一些简单的贪心题目，甚至网上很多都质疑这些题目是不是贪心算法。这些题目我没有立刻发出来，因为真的会让大家感觉贪心过于简单，而忽略了贪心的本质：局部最优和全局最优两个关键点。")]),r._v(" "),n("p",[n("strong",[r._v("所以我在贪心系列难度会有所交替，难的题目在于拓展思路，简单的题目在于分析清楚其贪心的本质，后续我还会发一些简单的题目来做贪心的分析。")])]),r._v(" "),n("p",[r._v("在"),n("a",{attrs:{href:"https://programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("摆动序列"),n("OutboundLink")],1),r._v("中大家就初步感受到贪心没那么简单了。")]),r._v(" "),n("p",[r._v("本周最后是"),n("a",{attrs:{href:"https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("最大子序和"),n("OutboundLink")],1),r._v("，这道题目要用贪心的方式做出来，就比较有难度，都知道负数加上正数之后会变小，但是这道题目依然会让很多人搞混淆，其关键在于："),n("strong",[r._v("不能让“连续和”为负数的时候加上下一个元素，而不是 不让“连续和”加上一个负数")]),r._v("。这块真的需要仔细体会！")]),r._v(" "),n("div",{attrs:{align:"center"}},[n("img",{attrs:{src:"https://code-thinking.cdn.bcebos.com/pics/01二维码.jpg",width:"450"}})])])}),[],!1,null,null,null);t.default=a.exports}}]);