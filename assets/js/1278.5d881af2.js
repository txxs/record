(window.webpackJsonp=window.webpackJsonp||[]).push([[1278],{1673:function(t,_,s){"use strict";s.r(_);var e=s(13),v=Object(e.a)({},(function(){var t=this,_=t.$createElement,s=t._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("blockquote",[s("p",[t._v("全是干货的技术号：\n本文已收录在github，欢迎 star/fork：\nhttps://github.com/Wasabi1234/Java-Interview-Tutorial")])]),t._v(" "),s("h1",{attrs:{id:"_1-单线程模型设计"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-单线程模型设计"}},[t._v("#")]),t._v(" 1 单线程模型设计")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200901030321960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70#pic_center",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"单线程模型为何效率高"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单线程模型为何效率高"}},[t._v("#")]),t._v(" 单线程模型为何效率高")]),t._v(" "),s("ul",[s("li",[t._v("纯内存操作")]),t._v(" "),s("li",[t._v("基于非阻塞的IO多路复用机制")]),t._v(" "),s("li",[t._v("避免了多线程的频繁上下文切换")])]),t._v(" "),s("h1",{attrs:{id:"_2-文件事件处理器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-文件事件处理器"}},[t._v("#")]),t._v(" 2 文件事件处理器")]),t._v(" "),s("p",[t._v("Redis 基于 Reactor 模式开发了自己的网络事件处理器 - 文件事件处理器（file event handler，后文简称为 "),s("code",[t._v("FEH")]),t._v("），而该处理器又是单线程的，所以redis设计为单线程模型。")]),t._v(" "),s("ul",[s("li",[t._v("采用"),s("strong",[t._v("I/O多路复用")]),t._v("同时监听多个socket，根据socket当前执行的事件来为 socket 选择对应的事件处理器。")]),t._v(" "),s("li",[t._v("当被监听的socket准备好执行"),s("code",[t._v("accept")]),t._v("、"),s("code",[t._v("read")]),t._v("、"),s("code",[t._v("write")]),t._v("、"),s("code",[t._v("close")]),t._v("等操作时，和操作对应的文件事件就会产生，这时FEH就会调用socket之前关联好的事件处理器来处理对应事件。")])]),t._v(" "),s("p",[t._v("所以虽然FEH是单线程运行，但通过I/O多路复用监听多个socket，不仅实现高性能的网络通信模型，又能和 Redis 服务器中其它同样单线程运行的模块交互，保证了Redis内部单线程模型的简洁设计。")]),t._v(" "),s("ul",[s("li",[t._v("下面讲讲文件事件处理器的几个组成部分。\n"),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200901160813736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70#pic_center",alt:""}})])]),t._v(" "),s("h2",{attrs:{id:"_2-1-socket"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-socket"}},[t._v("#")]),t._v(" 2.1 socket")]),t._v(" "),s("p",[t._v("文件事件就是对socket操作的抽象， 每当一个 socket 准备好执行连接accept、read、write、close等操作时， 就会产生一个文件事件。 一个服务器通常会连接多个socket， 多个socket可能并发产生不同操作，每个操作对应不同文件事件。")]),t._v(" "),s("h2",{attrs:{id:"_2-2-i-o多路复用程序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-i-o多路复用程序"}},[t._v("#")]),t._v(" 2.2 I/O多路复用程序")]),t._v(" "),s("p",[t._v("I/O 多路复用程序会负责监听多个socket。")]),t._v(" "),s("p",[t._v("尽管文件事件可能并发出现， 但 I/O 多路复用程序会将所有产生事件的socket放入队列， 通过该队列以有序、同步且每次一个socket的方式向文件事件分派器传送socket。\n当上一个socket产生的事件被对应事件处理器执行完后， I/O 多路复用程序才会向文件事件分派器传送下个socket， 如下：\n"),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200901161358251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70#pic_center",alt:""}})]),t._v(" "),s("h3",{attrs:{id:"i-o多路复用程序的实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#i-o多路复用程序的实现"}},[t._v("#")]),t._v(" I/O多路复用程序的实现")]),t._v(" "),s("p",[t._v("Redis 的 I/O 多路复用程序的所有功能都是通过包装常见的 select 、 epoll 、 evport 和 kqueue 这些 I/O 多路复用函数库实现的。\n每个 I/O 多路复用函数库在 Redis 源码中都对应一个单独的文件：\n"),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200901165112600.png#pic_center",alt:""}})]),t._v(" "),s("p",[t._v("因为 Redis 为每个 I/O 多路复用函数库都实现了相同的 API ， 所以 I/O 多路复用程序的底层实现是可以互换的。Redis 在 I/O 多路复用程序的实现源码"),s("code",[t._v("ae.c")]),t._v("文件中宏定义了相应规则，使得程序在编译时自动选择系统中性能最高的 I/O 多路复用函数库作为 Redis 的 I/O 多路复用程序的底层实现：性能降序排列。\n"),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/2020090117061454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70#pic_center",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"_2-3-文件事件分派器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-文件事件分派器"}},[t._v("#")]),t._v(" 2.3 文件事件分派器")]),t._v(" "),s("p",[t._v("文件事件分派器接收 I/O 多路复用程序传来的socket， 并根据socket产生的事件类型， 调用相应的事件处理器。")]),t._v(" "),s("h2",{attrs:{id:"_2-4-文件事件处理器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-文件事件处理器"}},[t._v("#")]),t._v(" 2.4 文件事件处理器")]),t._v(" "),s("p",[t._v("服务器会为执行不同任务的套接字关联不同的事件处理器， 这些处理器是一个个函数， 它们定义了某个事件发生时， 服务器应该执行的动作。")]),t._v(" "),s("h3",{attrs:{id:"处理器映射"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#处理器映射"}},[t._v("#")]),t._v(" 处理器映射")]),t._v(" "),s("p",[t._v("Redis 为各种文件事件需求编写了多个处理器，若客户端：")]),t._v(" "),s("ul",[s("li",[t._v("连接Redis，对连接服务器的各个客户端进行应答，就需要将socket映射到"),s("strong",[t._v("连接应答处理器")])]),t._v(" "),s("li",[t._v("写数据到Redis，接收客户端传来的命令请求，就需要映射到"),s("strong",[t._v("命令请求处理器")])]),t._v(" "),s("li",[t._v("从Redis读数据，向客户端返回命令的执行结果，就需要映射到"),s("strong",[t._v("命令回复处理器")])])]),t._v(" "),s("p",[t._v("当主服务器和从服务器进行复制操作时， 主从服务器都需要映射到特别为复制功能编写的复制处理器。")]),t._v(" "),s("h2",{attrs:{id:"_2-5-文件事件的类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-文件事件的类型"}},[t._v("#")]),t._v(" 2.5 文件事件的类型")]),t._v(" "),s("p",[t._v("I/O 多路复用程序可以监听多个socket的 "),s("code",[t._v("ae.h/AE_READABLE")]),t._v(" 事件和 "),s("code",[t._v("ae.h/AE_WRITABLE")]),t._v(" 事件， 这两类事件和套接字操作之间的对应关系如下：")]),t._v(" "),s("ul",[s("li",[t._v("当socket可读（比如客户端对Redis执行"),s("code",[t._v("write")]),t._v("/"),s("code",[t._v("close")]),t._v("操作），或有新的可应答的socket出现时（即客户端对Redis执行"),s("code",[t._v("connect")]),t._v("操作），socket就会产生一个"),s("code",[t._v("AE_READABLE")]),t._v("事件\n"),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200901163905592.png#pic_center",alt:""}})]),t._v(" "),s("li",[t._v("当socket可写时（比如客户端对Redis执行read操作），socket会产生一个AE_WRITABLE事件。\n"),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200901164103757.png#pic_center",alt:""}})])]),t._v(" "),s("p",[t._v("I/O多路复用程序可以同时监听"),s("code",[t._v("AE_REABLE")]),t._v("和"),s("code",[t._v("AE_WRITABLE")]),t._v("两种事件，要是一个socket同时产生这两种事件，那么文件事件分派器优先处理"),s("code",[t._v("AE_REABLE")]),t._v("事件。即一个socket又可读又可写时， Redis服务器先读后写socket。")]),t._v(" "),s("h1",{attrs:{id:"_3-总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-总结"}},[t._v("#")]),t._v(" 3 总结")]),t._v(" "),s("p",[t._v("最后，让我们梳理一下客户端和Redis服务器通信的整个过程：\n"),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200901190856764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70#pic_center",alt:""}})]),t._v(" "),s("ol",{attrs:{start:"0"}},[s("li",[t._v("Redis启动初始化时，将"),s("strong",[t._v("连接应答处理器")]),t._v("跟"),s("strong",[t._v("AE_READABLE")]),t._v("事件关联。")]),t._v(" "),s("li",[t._v("若一个客户端发起连接，会产生一个"),s("code",[t._v("AE_READABLE")]),t._v("事件，然后由"),s("strong",[t._v("连接应答处理器")]),t._v("负责和客户端建立连接，创建客户端对应的socket，同时将这个socket的"),s("code",[t._v("AE_READABLE")]),t._v("事件和"),s("strong",[t._v("命令请求处理器")]),t._v("关联，使得客户端可以向主服务器发送命令请求。")]),t._v(" "),s("li",[t._v("当客户端向Redis发请求时（不管读还是写请求），客户端socket都会产生一个"),s("code",[t._v("AE_READABLE")]),t._v("事件，触发命令请求处理器。处理器读取客户端的命令内容， 然后传给相关程序执行。")]),t._v(" "),s("li",[t._v("当Redis服务器准备好给客户端的响应数据后，会将socket的"),s("code",[t._v("AE_WRITABLE")]),t._v("事件和"),s("code",[t._v("命令回复处理器")]),t._v("关联，当客户端准备好读取响应数据时，会在socket产生一个"),s("code",[t._v("AE_WRITABLE")]),t._v("事件，由对应命令回复处理器处理，即将准备好的响应数据写入socket，供客户端读取。")]),t._v(" "),s("li",[t._v("命令回复处理器全部写完到 socket 后，就会删除该socket的"),s("code",[t._v("AE_WRITABLE")]),t._v("事件和命令回复处理器的映射。")])]),t._v(" "),s("p",[t._v("参考")]),t._v(" "),s("ul",[s("li",[t._v("《Redis 设计与实现》")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200825235213822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_1,color_FFFFFF,t_70#pic_center",alt:""}})])])}),[],!1,null,null,null);_.default=v.exports}}]);