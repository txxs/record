(window.webpackJsonp=window.webpackJsonp||[]).push([[572],{964:function(e,n,t){"use strict";t.r(n);var a=t(13),i=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"table-of-contents"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#table-of-contents"}},[e._v("#")]),e._v(" Table of Contents")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#linkedlist"}},[e._v("LinkedList")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%E6%A6%82%E8%BF%B0"}},[e._v("概述")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"}},[e._v("源码分析")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%E5%AE%9A%E4%B9%89"}},[e._v("定义")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#%E5%B1%9E%E6%80%A7"}},[e._v("属性")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"}},[e._v("构造方法")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#%E5%A2%9E%E5%8A%A0%E6%96%B9%E6%B3%95"}},[e._v("增加方法")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#%E7%A7%BB%E9%99%A4%E6%96%B9%E6%B3%95"}},[e._v("移除方法")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95"}},[e._v("查找方法")])])])])])]),e._v(" "),t("li",[t("a",{attrs:{href:"#queue"}},[e._v("Queue")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#dequeue"}},[e._v("DeQueue")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#arraydeque-%EF%BC%88%E5%BA%95%E5%B1%82%E4%BD%BF%E7%94%A8%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%EF%BC%89"}},[e._v("ArrayDeque （底层使用循环数组实现双向队列）")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%E5%88%9B%E5%BB%BA"}},[e._v("创建")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#add%E6%93%8D%E4%BD%9C"}},[e._v("add操作")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#remove%E6%93%8D%E4%BD%9C"}},[e._v("remove操作")])])])]),e._v(" "),t("li",[t("a",{attrs:{href:"#priorityqueue%EF%BC%88%E5%BA%95%E5%B1%82%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%A0%86%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%89"}},[e._v("PriorityQueue（底层用数组实现堆的结构）")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#add-%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95"}},[e._v("add 添加方法")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#poll%EF%BC%8C%E5%87%BA%E9%98%9F%E6%96%B9%E6%B3%95"}},[e._v("poll，出队方法")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#remove%EF%BC%8C%E5%88%A0%E9%99%A4%E9%98%9F%E5%88%97%E5%85%83%E7%B4%A0"}},[e._v("remove，删除队列元素")])])])])])]),e._v(" "),t("li",[t("a",{attrs:{href:"#%E6%80%BB%E7%BB%93%E5%92%8C%E5%90%8C%E6%AD%A5%E7%9A%84%E9%97%AE%E9%A2%98"}},[e._v("总结和同步的问题")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"}},[e._v("参考文章")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7"}},[e._v("微信公众号")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96"}},[e._v("Java技术江湖")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#%E4%B8%AA%E4%BA%BA%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%BB%84%E5%B0%8F%E6%96%9C"}},[e._v("个人公众号：黄小斜")]),e._v("\n本文参考 http://cmsblogs.com/?p=155\n和\nhttps://www.jianshu.com/p/0e84b8d3606c")])])])]),e._v(" "),t("p",[e._v("《Java集合详解系列》是我在完成夯实Java基础篇的系列博客后准备开始整理的新系列文章。\n为了更好地诠释知识点，形成体系文章，本系列文章整理了很多优质的博客内容，如有侵权请联系我，一定删除。")]),e._v(" "),t("p",[e._v("这些文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看")]),e._v(" "),t("p",[e._v("如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。")]),e._v(" "),t("blockquote",[t("p",[e._v("https://github.com/h2pl/Java-Tutorial")])]),e._v(" "),t("p",[e._v("喜欢的话麻烦点下Star、fork哈")]),e._v(" "),t("p",[e._v("本系列文章将整理于我的个人博客：")]),e._v(" "),t("blockquote",[t("p",[e._v("www.how2playlife.com")])]),e._v(" "),t("h2",{attrs:{id:"linkedlist"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedlist"}},[e._v("#")]),e._v(" LinkedList")]),e._v(" "),t("h3",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),t("blockquote",[t("p",[e._v("LinkedList与ArrayList一样实现List接口，只是ArrayList是List接口的大小可变数组的实现，LinkedList是List接口链表的实现。基于链表实现的方式使得LinkedList在插入和删除时更优于ArrayList，而随机访问则比ArrayList逊色些。")]),e._v(" "),t("p",[e._v("LinkedList实现所有可选的列表操作，并允许所有的元素包括null。")]),e._v(" "),t("p",[e._v("除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。")]),e._v(" "),t("p",[e._v("此类实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作。")]),e._v(" "),t("p",[e._v("所有操作都是按照双重链接列表的需要执行的。在列表中编索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。")]),e._v(" "),t("p",[e._v("同时，与ArrayList一样此实现不是同步的。")]),e._v(" "),t("p",[e._v("（以上摘自JDK 6.0 API）。")])]),e._v(" "),t("h3",{attrs:{id:"源码分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#源码分析"}},[e._v("#")]),e._v(" 源码分析")]),e._v(" "),t("h4",{attrs:{id:"定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[e._v("#")]),e._v(" 定义")]),e._v(" "),t("p",[e._v("首先我们先看LinkedList的定义：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public class LinkedList<E>\n    extends AbstractSequentialList<E>\n    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n      从这段代码中我们可以清晰地看出LinkedList继承AbstractSequentialList，实现List、Deque、Cloneable、Serializable。其中AbstractSequentialList提供了 List 接口的骨干实现，从而最大限度地减少了实现受“连续访问”数据存储（如链接列表）支持的此接口所需的工作,从而以减少实现List接口的复杂度。Deque一个线性 collection，支持在两端插入和移除元素，定义了双端队列的操作。\n")])])]),t("h4",{attrs:{id:"属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#属性"}},[e._v("#")]),e._v(" 属性")]),e._v(" "),t("p",[e._v("在LinkedList中提供了两个基本属性size、header。")]),e._v(" "),t("p",[e._v("private transient Entry"),t("E",[e._v(" header = new Entry"),t("E",[e._v("(null, null, null);\nprivate transient int size = 0;\n其中size表示的LinkedList的大小，header表示链表的表头，Entry为节点对象。")])],1)],1),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("private static class Entry<E> {\n    E element;        //元素节点\n    Entry<E> next;    //下一个元素\n    Entry<E> previous;  //上一个元素\n\n    Entry(E element, Entry<E> next, Entry<E> previous) {\n        this.element = element;\n        this.next = next;\n        this.previous = previous;\n    }\n}\n  上面为Entry对象的源代码，Entry为LinkedList的内部类，它定义了存储的元素。该元素的前一个元素、后一个元素，这是典型的双向链表定义方式。\n")])])]),t("h4",{attrs:{id:"构造方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造方法"}},[e._v("#")]),e._v(" 构造方法")]),e._v(" "),t("p",[e._v("LinkedList提供了两个构造方法：LinkedList()和LinkedList(Collection<? extends E> c)。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("/**\n     *  构造一个空列表。\n     */\n    public LinkedList() {\n        header.next = header.previous = header;\n    }\n    \n    /**\n     *  构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。\n     */\n    public LinkedList(Collection<? extends E> c) {\n        this();\n        addAll(c);\n    }\n")])])]),t("p",[e._v("LinkedList()构造一个空列表。里面没有任何元素，仅仅只是将header节点的前一个元素、后一个元素都指向自身。")]),e._v(" "),t("p",[e._v("LinkedList(Collection<? extends E> c)： 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。该构造函数首先会调用LinkedList()，构造一个空列表，然后调用了addAll()方法将Collection中的所有元素添加到列表中。以下是addAll()的源代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('/**\n     *  添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。\n     */\n    public boolean addAll(Collection<? extends E> c) {\n        return addAll(size, c);\n    }\n    \n/**\n * 将指定 collection 中的所有元素从指定位置开始插入此列表。其中index表示在其中插入指定collection中第一个元素的索引\n */\npublic boolean addAll(int index, Collection<? extends E> c) {\n    //若插入的位置小于0或者大于链表长度，则抛出IndexOutOfBoundsException异常\n    if (index < 0 || index > size)\n        throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);\n    Object[] a = c.toArray();\n    int numNew = a.length;    //插入元素的个数\n    //若插入的元素为空，则返回false\n    if (numNew == 0)\n        return false;\n    //modCount:在AbstractList中定义的，表示从结构上修改列表的次数\n    modCount++;\n    //获取插入位置的节点，若插入的位置在size处，则是头节点，否则获取index位置处的节点\n    Entry<E> successor = (index == size ? header : entry(index));\n    //插入位置的前一个节点，在插入过程中需要修改该节点的next引用：指向插入的节点元素\n    Entry<E> predecessor = successor.previous;\n    //执行插入动作\n    for (int i = 0; i < numNew; i++) {\n        //构造一个节点e，这里已经执行了插入节点动作同时修改了相邻节点的指向引用\n        //\n        Entry<E> e = new Entry<E>((E) a[i], successor, predecessor);\n        //将插入位置前一个节点的下一个元素引用指向当前元素\n        predecessor.next = e;\n        //修改插入位置的前一个节点，这样做的目的是将插入位置右移一位，保证后续的元素是插在该元素的后面，确保这些元素的顺序\n        predecessor = e;\n    }\n    successor.previous = predecessor;\n    //修改容量大小\n    size += numNew;\n    return true;\n}\n  在addAll()方法中，涉及到了两个方法，一个是entry(int index)，该方法为LinkedList的私有方法，主要是用来查找index位置的节点元素。\n\n/**\n     * 返回指定位置(若存在)的节点元素\n     */\n    private Entry<E> entry(int index) {\n        if (index < 0 || index >= size)\n            throw new IndexOutOfBoundsException("Index: " + index + ", Size: "\n                    + size);\n        //头部节点\n        Entry<E> e = header;\n        //判断遍历的方向\n        if (index < (size >> 1)) {\n            for (int i = 0; i <= index; i++)\n                e = e.next;\n        } else {\n            for (int i = size; i > index; i--)\n                e = e.previous;\n        }\n        return e;\n    }\n')])])]),t("p",[e._v("从该方法有两个遍历方向中我们也可以看出LinkedList是双向链表，这也是在构造方法中为什么需要将header的前、后节点均指向自己。")]),e._v(" "),t("p",[e._v("如果对数据结构有点了解，对上面所涉及的内容应该问题，我们只需要清楚一点：LinkedList是双向链表，其余都迎刃而解。")]),e._v(" "),t("p",[e._v("由于篇幅有限，下面将就LinkedList中几个常用的方法进行源码分析。")]),e._v(" "),t("h4",{attrs:{id:"增加方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#增加方法"}},[e._v("#")]),e._v(" 增加方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  add(E e): 将指定元素添加到此列表的结尾。\n\npublic boolean add(E e) {\n    addBefore(e, header);\n        return true;\n    }\n      该方法调用addBefore方法，然后直接返回true，对于addBefore()而已，它为LinkedList的私有方法。\n\nprivate Entry<E> addBefore(E e, Entry<E> entry) {\n        //利用Entry构造函数构建一个新节点 newEntry，\n        Entry<E> newEntry = new Entry<E>(e, entry, entry.previous);\n        //修改newEntry的前后节点的引用，确保其链表的引用关系是正确的\n        newEntry.previous.next = newEntry;\n        newEntry.next.previous = newEntry;\n        //容量+1\n        size++;\n        //修改次数+1\n        modCount++;\n        return newEntry;\n    }\n")])])]),t("p",[e._v("在addBefore方法中无非就是做了这件事：构建一个新节点newEntry，然后修改其前后的引用。")]),e._v(" "),t("p",[e._v("LinkedList还提供了其他的增加方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  add(int index, E element)：在此列表中指定的位置插入指定的元素。\n\n  addAll(Collection<? extends E> c)：添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。\n\n  addAll(int index, Collection<? extends E> c)：将指定 collection 中的所有元素从指定位置开始插入此列表。\n\n  AddFirst(E e): 将指定元素插入此列表的开头。\n\n  addLast(E e): 将指定元素添加到此列表的结尾。\n")])])]),t("h4",{attrs:{id:"移除方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#移除方法"}},[e._v("#")]),e._v(" 移除方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  remove(Object o)：从此列表中移除首次出现的指定元素（如果存在）。该方法的源代码如下：\n\npublic boolean remove(Object o) {\n        if (o==null) {\n            for (Entry<E> e = header.next; e != header; e = e.next) {\n                if (e.element==null) {\n                    remove(e);\n                    return true;\n                }\n            }\n        } else {\n            for (Entry<E> e = header.next; e != header; e = e.next) {\n                if (o.equals(e.element)) {\n                    remove(e);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n")])])]),t("p",[e._v("该方法首先会判断移除的元素是否为null，然后迭代这个链表找到该元素节点，最后调用remove(Entry"),t("E",[e._v(" e)，remove(Entry"),t("E",[e._v(" e)为私有方法，是LinkedList中所有移除方法的基础方法，如下：")])],1)],1),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("private E remove(Entry<E> e) {\n        if (e == header)\n            throw new NoSuchElementException();\n\n        //保留被移除的元素：要返回\n        E result = e.element;\n        \n        //将该节点的前一节点的next指向该节点后节点\n        e.previous.next = e.next;\n        //将该节点的后一节点的previous指向该节点的前节点\n        //这两步就可以将该节点从链表从除去：在该链表中是无法遍历到该节点的\n        e.next.previous = e.previous;\n        //将该节点归空\n        e.next = e.previous = null;\n        e.element = null;\n        size--;\n        modCount++;\n        return result;\n    }\n")])])]),t("p",[e._v("其他的移除方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  clear()： 从此列表中移除所有元素。\n\n  remove()：获取并移除此列表的头（第一个元素）。\n\n  remove(int index)：移除此列表中指定位置处的元素。\n\n  remove(Objec o)：从此列表中移除首次出现的指定元素（如果存在）。\n\n  removeFirst()：移除并返回此列表的第一个元素。\n\n  removeFirstOccurrence(Object o)：从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。\n\n  removeLast()：移除并返回此列表的最后一个元素。\n\n  removeLastOccurrence(Object o)：从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。\n")])])]),t("h4",{attrs:{id:"查找方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查找方法"}},[e._v("#")]),e._v(" 查找方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  对于查找方法的源码就没有什么好介绍了，无非就是迭代，比对，然后就是返回当前值。\n\n  get(int index)：返回此列表中指定位置处的元素。\n\n  getFirst()：返回此列表的第一个元素。\n\n  getLast()：返回此列表的最后一个元素。\n\n  indexOf(Object o)：返回此列表中首次出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。\n\n  lastIndexOf(Object o)：返回此列表中最后出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。\n")])])]),t("h2",{attrs:{id:"queue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#queue"}},[e._v("#")]),e._v(" Queue")]),e._v(" "),t("p",[e._v("Queue接口定义了队列数据结构，元素是有序的(按插入顺序)，先进先出。Queue接口相关的部分UML类图如下：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/195193-bcff191213cf126a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/578",alt:""}})]),e._v(" "),t("h3",{attrs:{id:"dequeue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dequeue"}},[e._v("#")]),e._v(" DeQueue")]),e._v(" "),t("blockquote",[t("p",[e._v("DeQueue(Double-ended queue)为接口，继承了Queue接口，创建双向队列，灵活性更强，可以前向或后向迭代，在队头队尾均可心插入或删除元素。它的两个主要实现类是ArrayDeque和LinkedList。")])]),e._v(" "),t("h3",{attrs:{id:"arraydeque-底层使用循环数组实现双向队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#arraydeque-底层使用循环数组实现双向队列"}},[e._v("#")]),e._v(" ArrayDeque （底层使用循环数组实现双向队列）")]),e._v(" "),t("h4",{attrs:{id:"创建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建"}},[e._v("#")]),e._v(" 创建")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('public ArrayDeque() {\n   // 默认容量为16\n   elements = new Object[16];\n}\n\npublic ArrayDeque(int numElements) {\n   // 指定容量的构造函数\n   allocateElements(numElements);\n}\nprivate void allocateElements(int numElements) {\n        int initialCapacity = MIN_INITIAL_CAPACITY;// 最小容量为8\n        // Find the best power of two to hold elements.\n        // Tests "<=" because arrays aren\'t kept full.\n        // 如果要分配的容量大于等于8，扩大成2的幂（是为了维护头、尾下标值）；否则使用最小容量8\n        if (numElements >= initialCapacity) {\n            initialCapacity = numElements;\n            initialCapacity |= (initialCapacity >>>  1);\n            initialCapacity |= (initialCapacity >>>  2);\n            initialCapacity |= (initialCapacity >>>  4);\n            initialCapacity |= (initialCapacity >>>  8);\n            initialCapacity |= (initialCapacity >>> 16);\n            initialCapacity++;\n            if (initialCapacity < 0)   // Too many elements, must back off\n                initialCapacity >>>= 1;// Good luck allocating 2 ^ 30 elements\n        }\n        elements = new Object[initialCapacity];\n    }\n')])])]),t("h4",{attrs:{id:"add操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#add操作"}},[e._v("#")]),e._v(" add操作")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('add(E e) 调用 addLast(E e) 方法：\npublic void addLast(E e) {\n   if (e == null)\n      throw new NullPointerException("e == null");\n   elements[tail] = e; // 根据尾索引，添加到尾端\n   // 尾索引+1，并与数组（length - 1）进行取‘&’运算，因为length是2的幂，所以（length-1）转换为2进制全是1，\n   // 所以如果尾索引值 tail 小于等于（length - 1），那么‘&’运算后仍为 tail 本身；如果刚好比（length - 1）大1时，\n   // ‘&’运算后 tail 便为0（即回到了数组初始位置）。正是通过与（length - 1）进行取‘&’运算来实现数组的双向循环。\n   // 如果尾索引和头索引重合了，说明数组满了，进行扩容。\n   if ((tail = (tail + 1) & (elements.length - 1)) == head)\n      doubleCapacity();// 扩容为原来的2倍\n}\n\n\naddFirst(E e) 的实现：\npublic void addFirst(E e) {\n   if (e == null)\n      throw new NullPointerException("e == null");\n   // 此处如果head为0，则-1（1111 1111 1111 1111 1111 1111 1111 1111）与（length - 1）进行取‘&’运算，结果必然是（length - 1），即回到了数组的尾部。\n   elements[head = (head - 1) & (elements.length - 1)] = e;\n   // 如果尾索引和头索引重合了，说明数组满了，进行扩容\n   if (head == tail)\n      doubleCapacity();\n}\n')])])]),t("h4",{attrs:{id:"remove操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#remove操作"}},[e._v("#")]),e._v(" remove操作")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('remove()方法最终都会调对应的poll()方法：\n    public E poll() {\n        return pollFirst();\n    }\n    public E pollFirst() {\n        int h = head;\n        @SuppressWarnings("unchecked") E result = (E) elements[h];\n        // Element is null if deque empty\n        if (result == null)\n            return null;\n        elements[h] = null;     // Must null out slot\n        // 头索引 + 1\n        head = (h + 1) & (elements.length - 1);\n        return result;\n    }\n    public E pollLast() {\n        // 尾索引 - 1\n        int t = (tail - 1) & (elements.length - 1);\n        @SuppressWarnings("unchecked") E result = (E) elements[t];\n        if (result == null)\n            return null;\n        elements[t] = null;\n        tail = t;\n        return result;\n    }\n')])])]),t("p",[t("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/195193-e36436dd0c750c3c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700",alt:""}})]),e._v(" "),t("h3",{attrs:{id:"priorityqueue-底层用数组实现堆的结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#priorityqueue-底层用数组实现堆的结构"}},[e._v("#")]),e._v(" PriorityQueue（底层用数组实现堆的结构）")]),e._v(" "),t("blockquote",[t("p",[e._v("优先队列跟普通的队列不一样，普通队列是一种遵循FIFO规则的队列，拿数据的时候按照加入队列的顺序拿取。 而优先队列每次拿数据的时候都会拿出优先级最高的数据。")]),e._v(" "),t("p",[e._v("优先队列内部维护着一个堆，每次取数据的时候都从堆顶拿数据（堆顶的优先级最高），这就是优先队列的原理。")])]),e._v(" "),t("h4",{attrs:{id:"add-添加方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#add-添加方法"}},[e._v("#")]),e._v(" add 添加方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public boolean add(E e) {\n    return offer(e); // add方法内部调用offer方法\n}\npublic boolean offer(E e) {\n    if (e == null) // 元素为空的话，抛出NullPointerException异常\n        throw new NullPointerException();\n    modCount++;\n    int i = size;\n    if (i >= queue.length) // 如果当前用堆表示的数组已经满了，调用grow方法扩容\n        grow(i + 1); // 扩容\n    size = i + 1; // 元素个数+1\n    if (i == 0) // 堆还没有元素的情况\n        queue[0] = e; // 直接给堆顶赋值元素\n    else // 堆中已有元素的情况\n        siftUp(i, e); // 重新调整堆，从下往上调整，因为新增元素是加到最后一个叶子节点\n    return true;\n}\nprivate void siftUp(int k, E x) {\n    if (comparator != null)  // 比较器存在的情况下\n        siftUpUsingComparator(k, x); // 使用比较器调整\n    else // 比较器不存在的情况下\n        siftUpComparable(k, x); // 使用元素自身的比较器调整\n}\nprivate void siftUpUsingComparator(int k, E x) {\n    while (k > 0) { // 一直循环直到父节点还存在\n        int parent = (k - 1) >>> 1; // 找到父节点索引，等同于（k - 1）/ 2\n        Object e = queue[parent]; // 获得父节点元素\n        // 新元素与父元素进行比较，如果满足比较器结果，直接跳出，否则进行调整\n        if (comparator.compare(x, (E) e) >= 0) \n            break;\n        queue[k] = e; // 进行调整，新位置的元素变成了父元素\n        k = parent; // 新位置索引变成父元素索引，进行递归操作\n    }\n    queue[k] = x; // 新添加的元素添加到堆中\n}\n")])])]),t("p",[t("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/195193-be988ac1a1a415d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/670",alt:""}})]),e._v(" "),t("h4",{attrs:{id:"poll-出队方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#poll-出队方法"}},[e._v("#")]),e._v(" poll，出队方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public E poll() {\n    if (size == 0)\n        return null;\n    int s = --size; // 元素个数-1\n    modCount++;\n    E result = (E) queue[0]; // 得到堆顶元素\n    E x = (E) queue[s]; // 最后一个叶子节点\n    queue[s] = null; // 最后1个叶子节点置空\n    if (s != 0)\n        siftDown(0, x); // 从上往下调整，因为删除元素是删除堆顶的元素\n    return result;\n}\nprivate void siftDown(int k, E x) {\n    if (comparator != null) // 比较器存在的情况下\n        siftDownUsingComparator(k, x); // 使用比较器调整\n    else // 比较器不存在的情况下\n        siftDownComparable(k, x); // 使用元素自身的比较器调整\n}\nprivate void siftDownUsingComparator(int k, E x) {\n    int half = size >>> 1; // 只需循环节点个数的一般即可\n    while (k < half) {\n        int child = (k << 1) + 1; // 得到父节点的左子节点索引，即（k * 2）+ 1\n        Object c = queue[child]; // 得到左子元素\n        int right = child + 1; // 得到父节点的右子节点索引\n        if (right < size &&\n            comparator.compare((E) c, (E) queue[right]) > 0) // 左子节点跟右子节点比较，取更大的值\n            c = queue[child = right];\n        if (comparator.compare(x, (E) c) <= 0)  // 然后这个更大的值跟最后一个叶子节点比较\n            break;\n        queue[k] = c; // 新位置使用更大的值\n        k = child; // 新位置索引变成子元素索引，进行递归操作\n    }\n    queue[k] = x; // 最后一个叶子节点添加到合适的位置\n}\n")])])]),t("p",[t("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/195193-c88e7314648144da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/680",alt:""}})]),e._v(" "),t("h4",{attrs:{id:"remove-删除队列元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#remove-删除队列元素"}},[e._v("#")]),e._v(" remove，删除队列元素")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public boolean remove(Object o) {\n    int i = indexOf(o); // 找到数据对应的索引\n    if (i == -1) // 不存在的话返回false\n        return false;\n    else { // 存在的话调用removeAt方法，返回true\n        removeAt(i);\n        return true;\n    }\n}\nprivate E removeAt(int i) {\n    modCount++;\n    int s = --size; // 元素个数-1\n    if (s == i) // 如果是删除最后一个叶子节点\n        queue[i] = null; // 直接置空，删除即可，堆还是保持特质，不需要调整\n    else { // 如果是删除的不是最后一个叶子节点\n        E moved = (E) queue[s]; // 获得最后1个叶子节点元素\n        queue[s] = null; // 最后1个叶子节点置空\n        siftDown(i, moved); // 从上往下调整\n        if (queue[i] == moved) { // 如果从上往下调整完毕之后发现元素位置没变，从下往上调整\n            siftUp(i, moved); // 从下往上调整\n            if (queue[i] != moved)\n                return moved;\n        }\n    }\n    return null;\n}\n")])])]),t("p",[e._v("先执行 siftDown() 下滤过程：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/195193-a64dbb5508a9c668.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/642",alt:""}})]),e._v(" "),t("p",[e._v("再执行 siftUp() 上滤过程：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/195193-e9ad437213e69b07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/633",alt:""}})]),e._v(" "),t("h2",{attrs:{id:"总结和同步的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结和同步的问题"}},[e._v("#")]),e._v(" 总结和同步的问题")]),e._v(" "),t("p",[e._v("1、jdk内置的优先队列PriorityQueue内部使用一个堆维护数据，每当有数据add进来或者poll出去的时候会对堆做从下往上的调整和从上往下的调整。")]),e._v(" "),t("p",[e._v("2、PriorityQueue不是一个线程安全的类，如果要在多线程环境下使用，可以使用 PriorityBlockingQueue 这个优先阻塞队列。其中add、poll、remove方法都使用 ReentrantLock 锁来保持同步，take() 方法中如果元素为空，则会一直保持阻塞。")]),e._v(" "),t("h2",{attrs:{id:"参考文章"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[e._v("#")]),e._v(" 参考文章")]),e._v(" "),t("p",[e._v("http://cmsblogs.com/?p=155")]),e._v(" "),t("p",[e._v("https://www.jianshu.com/p/0e84b8d3606c")]),e._v(" "),t("p",[e._v("https://blog.csdn.net/Faker_Wang/article/details/80923155")]),e._v(" "),t("p",[e._v("https://blog.csdn.net/m0_37869177/article/details/88847569")]),e._v(" "),t("p",[e._v("https://www.iteye.com/blog/shmilyaw-hotmail-com-1825171")]),e._v(" "),t("p",[e._v("https://blog.csdn.net/weixin_36378917/article/details/81812210")]),e._v(" "),t("h2",{attrs:{id:"微信公众号"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#微信公众号"}},[e._v("#")]),e._v(" 微信公众号")]),e._v(" "),t("h3",{attrs:{id:"java技术江湖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java技术江湖"}},[e._v("#")]),e._v(" Java技术江湖")]),e._v(" "),t("p",[e._v("如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，作者黄小斜，专注 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！")]),e._v(" "),t("p",[t("strong",[e._v("Java工程师必备学习资源:")]),e._v(" 一些Java工程师常用学习资源，关注公众号后，后台回复关键字 "),t("strong",[e._v("“Java”")]),e._v(" 即可免费无套路获取。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190805090108984.jpg",alt:"我的公众号"}})]),e._v(" "),t("h3",{attrs:{id:"个人公众号-黄小斜"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#个人公众号-黄小斜"}},[e._v("#")]),e._v(" 个人公众号：黄小斜")]),e._v(" "),t("p",[e._v("作者是 985 硕士，蚂蚁金服 JAVA 工程师，专注于 JAVA 后端技术栈：SpringBoot、MySQL、分布式、中间件、微服务，同时也懂点投资理财，偶尔讲点算法和计算机理论基础，坚持学习和写作，相信终身学习的力量！")]),e._v(" "),t("p",[t("strong",[e._v("程序员3T技术学习资源：")]),e._v(" 一些程序员学习技术的资源大礼包，关注公众号后，后台回复关键字 "),t("strong",[e._v("“资料”")]),e._v(" 即可免费无套路获取。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190829222750556.jpg",alt:""}})])])}),[],!1,null,null,null);n.default=i.exports}}]);