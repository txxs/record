(window.webpackJsonp=window.webpackJsonp||[]).push([[294],{677:function(a,t,s){"use strict";s.r(t);var v=s(13),_=Object(v.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("p",[a._v("一个系统中包含有各种各样的配置信息，如一个日志文件需要配置以下几个信息。")]),a._v(" "),s("ul",[s("li",[a._v("日志文件生成主目录")]),a._v(" "),s("li",[a._v("日志文件名称，不同的日志级别对应不同的文件")]),a._v(" "),s("li",[a._v("当前日志级别")])]),a._v(" "),s("p",[a._v("还有其他各种业务参数、系统参数等，大多单一系统是直接把这些配置写死在配置文件中，当部署到测试、生产环境就再修改下配置文件，这样很容易出错，也不能灵活修改。还有就是系统变成分布式系统后，子系统越来越多，你要维护这些配置就变得越来越困难。")]),a._v(" "),s("p",[s("strong",[a._v("我觉得至少要能解决以下几个问题才能算优秀！")])]),a._v(" "),s("p",[a._v("1）能在线灵活修改配置")]),a._v(" "),s("p",[a._v("2）能在线动态刷新配置")]),a._v(" "),s("p",[a._v("3）能根据不同环境配置")]),a._v(" "),s("p",[a._v("4）能统一管理维护配置")]),a._v(" "),s("p",[a._v("那么如何灵活维护这些配置呢？我给大家总结了一下几类方法，根据不同的应用场大家参考一下。")]),a._v(" "),s("h4",{attrs:{id:"_1、数据库法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、数据库法"}},[a._v("#")]),a._v(" 1、数据库法")]),a._v(" "),s("p",[a._v("把所有参数存储到数据库，系统启动的时候加载到内存。")]),a._v(" "),s("p",[a._v("这种实现方式比较简单，但需要占用数据库资源，系统简单压力较小时可以选用此种方式。")]),a._v(" "),s("h4",{attrs:{id:"_2、打包处理法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、打包处理法"}},[a._v("#")]),a._v(" 2、打包处理法")]),a._v(" "),s("p",[a._v("利用 Maven 的 "),s("code",[a._v("maven-resources-plugin")]),a._v(" 插件，然后根据不同的环境（Profile）提供不同环境的配置文件，这样，不同环境的配置信息在打包阶段就决定好了。")]),a._v(" "),s("p",[a._v("这样只能解决了不同操作系统上面的配置，不能灵活动态修改，每次更新只能重新打包或者在线修改配置文件，而且信息也难于同步，如果项目少还好，项目多起来，配置还要经常变动，这样变得异常烦琐。")]),a._v(" "),s("h4",{attrs:{id:"_3、环境变量法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、环境变量法"}},[a._v("#")]),a._v(" 3、环境变量法")]),a._v(" "),s("p",[a._v("可以把属性值设置到环境变量中，然后读取后设置到 Java 系统属性中。这种可以实现区分不同环境的目的，但仍然不能动态更新配置，而且配置和维护环境变量相当麻烦，并且在分布式系统中更是个十分头疼的问题。")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("// 读取环境变量\njava.lang.System#getenv(java.lang.String)\n\n// 设置系统属性\njava.lang.System#setProperty\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br")])]),s("p",[a._v("这种方法，一些全局的系统配置，如日志、缓存、临时目录等可以参考，主流日志系统都支持从 system properties 中读取配置。其他一些配置，不建议存储在环境变量中。")]),a._v(" "),s("h4",{attrs:{id:"_4、配置中心法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4、配置中心法"}},[a._v("#")]),a._v(" 4、配置中心法")]),a._v(" "),s("p",[a._v("1）目前大多数分布式配置中心都是基于 Zookeeper 来实现的，Spring Cloud 有自己的配置中心组件，它们都支持在线动态更新和刷新配置。")]),a._v(" "),s("p",[a._v("2）直接把配置存放在数据库，如果系统并发小的或者管理类系统的话可以参考，对于高并发应用不建议用数据库做配置中心，毕竟它会带来访问压力，而且实现动态更新配置也比较复杂。")]),a._v(" "),s("h4",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),s("p",[a._v("这是我们目前应用的 4 种配置方法，很显然，配置中心是最佳的解决方案，也解决了以上的几个问题，但需要依赖中间件及其高可用性，如果你有其他更好的方式，欢迎留言。")]),a._v(" "),s("blockquote",[s("p",[a._v('本文原创首发于微信公众号：Java技术栈（id:javastack），关注公众号在后台回复 "分布式" 可获取更多，转载请原样保留来源信息。')])])])}),[],!1,null,null,null);t.default=_.exports}}]);