(window.webpackJsonp=window.webpackJsonp||[]).push([[346],{741:function(t,r,v){"use strict";v.r(r);var a=v(13),e=Object(a.a)({},(function(){var t=this,r=t.$createElement,v=t._self._c||r;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h3",{attrs:{id:"一、适配器模式和代理模式的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、适配器模式和代理模式的区别"}},[t._v("#")]),t._v(" 一、适配器模式和代理模式的区别")]),t._v(" "),v("p",[t._v("一.简介：适配器模式：适配器模式（英语：adapter pattern）有时候也称包装样式或者包装。将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。代理模式：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。")]),t._v(" "),v("p",[t._v("二.困惑：设计模式总是通过增加层来进行解耦合，提高扩展性，但是如果我们没法从在这个抽象维度中看出，这个层真正的抽象含义，那么我们很难搞懂一个模式真正的内涵？我就有这个疑问，这两个东东都是增加了一层，但是这一层有什么区别？")]),t._v(" "),v("p",[t._v("三.理解：很明显，适配器模式是因为新旧接口不一致导致出现了客户端无法得到满足的问题，但是，由于旧的接口是不能被完全重构掉的，因为我们还想使用实现了这个接口的一些服务。那么为了使用以前实现旧接口的服务，我们就应该把新的接口转换成旧接口；实现这个转换的类就是抽象意义的转换器。就比如在java中早期的枚举接口是Enumeration而后定义的枚举接口是Iterator;有很多旧的类实现了enumeration接口暴露出了一些服务，但是这些服务我们现在想通过传入Iterator接口而不是Enumeration接口来调用，这时就需要一个适配器，那么client就能用这个服务了（服务端只想用Iterator或者只知道这个接口）。相比于适配器的应用场景，代理就不一样了，虽然代理也同样是增加了一层，但是，代理提供的接口和原本的接口是一样的，代理模式的作用是不把实现直接暴露给client，而是通过代理这个层，代理能够做一些处理。")]),t._v(" "),v("h3",{attrs:{id:"二、简单工厂、工厂方法和抽象工厂区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、简单工厂、工厂方法和抽象工厂区别"}},[t._v("#")]),t._v(" 二、简单工厂、工厂方法和抽象工厂区别")]),t._v(" "),v("p",[t._v("简单工厂模式角色分配：")]),t._v(" "),v("ul",[v("li",[t._v("工厂(Factory)角色 :简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。")]),t._v(" "),v("li",[t._v("抽象产品(Product)角色 :简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。")]),t._v(" "),v("li",[t._v("具体产品(Concrete Product)角色:简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。")])]),t._v(" "),v("p",[t._v("工厂方法模式角色分配：")]),t._v(" "),v("ul",[v("li",[t._v("抽象工厂(Abstract Factory)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。")]),t._v(" "),v("li",[t._v("具体工厂(Concrete Factory)角色 ：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。")]),t._v(" "),v("li",[t._v("抽象产品(AbstractProduct)角色 ：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。")]),t._v(" "),v("li",[t._v("具体产品(Concrete Product)角色 ：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应")])]),t._v(" "),v("p",[t._v("抽象工厂方法模式角色分配：")]),t._v(" "),v("ul",[v("li",[t._v("抽象工厂（AbstractFactory）角色 ：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。")]),t._v(" "),v("li",[t._v("具体工厂类（ConreteFactory）角色 ：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。")]),t._v(" "),v("li",[t._v("抽象产品（Abstract Product）角色 ：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。")]),t._v(" "),v("li",[t._v("具体产品（Concrete Product）角色 ：抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。在抽象工厂中创建的产品属于同一产品族，这不同于工厂模式中的工厂只创建单一产品，我后面也会详解介绍到。")])]),t._v(" "),v("p",[t._v("具体看：")]),t._v(" "),v("p",[t._v("简单工厂：\n1.工厂类：负责实现创建所有产品实例的内部逻辑，它可以被外部直接调用来创建所需实例。\n2.抽象产品：所有产品的父类。用于描述所有产品公有的公共接口。\n3.具体产品")]),t._v(" "),v("p",[t._v("工厂方法：\n1.工厂类：功能和简单工厂相似，唯一区别是有抽象工厂和具体工厂，具体工厂可以创建对应的产品对象。\n2.抽象产品\n3.具体产品")]),t._v(" "),v("p",[t._v("抽象工厂：\n1.抽象工厂\n2.具体工厂：可以创建一组产品对象，和工厂方法区别的本质是抽象工厂可以生产一组产品。\n3.抽象产品：可以有多个抽象产品类。\n4.具体产品")]),t._v(" "),v("p",[t._v("引用自：\nhttps://blog.csdn.net/qq_34337272/article/details/80472071\nhttps://juejin.cn/post/6844904112975265799")]),t._v(" "),v("h3",{attrs:{id:"三、其他相似的设计模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、其他相似的设计模式"}},[t._v("#")]),t._v(" 三、其他相似的设计模式")]),t._v(" "),v("p",[t._v("Template vs. Strategy\n这两个是经常被用来比较的模式了。它们的目的一样，即使得对象的行为能够在运行时被改变，不同的是实现。Template模式使用了继承（Inheritance），而Strategy使用了组合（Composition）。稍具体来说，Strategy是通过组合维护了另一个行为对象的引用，需要执行相关任务时就委托（Delegation）给该对象，通过组合不同的被委托对象动态决定行为。Template则是在父类中定义算法框架，但算法中的一些步骤在子类中定义，运行时通过选择不同的子类决定最终行为。")]),t._v(" "),v("p",[t._v("Factory vs. Builder")]),t._v(" "),v("p",[t._v("两者的目的都是为了创建类的实例，区别在于Builder模式中独有的导演角色（Director role），这个角色负责将零件对象组装成整体。它的优点在于导演角色还可以根据不同的需求，通过改变组装过程从而得到不同的结果。这个过程就好像源码，经过预处理，编译，链接等各个环节，最终得到可执行对象一样。Factory则是一站式的服务，直接就给成品。")]),t._v(" "),v("p",[t._v("Visitor vs. Iterator\n两者的目的都是遍历，但遍历的结构和方式略有不同。一般地，Visitor遍历复杂结构，如树结构或组合结构等，结构中每个结点可以同构也可以异构，前提是只要提供一个预定的统一访问接口即可。Iterator用于遍历元素类型一致的集合（多是线性结构，当然也可以是非线性结构），不用为每个元素定义统一的访问接口，因为要进行什么操作用户自己决定。")]),t._v(" "),v("p",[t._v("Memento vs. State\n这两种模式像的只有名字了，其实没什么关系。前者的目的在于记录对象当前状态，好让以后能够恢复到这一点。后者用于实现状态机。")]),t._v(" "),v("p",[t._v("Adapter vs. Facade\n两种模式的形式很像，都是在对象外面包了层东西，而且都以改变原有接口为目的。区别在于前者一般只包装一个对象，目标是为了改变接口来适应外部系统，现实中的经典例子如电器插头，你英式的插头要进美式的插座就得用个转换器，但要完成的功能没变。而后者一般是将一个子系统进行包装，目的是简化接口，如汽车构造虽然复杂，但暴露给司机的接口-方向盘和油门刹车却很简单，功能也没变，只是用户操作更方便了。")]),t._v(" "),v("p",[t._v("Decorator vs. Adapter")]),t._v(" "),v("p",[t._v("两者形式上也很像，也都是在对象外包一层东西，但目的不一样，前者是为了给现有对象增加功能，一般接口不变或接口增加，如Java I/O就大量使用了这一模式。后者是为了改变其接口，功能保持不变。")]),t._v(" "),v("p",[t._v("State vs.Strategy")]),t._v(" "),v("p",[t._v("这两者在目的上没什么关系，但形式上却是一样的，都是将任务委托给其组合的对象。")]),t._v(" "),v("p",[t._v("Decorator, Adapter vs. Proxy")]),t._v(" "),v("p",[t._v("前两者包装即有对象，要么增加其行为，要么改变其接口。而相比而言，Proxy既不改变原有对象的行为也不会改变其接口，它的核心在于对被代理对象的控制。控制的目的可能是权限控制，虚拟化或者Cache等。还有个细微的区别是Proxy模式中代理对象和被代理对象可以是远程连接的，而Decorator中装饰对象/被装饰对象，Adapter中适配对象和被适配对象一般都在本地。")]),t._v(" "),v("p",[t._v("Abstract factory & Factory")]),t._v(" "),v("p",[t._v("Factory Method定义创建对象的接口，而将创建对象实例的过程放到子类中去定义，用户根据需要选择相应的工厂子类就行。可以看到，Factory模式本身还是Template模式的一种用法。Abstract Factory与之区别在于它是要创建一族相互关联或者依赖的产品。Abstract Factory需要定义所有具体工厂的接口，即它是“工厂的工厂”，每个具体的工厂都要实现其中的方法。Abstract factory用于创建一族相关的产品。如鼠标和键盘，工厂A既可以生产鼠标也可以生产键盘，工厂B也既可以生产鼠标也可以生产键盘，只是它们的实现不一样，如一个是生产无线鼠标键盘而另一个可以是生产有线鼠标键盘的。但你单独拿出一个产品（即鼠标或者键盘）来看，那就是个Factory模式。")]),t._v(" "),v("p",[t._v("Factory vs. Prototype\nFactory是从类重新实例一个对象，Prototype是从已有的实例直接拷贝生成一个实例，从而省去了初始化的过程。Prototype模式一般以clone()这种深拷贝函数的形式出现。")]),t._v(" "),v("p",[t._v("Memento vs. Command")]),t._v(" "),v("p",[t._v("两种模式都可以提供回到先前某点的功能，但前者是针对对象状态，后者针对对象行为。前者相当于为对象取一个snapshot，方便以后可以回到该点。正是这个特点，Memento模式也可用于对象序列化及反序列化。后者则通过类似于“撤消”（Undo）的动作来回滚之前动作的影响。")]),t._v(" "),v("p",[t._v("原文链接：https://blog.csdn.net/jinzhuojun/article/details/11555595")])])}),[],!1,null,null,null);r.default=e.exports}}]);