(window.webpackJsonp=window.webpackJsonp||[]).push([[297],{685:function(v,_,a){"use strict";a.r(_);var e=a(13),t=Object(e.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"table-of-contents"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#table-of-contents"}},[v._v("#")]),v._v(" Table of Contents")]),v._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF"}},[v._v("分布式技术")]),v._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%92%8Cnosql"}},[v._v("分布式数据和nosql")])]),v._v(" "),a("li",[a("a",{attrs:{href:"#%E7%BC%93%E5%AD%98-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98"}},[v._v("缓存 分布式缓存")]),v._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#redis%E7%9A%84%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88%EF%BC%9A"}},[v._v("redis的部署方案：")])]),v._v(" "),a("li",[a("a",{attrs:{href:"#%E7%BC%93%E5%AD%98%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"}},[v._v("缓存需要解决的问题：")])]),v._v(" "),a("li",[a("a",{attrs:{href:"#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E6%96%B9%E6%B3%95"}},[v._v("缓存更新的方法")])]),v._v(" "),a("li",[a("a",{attrs:{href:"#%E7%BC%93%E5%AD%98%E5%9C%A8springboot%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"}},[v._v("缓存在springboot中的使用")])]),v._v(" "),a("li",[a("a",{attrs:{href:"#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"}},[v._v("一致性哈希")])])])]),v._v(" "),a("li",[a("a",{attrs:{href:"#session%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8Fsession"}},[v._v("session和分布式session")])]),v._v(" "),a("li",[a("a",{attrs:{href:"#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"}},[v._v("负载均衡")])]),v._v(" "),a("li",[a("a",{attrs:{href:"#zookeeper"}},[v._v("zookeeper")])]),v._v(" "),a("li",[a("a",{attrs:{href:"#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"}},[v._v("数据库的分布式事务")])]),v._v(" "),a("li",[a("a",{attrs:{href:"#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%97%AE%E9%A2%98"}},[v._v("分布式锁问题")]),v._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#mysql%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"}},[v._v("MySQL实现分布式锁")])]),v._v(" "),a("li",[a("a",{attrs:{href:"#redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"}},[v._v("redis实现分布式锁")])]),v._v(" "),a("li",[a("a",{attrs:{href:"#zookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"}},[v._v("zookeeper实现分布式锁")])])])]),v._v(" "),a("li",[a("a",{attrs:{href:"#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"}},[v._v("消息队列")])]),v._v(" "),a("li",[a("a",{attrs:{href:"#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8Cdubbo"}},[v._v("微服务和Dubbo")]),v._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#%E5%85%A8%E5%B1%80id"}},[v._v("全局id")])])])]),v._v(" "),a("li",[a("a",{attrs:{href:"#%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F"}},[v._v("秒杀系统")]),v._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#%E7%AC%AC%E4%B8%80%E5%B1%82%EF%BC%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%88%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B1%82%EF%BC%8Capp%E5%B1%82%EF%BC%89"}},[v._v("第一层，客户端怎么优化（浏览器层，APP层）")])]),v._v(" "),a("li",[a("a",{attrs:{href:"#%E7%AC%AC%E4%BA%8C%E5%B1%82%EF%BC%8C%E7%AB%99%E7%82%B9%E5%B1%82%E9%9D%A2%E7%9A%84%E8%AF%B7%E6%B1%82%E6%8B%A6%E6%88%AA"}},[v._v("第二层，站点层面的请求拦截")])]),v._v(" "),a("li",[a("a",{attrs:{href:"#%E7%AC%AC%E4%B8%89%E5%B1%82-%E6%9C%8D%E5%8A%A1%E5%B1%82%E6%9D%A5%E6%8B%A6%E6%88%AA%EF%BC%88%E5%8F%8D%E6%AD%A3%E5%B0%B1%E6%98%AF%E4%B8%8D%E8%A6%81%E8%AE%A9%E8%AF%B7%E6%B1%82%E8%90%BD%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8A%E5%8E%BB%EF%BC%89%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%BC%93%E5%AD%98"}},[v._v("第三层 服务层来拦截（反正就是不要让请求落到数据库上去）消息队列+缓存")])]),v._v(" "),a("li",[a("a",{attrs:{href:"#%E5%A5%BD%E4%BA%86%EF%BC%8C%E6%9C%80%E5%90%8E%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B1%82"}},[v._v("好了，最后是数据库层")])]),v._v(" "),a("li",[a("a",{attrs:{href:"#%E6%80%BB%E7%BB%93"}},[v._v("总结")])])])]),v._v(" "),a("li",[a("a",{attrs:{href:"#%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7"}},[v._v("微信公众号")]),v._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96"}},[v._v("Java技术江湖")])]),v._v(" "),a("li",[a("a",{attrs:{href:"#%E4%B8%AA%E4%BA%BA%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%BB%84%E5%B0%8F%E6%96%9C"}},[v._v("个人公众号：黄小斜")])])])])])])]),v._v(" "),a("hr"),v._v(" "),a("h2",{attrs:{id:"title-分布式技术实践总结date-2018-07-08-22-15-36tags-分布式系统categories-后端-技术总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#title-分布式技术实践总结date-2018-07-08-22-15-36tags-分布式系统categories-后端-技术总结"}},[v._v("#")]),v._v(" title: 分布式技术实践总结\ndate: 2018-07-08 22:15:36\ntags:\n- 分布式系统\ncategories:\n- 后端\n- 技术总结")]),v._v(" "),a("p",[v._v("本文基于之前的分布式系统理论系列文章总结而成，本部分主要是实践内容，详细内容可见我的专栏：分布式系统理论与实践")]),v._v(" "),a("p",[v._v("https://blog.csdn.net/column/details/24090.html")]),v._v(" "),a("p",[v._v("本文主要是按照我自己的理解以及参考之前文章综合而成的，其中可能会有一些错误，还请见谅，也请指出。\n")]),v._v(" "),a("h1",{attrs:{id:"分布式技术"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式技术"}},[v._v("#")]),v._v(" 分布式技术")]),v._v(" "),a("h2",{attrs:{id:"分布式数据和nosql"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式数据和nosql"}},[v._v("#")]),v._v(" 分布式数据和nosql")]),v._v(" "),a("p",[v._v("分布式一般是指分布式部署的数据库。")]),v._v(" "),a("p",[v._v("比如Hbase基于HDFS分布式部署，所以他是一个分布式数据库。")]),v._v(" "),a("p",[v._v("当然MySQL也可以分布式部署，比如按照不同业务部署，或者把单表内容拆成多个表乃至多个库进行部署。")]),v._v(" "),a("p",[v._v("一般MySQL的扩展方式有：")]),v._v(" "),a("p",[v._v("1 主从复制 使用冗余保证可用")]),v._v(" "),a("p",[v._v("2 读写分离 主库负责写从库负责读，分担压力，并且保证数据一致性和备份。")]),v._v(" "),a("p",[v._v("3 分表分库，横向拆分数据表放到多个表中或者多个库中，一般多个表或者多个库会使用不同节点部署，也就是一种分布式方案，提高并发的读写量。")]),v._v(" "),a("p",[v._v("Nosql的话就比较多了，redis，memcache等。\n当然hbase也是，hbase按照region将数据文件分布在hdfs上，并且hdfs提供高可用和备份，同时hbase的regionserver也保证高可用，于是hbase的分布式方案也是比较成熟的。")]),v._v(" "),a("h2",{attrs:{id:"缓存-分布式缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存-分布式缓存"}},[v._v("#")]),v._v(" 缓存 分布式缓存")]),v._v(" "),a("p",[v._v("一般作为缓存的软件有redis，memcache等。当然我本地写一个hashmap也可以作为缓存。")]),v._v(" "),a("p",[v._v("memcache提出了一致性哈希的算法，但是本身不支持数据持久化，也没有提供分布式方案，需要自己完成持久化以及分布式部署并且保证其可用性。")]),v._v(" "),a("p",[v._v("redis作为新兴的内存数据库，提供了比memcache更多的数据结构，以及各种分布式方案。当然它也支持持久化。")]),v._v(" "),a("h3",{attrs:{id:"redis的部署方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis的部署方案"}},[v._v("#")]),v._v(" redis的部署方案：")]),v._v(" "),a("blockquote",[a("p",[v._v("1 redis的主从复制结构，和MySQL类似，使用日志aof或者持久化文件rdb进行主从同步。")]),v._v(" "),a("p",[v._v("2 读写分离，也可以做，但一般不需要。因为redis够快。")]),v._v(" "),a("p",[v._v("3 redis的哨兵方案，主节点配置哨兵，每当宕机时自动完成主从切换。")]),v._v(" "),a("p",[v._v("4 redis的集群方案，p2p的Redis Cluster部署了多台Redis服务器，每台Redis拥有全局的分片信息，所以任意节点都可以对外提供服务，当然每个节点只保存一部分分片，所以某台机器宕机时不会影响整个集群，当然每个节点也有slave，哨兵自动进行故障切换。")]),v._v(" "),a("p",[v._v("5 codis方案，codis屏蔽了集群的内部实现，可以不更改redis api的情况下使用代理的方式提供集群访问。并且使用 group的概念封装一组节点。")])]),v._v(" "),a("h3",{attrs:{id:"缓存需要解决的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存需要解决的问题"}},[v._v("#")]),v._v(" 缓存需要解决的问题：")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("命中：缓存有数据\n不命中：去数据库读取\n失效：过期\n替换：缓存淘汰算法。\n\n一般有lru，fifo，随机缓存等。\n")])])]),a("h3",{attrs:{id:"缓存更新的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存更新的方法"}},[v._v("#")]),v._v(" 缓存更新的方法")]),v._v(" "),a("p",[v._v("缓存更新可以先更新数据库再更新缓存，也可以先更新缓存再更新数据库。")]),v._v(" "),a("p",[v._v("一般推荐先更新数据库，否则写一条数据时刚好有人读到缓存，把旧数据读到缓存中，此时新数据在数据库确不在缓存中。")]),v._v(" "),a("p",[v._v("还有一种方法，就是让缓存自己去完成数据库更新，而不是让应用去选择如何更新数据库，这样的话缓存和数据库的更新操作就是透明的了，我们只需要操作缓存即可。")]),v._v(" "),a("h3",{attrs:{id:"缓存在springboot中的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存在springboot中的使用"}},[v._v("#")]),v._v(" 缓存在springboot中的使用")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("springboot支持将缓存的curd操作配置在注解中，只需要在对应方法上配置好键和更新策略。\n\n则redis会根据该方法的操作类型执行对应操作，非常方便。\n")])])]),a("h3",{attrs:{id:"一致性哈希"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一致性哈希"}},[v._v("#")]),v._v(" 一致性哈希")]),v._v(" "),a("p",[v._v("分布式部署时，经常要面对的问题是，一个服务集群由谁来提供给这个客户度服务，需要一种算法来完成这一步映射。")]),v._v(" "),a("p",[v._v("如果直接使用hash显然分布非常不均匀。那如果使用余数法呢，一共有N台机器，我对N取余可以映射到任意一台机器上。")]),v._v(" "),a("p",[v._v("这种方法的缺点在于，当取余的值集中在某一范围时，就容易集中访问某些机器，导致热点问题。")]),v._v(" "),a("blockquote",[a("p",[v._v("于是memcache推出了一个叫做一致性哈希的算法，一个哈希环，环上支持2^32次方个节点，也就是包含了所有的ip。")]),v._v(" "),a("p",[v._v("然后我们把主机通过hash值分布到这个环上，请求到来时会映射到某一个节点，如果该节点没有主机，则顺时针寻找真正主机。")]),v._v(" "),a("p",[v._v("当节点加入或者节点删除时，并不会影响服务的可用性，只是某些请求会被映射到别的节点。")])]),v._v(" "),a("p",[v._v("但是当请求集中到某个区域时，会产生倾斜，我们引入了虚拟节点来改善这个问题，虚拟节点对应到真实节点，所以加入虚拟节点可以更好地转移请求。")]),v._v(" "),a("h2",{attrs:{id:"session和分布式session"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#session和分布式session"}},[v._v("#")]),v._v(" session和分布式session")]),v._v(" "),a("p",[v._v("session是web应用必备的一个结构。\n一般有几种方案来管理session。")]),v._v(" "),a("p",[v._v("1 web应用保存session到内存中，但是宕机会丢失")]),v._v(" "),a("p",[v._v("2 web应用持久化到数据库或者redis，增加数据库负担。")]),v._v(" "),a("p",[v._v("3 使用cookie保存加密后的session，浏览器压力大，可能被破解")]),v._v(" "),a("p",[v._v("4 使用单独的session服务集群提供session服务，并且本身也可以采用分布式部署，部署的时候可以主从。")]),v._v(" "),a("p",[v._v("保证session一致性的解决方法（客户端可以访问到自己的session）：")]),v._v(" "),a("p",[v._v("1 客户端cookie保存")]),v._v(" "),a("p",[v._v("2 多个webserver进行同步，效率低")]),v._v(" "),a("p",[v._v("3 反向代理绑定ip映射同一个服务器，但是宕机时出错")]),v._v(" "),a("p",[v._v("4 后端统一存储，比如redis，或则部署session服务。")]),v._v(" "),a("h2",{attrs:{id:"负载均衡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡"}},[v._v("#")]),v._v(" 负载均衡")]),v._v(" "),a("p",[v._v("负载均衡一般可以分为七层，四层负载均衡。")]),v._v(" "),a("p",[v._v("Nginx")]),v._v(" "),a("p",[v._v("七层的负载均衡也就是http负载均衡，主要使用Nginx完成。")]),v._v(" "),a("blockquote",[a("p",[v._v("配置Nginx进行反向代理的url，然后转发请求到上游服务器，请求进来时自动转发到上游服务器，通过url进行负载均衡，所以是七层负载均衡。既然是七层负载，那么上游服务器提供了http服务，也可以解析该请求。")]),v._v(" "),a("p",[v._v("四层负载均衡主要是tcp请求的负载均衡，因为tcp请求是绑定到一个端口上的，所以我们根据端口进行请求转发到上游服务器的。既然是四层负载，上游服务器监听该端口的服务就可以处理该请求。")])]),v._v(" "),a("p",[v._v("LVS")]),v._v(" "),a("p",[v._v("LVS术语定义：")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("DS：Director Server，前端负载均衡器节点（后文用Director称呼）；\n\nRS：Real Server，后端真实服务器；\n\nVIP：用户请求的目标的IP地址，一般是公网IP地址；\n\nDIP：Director Server IP，Director和Real Server通讯的内网IP地址；\n\nRIP：Real Server IP，Director和Real Server通讯的内网IP地址；\n")])])]),a("p",[v._v("LVS有三种实现负载均衡的方式")]),v._v(" "),a("p",[v._v("NAT 四层负载均衡")]),v._v(" "),a("blockquote",[a("p",[v._v("NAT支持四层负载均衡，NAT中只有DS提供公网ip，并且VIP绑定在DS的mac地址上，客户端只能访问DS。同时DS和RS通过内网ip进行网络连接。当TCP数据报到达DS时，DS修改数据报，指向RS的ip和port。进行转发即可。")]),v._v(" "),a("p",[v._v("同时，RS处理完请求后，由于网关时DS，所以仍然要返回给DS处理。")]),v._v(" "),a("p",[v._v("NAT模式中，RS返回数据包是返回给Director，Director再返回给客户端；事实上这跟NAT网络协议没什么关系。")])]),v._v(" "),a("p",[v._v("DR 二层负载均衡")]),v._v(" "),a("blockquote",[a("p",[v._v("DR模式中，DS负责接收请求。接收请求后把数据报的mac地址改成指向RS的mac地址，并且由于三台机器拥有同样的vip地址。\n所以RS接收请求后认为该数据报应该由自己处理并相应。")]),v._v(" "),a("p",[v._v("同时为了避免RS再把相应转发会DS，我们禁用了对DS的arp，所以此时RS就会通过vip把响应通过vip网关返回给客户端。")]),v._v(" "),a("p",[v._v("Director通过修改请求中目标地址MAC为选定的RS实现数据转发，这就要求Diretor和Real Server必须在同一个广播域内，也就是他们的mac地址是可达的。\nDR（Direct Routing）模式中，RS返回数据是直接返回给客户端（通过额外的路由）；")])]),v._v(" "),a("p",[v._v("TUN")]),v._v(" "),a("blockquote",[a("p",[v._v("TUN中使用了IP隧道技术，客户端请求发给DS时，DS会通过隧道技术把数据报通过隧道发给实际的RS，然后RS解析数据以后可以直接响应给客户端，因为他有客户端的ip地址。这就不要求DS和RS在同一网段了，当然前提是RS有公网ip。")]),v._v(" "),a("p",[v._v("TUN（IP Tunneling）模式中，RS返回的数据也是直接返回给客户端，这种模式通过Overlay协议（把一个IP数据包封装到另一个数据包内部叫Overlay）避免了DR的限制。")])]),v._v(" "),a("h2",{attrs:{id:"zookeeper"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper"}},[v._v("#")]),v._v(" zookeeper")]),v._v(" "),a("p",[v._v("zookeeper集群自身的特性：")]),v._v(" "),a("blockquote",[a("p",[v._v("1 一个zookeeper服务器集群，一开始就会进行选主，主节点挂掉后也会进行选主。")]),v._v(" "),a("p",[v._v("使用zab协议中的选主机制进行选主，也就是每个节点进行一次提议，刚开始提议自己，如果有新的提议则覆盖自己原来的提议，不断重复，直到有节点获得过半的投票。完成一轮选主。")]),v._v(" "),a("p",[v._v("2 选主结束后，开始进行消息广播和数据同步，保证每一台服务器的数据都和leader同步。")]),v._v(" "),a("p",[v._v("3 开始提供服务，客户端向leader发送请求，leader首先发出提议，当有半数以上节点响应时，leader会发送commit信息，于是所有节点执行该操作。当有机器宕机时重启后会和leader同步。这是一个类似2pc的提交方式。")])]),v._v(" "),a("p",[v._v("zookeeper提供了分布式环境中常用的服务")]),v._v(" "),a("blockquote",[a("p",[v._v("1 配置服务，多个机器可以通过文件节点共享配置。")]),v._v(" "),a("p",[v._v("2 选主服务，通过添加顺序节点，可以进行选主。")]),v._v(" "),a("p",[v._v("3 分布式锁，顺序节点和watcher")]),v._v(" "),a("p",[v._v("4 全局id，使用机器号+时间戳可以生成一个transactionid，是全局唯一的。")])]),v._v(" "),a("h2",{attrs:{id:"数据库的分布式事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库的分布式事务"}},[v._v("#")]),v._v(" 数据库的分布式事务")]),v._v(" "),a("p",[v._v("分布式事务的实现一般可以用2PC和3PC解决。")]),v._v(" "),a("p",[v._v("成熟的方案有：")]),v._v(" "),a("blockquote",[a("p",[v._v("1 TCC 补偿式事务，对每一个步骤都有一个补偿措施。")]),v._v(" "),a("p",[v._v("2 全局事务实现。")]),v._v(" "),a("p",[v._v("3 事务消息：rocketmq的事务实现，先发消息到队列中，然后本地执行事务并通知消息队列，若成功则消息主动推给另一个服务，直到服务二执行成功，消息从队列中删除。如果超时不成功，则消息要求事务A回滚。")]),v._v(" "),a("p",[v._v("如果过程中失败了，本地事务也会回滚。消息队列可以回调本地接口判断事务是否执行成功，防止超时。")]),v._v(" "),a("p",[v._v("4 本地实现消息表：\n本地实现消息表并且和事务记录存在一起，自己实现消息的轮询发送。\n首先把本地事务操作和消息增加放在一个事务里执行，然后轮询消息表进行发送，如果执行成功则消息达到服务B，通知其执行。执行成功后消息被删除，否则回滚事务删除消息。")])]),v._v(" "),a("h2",{attrs:{id:"分布式锁问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁问题"}},[v._v("#")]),v._v(" 分布式锁问题")]),v._v(" "),a("p",[v._v("分布式锁用于分布式环境中的资源互斥，因为单机可以通过共享内存实现，而分布式环境只能通过网络实现。")]),v._v(" "),a("h3",{attrs:{id:"mysql实现分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql实现分布式锁"}},[v._v("#")]),v._v(" MySQL实现分布式锁")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("insert加锁，锁没有失效时间，容易产生死锁\n")])])]),a("h3",{attrs:{id:"redis实现分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis实现分布式锁"}},[v._v("#")]),v._v(" redis实现分布式锁")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("1. 基于setnx、expire两个命令来实现\n\n基于setnx（set if not exist）的特点，当缓存里key不存在时，才会去set，否则直接返回false。\n\n如果返回true则获取到锁，否则获取锁失败，为了防止死锁，我们再用expire命令对这个key设置一个超时时间来避免。\n\n但是这里看似完美，实则有缺陷，当我们setnx成功后，线程发生异常中断，expire还没来的及设置，那么就会产生死锁。\n\n2 使用getset实现，可以判断自己是否获得了锁，但是可能会出现并发的原子性问题。拆分成两个操作。\n\n3 避免原子性问题可以使用lua脚本保证事务的原子性。\n\n4 上述都是单点的redis，如果是分布式环境的redis集群，可以使用redlock，要求节点向半数以上redis机器请求锁。才算成功。\n")])])]),a("h3",{attrs:{id:"zookeeper实现分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper实现分布式锁"}},[v._v("#")]),v._v(" zookeeper实现分布式锁")]),v._v(" "),a("p",[v._v("创建有序节点，最小的抢到锁，其他的监听他的上一个节点即可。并且抢到锁的节点释放时只会通知下一个节点。")]),v._v(" "),a("p",[v._v("小结")]),v._v(" "),a("p",[v._v("在分布式系统中，共享资源互斥访问问题非常普遍，而针对访问共享资源的互斥问题，常用的解决方案就是使用分布式锁，这里只介绍了几种常用的分布式锁，分布式锁的实现方式还有有很多种，根据业务选择合适的分布式锁，下面对上述几种锁进行一下比较：")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("数据库锁：\n\n优点：直接使用数据库，使用简单。\n\n缺点：分布式系统大多数瓶颈都在数据库，使用数据库锁会增加数据库负担。\n\n缓存锁：\n\n优点：性能高，实现起来较为方便，在允许偶发的锁失效情况，不影响系统正常使用，建议采用缓存锁。\n\n缺点：通过锁超时机制不是十分可靠，当线程获得锁后，处理时间过长导致锁超时，就失效了锁的作用。\n\nzookeeper锁：\n\n优点：不依靠超时时间释放锁；可靠性高；系统要求高可靠性时，建议采用zookeeper锁。\n\n缺点：性能比不上缓存锁，因为要频繁的创建节点删除节点。并且zookeeper只能单点写入。而Redis可以并发写入。\n")])])]),a("h2",{attrs:{id:"消息队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[v._v("#")]),v._v(" 消息队列")]),v._v(" "),a("p",[v._v("适合场景：")]),v._v(" "),a("p",[v._v("1 服务之间解耦，比如淘宝的买家服务和物流服务，中间需要消息传递订单信息。但又不需要强耦合。便于服务的划分和独立部署")]),v._v(" "),a("p",[v._v("2 控制流量，大流量访问某服务时，避免服务出现问题，将其先存入队列，均匀释放流量。")]),v._v(" "),a("p",[v._v("3 削峰，当某一个服务如秒杀，如果直接集中访问，服务器可能会冲垮，所以先存到队列中，控制访问量，避免服务器冲击。")]),v._v(" "),a("p",[v._v("4 事务，消息事务")]),v._v(" "),a("p",[v._v("5 异步请求处理，比如一些不重要的服务可以延缓执行，比如卖家评价，站内信等。")]),v._v(" "),a("p",[v._v("常用消息队列：")]),v._v(" "),a("p",[v._v("rabbitmq：使用consumer和producer的模型，并且使用了broker，broker中包含路由功能的exchanger，每个key绑定一个queue，应用通过key进行队列消费和生产。")]),v._v(" "),a("p",[v._v("一般是点对点的消息，也可以支持一对多的消息，当然也可以支持消息的订阅。还有就是主题模式，和key的区别就是主题模式是多级的key表示。")]),v._v(" "),a("p",[v._v("kafka：")]),v._v(" "),a("h2",{attrs:{id:"微服务和dubbo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微服务和dubbo"}},[v._v("#")]),v._v(" 微服务和Dubbo")]),v._v(" "),a("p",[v._v("分布式架构意味着服务的拆分，最早的SOA架构已经进行了服务拆分，但是每个服务还是太过庞大，不适合扩展和修改。")]),v._v(" "),a("p",[v._v("微服务的拆分粒度更加细，服务可以独立部署和快速迭代，通知支持扩展。")]),v._v(" "),a("p",[v._v("服务之间一般使用rpc调用进行访问，可以使用自定义协议也可以使用http服务，当然通过netty 实现TCP服务并且搭配合理的序列化方案也可以完成rpc功能。rpc是微服务的基础。")]),v._v(" "),a("p",[v._v("微服务一般需要配置中心来进行服务注册和发现，以便服务信息更新和配置，dubbo中使用的是zookeeper，用于配置服务信息提供给生产者使用。")]),v._v(" "),a("p",[v._v("一般情况下微服务需要有监控中心，心跳检测每一台服务器，及时完成故障切换和通知。同时监控服务的性能和使用情况。")]),v._v(" "),a("p",[v._v("序列化方式一般可以使用protobuf，http服务一般使用json。")]),v._v(" "),a("p",[v._v("微服务还支持更多的包括权限控制，流量控制，灰度发布，服务降级等内容，这里就不再细谈。")]),v._v(" "),a("h3",{attrs:{id:"全局id"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全局id"}},[v._v("#")]),v._v(" 全局id")]),v._v(" "),a("p",[v._v("方法一：使用数据库的 auto_increment 来生成全局唯一递增ID")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("优点：\n\n简单，使用数据库已有的功能\n\n能够保证唯一性\n\n能够保证递增性\n\n步长固定\n")])])]),a("p",[v._v("​"),a("br"),v._v("\n​"),a("br"),v._v("\n缺点：")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("可用性难以保证：数据库常见架构是一主多从+读写分离，生成自增ID是写请求，主库挂了就玩不转了\n\n扩展性差，性能有上限：因为写入是单点，数据库主库的写性能决定ID的生成性能上限，并且难以扩展\n")])])]),a("p",[v._v("方法三：uuid/guid")]),v._v(" "),a("p",[v._v("不管是通过数据库，还是通过服务来生成ID，业务方Application都需要进行一次远程调用，比较耗时。")]),v._v(" "),a("p",[v._v("有没有一种本地生成ID的方法，即高性能，又时延低呢？")]),v._v(" "),a("p",[v._v("uuid是一种常见的方案：")]),v._v(" "),a("p",[v._v("string ID =GenUUID();")]),v._v(" "),a("p",[v._v("优点：")]),v._v(" "),a("p",[v._v("本地生成ID，不需要进行远程调用，时延低")]),v._v(" "),a("p",[v._v("扩展性好，基本可以认为没有性能上限")]),v._v(" "),a("p",[v._v("缺点：")]),v._v(" "),a("p",[v._v("无法保证趋势递增")]),v._v(" "),a("p",[v._v("uuid过长，往往用字符串表示，作为主键建立索引查询效率低，常见优化方案为“转化为两个uint64整数存储”或者“折半存储”（折半后不能保证唯一性）")]),v._v(" "),a("p",[v._v("方法四：取当前毫秒数")]),v._v(" "),a("p",[v._v("uuid是一个本地算法，生成性能高，但无法保证趋势递增，且作为字符串ID检索效率低，有没有一种能保证递增的本地算法呢？")]),v._v(" "),a("p",[v._v("取当前毫秒数是一种常见方案：")]),v._v(" "),a("p",[v._v("uint64 ID = GenTimeMS();")]),v._v(" "),a("p",[v._v("优点：")]),v._v(" "),a("p",[v._v("本地生成ID，不需要进行远程调用，时延低")]),v._v(" "),a("p",[v._v("生成的ID趋势递增")]),v._v(" "),a("p",[v._v("生成的ID是整数，建立索引后查询效率高")]),v._v(" "),a("p",[v._v("缺点：")]),v._v(" "),a("p",[v._v("如果并发量超过1000，会生成重复的ID")]),v._v(" "),a("p",[v._v("方法五：类snowflake算法")]),v._v(" "),a("p",[v._v("snowflake是twitter开源的分布式ID生成算法，其核心思想为，一个long型的ID：")]),v._v(" "),a("p",[v._v("41bit作为毫秒数")]),v._v(" "),a("p",[v._v("10bit作为机器编号")]),v._v(" "),a("p",[v._v("12bit作为毫秒内序列号")]),v._v(" "),a("p",[v._v("算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。")]),v._v(" "),a("h2",{attrs:{id:"秒杀系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#秒杀系统"}},[v._v("#")]),v._v(" 秒杀系统")]),v._v(" "),a("p",[a("img",{attrs:{src:"http://i2.51cto.com/images/blog/201803/11/9eda905930f00090d55b5ae3f6796d2b.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=",alt:"image"}})]),v._v(" "),a("h3",{attrs:{id:"第一层-客户端怎么优化-浏览器层-app层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第一层-客户端怎么优化-浏览器层-app层"}},[v._v("#")]),v._v(" 第一层，客户端怎么优化（浏览器层，APP层）")]),v._v(" "),a("p",[v._v("（a）产品层面，用户点击“查询”或者“购票”后，按钮置灰，禁止用户重复提交请求；")]),v._v(" "),a("p",[v._v("（b）JS层面，限制用户在x秒之内只能提交一次请求；")]),v._v(" "),a("h3",{attrs:{id:"第二层-站点层面的请求拦截"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第二层-站点层面的请求拦截"}},[v._v("#")]),v._v(" 第二层，站点层面的请求拦截")]),v._v(" "),a("blockquote",[a("p",[v._v("怎么拦截？怎么防止程序员写for循环调用，有去重依据么？ip？cookie-id？…想复杂了，这类业务都需要登录，用uid即可。在站点层面，对uid进行请求计数和去重，甚至不需要统一存储计数，直接站点层内存存储（这样计数会不准，但最简单）。一个uid，5秒只准透过1个请求，这样又能拦住99%的for循环请求。")]),v._v(" "),a("p",[v._v("5s只透过一个请求，其余的请求怎么办？缓存，页面缓存，同一个uid，限制访问频度，做页面缓存，x秒内到达站点层的请求，均返回同一页面。同一个item的查询，例如车次，做页面缓存，x秒内到达站点层的请求，均返回同一页面。如此限流，既能保证用户有良好的用户体验（没有返回404）又能保证系统的健壮性（利用页面缓存，把请求拦截在站点层了）。")])]),v._v(" "),a("p",[v._v("好，这个方式拦住了写for循环发http请求的程序员，有些高端程序员（黑客）控制了10w个肉鸡，手里有10w个uid，同时发请求（先不考虑实名制的问题，小米抢手机不需要实名制），这下怎么办，站点层按照uid限流拦不住了。")]),v._v(" "),a("h3",{attrs:{id:"第三层-服务层来拦截-反正就是不要让请求落到数据库上去-消息队列-缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第三层-服务层来拦截-反正就是不要让请求落到数据库上去-消息队列-缓存"}},[v._v("#")]),v._v(" 第三层 服务层来拦截（反正就是不要让请求落到数据库上去）消息队列+缓存")]),v._v(" "),a("p",[v._v("服务层怎么拦截？大哥，我是服务层，我清楚的知道小米只有1万部手机，我清楚的知道一列火车只有2000张车票，我透10w个请求去数据库有什么意义呢？没错，请求队列！")]),v._v(" "),a("p",[v._v("对于写请求，做请求队列，每次只透有限的写请求去数据层（下订单，支付这样的写业务）")]),v._v(" "),a("p",[v._v("1w部手机，只透1w个下单请求去db")]),v._v(" "),a("p",[v._v("3k张火车票，只透3k个下单请求去db")]),v._v(" "),a("p",[v._v("如果均成功再放下一批，如果库存不够则队列里的写请求全部返回“已售完”。")]),v._v(" "),a("p",[v._v("对于读请求，怎么优化？cache抗，不管是memcached还是redis，单机抗个每秒10w应该都是没什么问题的。如此限流，只有非常少的写请求，和非常少的读缓存mis的请求会透到数据层去，又有99.9%的请求被拦住了。")]),v._v(" "),a("h3",{attrs:{id:"好了-最后是数据库层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#好了-最后是数据库层"}},[v._v("#")]),v._v(" 好了，最后是数据库层")]),v._v(" "),a("p",[v._v("浏览器拦截了80%，站点层拦截了99.9%并做了页面缓存，服务层又做了写请求队列与数据缓存，每次透到数据库层的请求都是可控的。db基本就没什么压力了，闲庭信步，单机也能扛得住，还是那句话，库存是有限的，小米的产能有限，透这么多请求来数据库没有意义。")]),v._v(" "),a("p",[v._v("全部透到数据库，100w个下单，0个成功，请求有效率0%。透3k个到数据，全部成功，请求有效率100%。")]),v._v(" "),a("p",[a("img",{attrs:{src:"http://i2.51cto.com/images/blog/201803/11/bf7107f82e635020a43f12aa4a8dc856.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=",alt:"image"}})]),v._v(" "),a("h3",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),a("p",[v._v("上文应该描述的非常清楚了，没什么总结了，对于秒杀系统，再次重复下我个人经验的两个架构优化思路：")]),v._v(" "),a("p",[v._v("（1）尽量将请求拦截在系统上游（越上游越好）；")]),v._v(" "),a("p",[v._v("（2）读多写少的常用多使用缓存（缓存抗读压力）；")]),v._v(" "),a("p",[v._v("浏览器和APP：做限速")]),v._v(" "),a("p",[v._v("站点层：按照uid做限速，做页面缓存")]),v._v(" "),a("p",[v._v("服务层：按照业务做写请求队列控制流量，做数据缓存")]),v._v(" "),a("p",[v._v("数据层：闲庭信步")]),v._v(" "),a("p",[v._v("并且：结合业务做优化")]),v._v(" "),a("h2",{attrs:{id:"微信公众号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微信公众号"}},[v._v("#")]),v._v(" 微信公众号")]),v._v(" "),a("h3",{attrs:{id:"java技术江湖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java技术江湖"}},[v._v("#")]),v._v(" Java技术江湖")]),v._v(" "),a("p",[v._v("如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，作者黄小斜，专注 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！")]),v._v(" "),a("p",[a("strong",[v._v("Java工程师必备学习资源:")]),v._v(" 一些Java工程师常用学习资源，关注公众号后，后台回复关键字 "),a("strong",[v._v("“Java”")]),v._v(" 即可免费无套路获取。")]),v._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190805090108984.jpg",alt:"我的公众号"}})]),v._v(" "),a("h3",{attrs:{id:"个人公众号-黄小斜"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#个人公众号-黄小斜"}},[v._v("#")]),v._v(" 个人公众号：黄小斜")]),v._v(" "),a("p",[v._v("作者是 985 硕士，蚂蚁金服 JAVA 工程师，专注于 JAVA 后端技术栈：SpringBoot、MySQL、分布式、中间件、微服务，同时也懂点投资理财，偶尔讲点算法和计算机理论基础，坚持学习和写作，相信终身学习的力量！")]),v._v(" "),a("p",[a("strong",[v._v("程序员3T技术学习资源：")]),v._v(" 一些程序员学习技术的资源大礼包，关注公众号后，后台回复关键字 "),a("strong",[v._v("“资料”")]),v._v(" 即可免费无套路获取。")]),v._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190829222750556.jpg",alt:""}})])])}),[],!1,null,null,null);_.default=t.exports}}]);