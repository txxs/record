(window.webpackJsonp=window.webpackJsonp||[]).push([[614],{1006:function(a,t,s){"use strict";s.r(t);var e=s(13),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"table-of-contents"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#table-of-contents"}},[a._v("#")]),a._v(" Table of Contents")]),a._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#%E4%B8%80%E3%80%81jvm%E5%B8%B8%E8%A7%81%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7%E6%8C%87%E4%BB%A4"}},[a._v("一、jvm常见监控工具&指令")]),a._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#1%E3%80%81-jpsjvm%E8%BF%9B%E7%A8%8B%E7%8A%B6%E5%86%B5%E5%B7%A5%E5%85%B7"}},[a._v("1、 jps:jvm进程状况工具")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#2%E3%80%81jstat-jvm%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7"}},[a._v("2、jstat: jvm统计信息监控工具")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#3%E3%80%81jinfo%EF%BC%9A-java%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"}},[a._v("3、jinfo： java配置信息")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#4%E3%80%81jmap-java-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%B7%A5%E5%85%B7"}},[a._v("4、jmap: java 内存映射工具")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#5%E3%80%81jhatjvm%E5%A0%86%E5%BF%AB%E7%85%A7%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"}},[a._v("5、jhat:jvm堆快照分析工具")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#6%E3%80%81jstackjava%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AA%E5%B7%A5%E5%85%B7"}},[a._v("6、jstack:java堆栈跟踪工具")])])])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E4%BA%8C%E3%80%81%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7"}},[a._v("二、可视化工具")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E4%B8%89%E3%80%81%E5%BA%94%E7%94%A8"}},[a._v("三、应用")]),a._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#1%E3%80%81cpu%E9%A3%99%E5%8D%87"}},[a._v("1、cpu飙升")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#2%E3%80%81%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"}},[a._v("2、线程死锁")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#2%E6%9F%A5%E7%9C%8Bjava%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%BF%AB%E7%85%A7%E4%BF%A1%E6%81%AF"}},[a._v("2.查看java进程的线程快照信息")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#3%E3%80%81oom%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"}},[a._v("3、OOM内存泄露")])])])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"}},[a._v("参考文章")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7"}},[a._v("微信公众号")]),a._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96"}},[a._v("Java技术江湖")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E4%B8%AA%E4%BA%BA%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%BB%84%E5%B0%8F%E6%96%9C"}},[a._v("个人公众号：黄小斜")])])])])]),a._v(" "),s("p",[a._v("本文转自：https://juejin.im/post/59e6c1f26fb9a0451c397a8c")]),a._v(" "),s("p",[a._v("本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看")]),a._v(" "),s("blockquote",[s("p",[a._v("https://github.com/h2pl/Java-Tutorial")])]),a._v(" "),s("p",[a._v("喜欢的话麻烦点下Star哈")]),a._v(" "),s("p",[a._v("文章将同步到我的个人博客：")]),a._v(" "),s("blockquote",[s("p",[a._v("www.how2playlife.com")])]),a._v(" "),s("p",[a._v("本文是微信公众号【Java技术江湖】的《深入理解JVM虚拟机》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。")]),a._v(" "),s("p",[a._v("该系列博文会告诉你如何从入门到进阶，一步步地学习JVM基础知识，并上手进行JVM调优实战，JVM是每一个Java工程师必须要学习和理解的知识点，你必须要掌握其实现原理，才能更完整地了解整个Java技术体系，形成自己的知识框架。")]),a._v(" "),s("p",[a._v("为了更好地总结和检验你的学习成果，本系列文章也会提供每个知识点对应的面试题以及参考答案。")]),a._v(" "),s("p",[a._v("如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。")]),a._v(" "),s("p",[a._v("在常见的线上问题时候，我们多数会遇到以下问题：")]),a._v(" "),s("blockquote",[s("ul",[s("li",[a._v("内存泄露")]),a._v(" "),s("li",[a._v("某个进程突然cpu飙升")]),a._v(" "),s("li",[a._v("线程死锁")]),a._v(" "),s("li",[a._v("响应变慢...等等其他问题。")])])]),a._v(" "),s("p",[a._v("如果遇到了以上这种问题，在线下可以有各种本地工具支持查看，但到线上了，就没有这么多的本地调试工具支持，我们该如何基于监控工具来进行定位问题?")]),a._v(" "),s("p",[a._v("我们一般会基于数据收集来定位，而数据的收集离不开监控工具的处理，比如：运行日志、异常堆栈、GC日志、线程快照、堆快照等。经常使用恰当的分析和监控工具可以加快我们的分析数据、定位解决问题的速度。以下我们将会详细介绍。")]),a._v(" "),s("h2",{attrs:{id:"一、jvm常见监控工具-指令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、jvm常见监控工具-指令"}},[a._v("#")]),a._v(" 一、jvm常见监控工具&指令")]),a._v(" "),s("h3",{attrs:{id:"_1、-jps-jvm进程状况工具"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、-jps-jvm进程状况工具"}},[a._v("#")]),a._v(" 1、 jps:jvm进程状况工具")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("jps [options] [hostid]复制代码\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("如果不指定hostid就默认为当前主机或服务器。")]),a._v(" "),s("p",[a._v("命令行参数选项说明如下：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("-q 不输出类名、Jar名和传入main方法的参数\n\n- l 输出main类或Jar的全限名\n\n-m 输出传入main方法的参数\n\n- v 输出传入JVM的参数复制代码\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br")])]),s("h3",{attrs:{id:"_2、jstat-jvm统计信息监控工具"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、jstat-jvm统计信息监控工具"}},[a._v("#")]),a._v(" 2、jstat: jvm统计信息监控工具")]),a._v(" "),s("p",[a._v("jstat 是用于见识虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、jit编译等运行数据，它是线上定位jvm性能的首选工具。")]),a._v(" "),s("p",[a._v("命令格式:")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("jstat [ generalOption | outputOptions vmid [interval[s|ms] [count]] ]\n\ngeneralOption - 单个的常用的命令行选项，如-help, -options, 或 -version。\n\noutputOptions -一个或多个输出选项，由单个的statOption选项组成，可以和-t, -h, and -J等选项配合使用。复制代码\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br")])]),s("p",[a._v("参数选项：")]),a._v(" "),s("table",[s("thead",[s("tr",[s("th",[a._v("Option")]),a._v(" "),s("th",[a._v("Displays")]),a._v(" "),s("th",[a._v("Ex")])])]),a._v(" "),s("tbody",[s("tr",[s("td",[s("a",{attrs:{href:"http://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html#class_option",target:"_blank",rel:"noopener noreferrer"}},[a._v("class"),s("OutboundLink")],1)]),a._v(" "),s("td",[a._v("用于查看类加载情况的统计")]),a._v(" "),s("td",[a._v("jstat -class pid:显示加载class的数量，及所占空间等信息。")])]),a._v(" "),s("tr",[s("td",[s("a",{attrs:{href:"http://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html#compiler_option",target:"_blank",rel:"noopener noreferrer"}},[a._v("compiler"),s("OutboundLink")],1)]),a._v(" "),s("td",[a._v("查看HotSpot中即时编译器编译情况的统计")]),a._v(" "),s("td",[a._v("jstat -compiler pid:显示VM实时编译的数量等信息。")])]),a._v(" "),s("tr",[s("td",[s("a",{attrs:{href:"http://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html#gc_option",target:"_blank",rel:"noopener noreferrer"}},[a._v("gc"),s("OutboundLink")],1)]),a._v(" "),s("td",[a._v("查看JVM中堆的垃圾收集情况的统计")]),a._v(" "),s("td",[a._v("jstat -gc pid:可以显示gc的信息，查看gc的次数，及时间。其中最后五项，分别是young gc的次数，young gc的时间，full gc的次数，full gc的时间，gc的总时间。")])]),a._v(" "),s("tr",[s("td",[s("a",{attrs:{href:"http://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html#gccapacity_option",target:"_blank",rel:"noopener noreferrer"}},[a._v("gccapacity"),s("OutboundLink")],1)]),a._v(" "),s("td",[a._v("查看新生代、老生代及持久代的存储容量情况")]),a._v(" "),s("td",[a._v("jstat -gccapacity:可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小")])]),a._v(" "),s("tr",[s("td",[s("a",{attrs:{href:"http://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html#gccause_option",target:"_blank",rel:"noopener noreferrer"}},[a._v("gccause"),s("OutboundLink")],1)]),a._v(" "),s("td",[a._v("查看垃圾收集的统计情况（这个和-gcutil选项一样），如果有发生垃圾收集，它还会显示最后一次及当前正在发生垃圾收集的原因。")]),a._v(" "),s("td",[a._v("jstat -gccause:显示gc原因")])]),a._v(" "),s("tr",[s("td",[s("a",{attrs:{href:"http://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html#gcnew_option",target:"_blank",rel:"noopener noreferrer"}},[a._v("gcnew"),s("OutboundLink")],1)]),a._v(" "),s("td",[a._v("查看新生代垃圾收集的情况")]),a._v(" "),s("td",[a._v("jstat -gcnew pid:new对象的信息")])]),a._v(" "),s("tr",[s("td",[s("a",{attrs:{href:"http://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html#gcnewcapacity_option",target:"_blank",rel:"noopener noreferrer"}},[a._v("gcnewcapacity"),s("OutboundLink")],1)]),a._v(" "),s("td",[a._v("用于查看新生代的存储容量情况")]),a._v(" "),s("td",[a._v("jstat -gcnewcapacity pid:new对象的信息及其占用量")])]),a._v(" "),s("tr",[s("td",[s("a",{attrs:{href:"http://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html#gcold_option",target:"_blank",rel:"noopener noreferrer"}},[a._v("gcold"),s("OutboundLink")],1)]),a._v(" "),s("td",[a._v("用于查看老生代及持久代发生GC的情况")]),a._v(" "),s("td",[a._v("jstat -gcold pid:old对象的信息")])]),a._v(" "),s("tr",[s("td",[s("a",{attrs:{href:"http://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html#gcoldcapacity_option",target:"_blank",rel:"noopener noreferrer"}},[a._v("gcoldcapacity"),s("OutboundLink")],1)]),a._v(" "),s("td",[a._v("用于查看老生代的容量")]),a._v(" "),s("td",[a._v("jstat -gcoldcapacity pid:old对象的信息及其占用量")])]),a._v(" "),s("tr",[s("td",[s("a",{attrs:{href:"http://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html#gcpermcapacity_option",target:"_blank",rel:"noopener noreferrer"}},[a._v("gcpermcapacity"),s("OutboundLink")],1)]),a._v(" "),s("td",[a._v("用于查看持久代的容量")]),a._v(" "),s("td",[a._v("jstat -gcpermcapacity pid: perm对象的信息及其占用量")])]),a._v(" "),s("tr",[s("td",[s("a",{attrs:{href:"http://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html#gcutil_option",target:"_blank",rel:"noopener noreferrer"}},[a._v("gcutil"),s("OutboundLink")],1)]),a._v(" "),s("td",[a._v("查看新生代、老生代及持代垃圾收集的情况")]),a._v(" "),s("td",[a._v("jstat -util pid:统计gc信息统计")])]),a._v(" "),s("tr",[s("td",[s("a",{attrs:{href:"http://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html#printcompilation_option",target:"_blank",rel:"noopener noreferrer"}},[a._v("printcompilation"),s("OutboundLink")],1)]),a._v(" "),s("td",[a._v("HotSpot编译方法的统计")]),a._v(" "),s("td",[a._v("jstat -printcompilation pid:当前VM执行的信息")])])])]),a._v(" "),s("p",[s("strong",[a._v("例如")]),a._v(":")]),a._v(" "),s("p",[a._v("查看gc 情况执行:jstat-gcutil 27777")]),a._v(" "),s("p",[a._v('![](data:image/svg+xml;utf8,<?xml version="1.0"?>'),s("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",version:"1.1",width:"800",height:"600"}}),a._v(")")]),a._v(" "),s("h3",{attrs:{id:"_3、jinfo-java配置信息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、jinfo-java配置信息"}},[a._v("#")]),a._v(" 3、jinfo： java配置信息")]),a._v(" "),s("p",[a._v("命令格式:")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("jinfo[option] pid复制代码\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("比如:获取一些当前进程的jvm运行和启动信息。")]),a._v(" "),s("p",[a._v('![](data:image/svg+xml;utf8,<?xml version="1.0"?>'),s("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",version:"1.1",width:"800",height:"600"}}),a._v(")")]),a._v(" "),s("h3",{attrs:{id:"_4、jmap-java-内存映射工具"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4、jmap-java-内存映射工具"}},[a._v("#")]),a._v(" 4、jmap: java 内存映射工具")]),a._v(" "),s("p",[a._v("jmap命令用于生产堆转存快照。打印出某个java进程（使用pid）内存内的，所有‘对象’的情况（如：产生那些对象，及其数量）。")]),a._v(" "),s("p",[a._v("命令格式：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("jmap [ option ] pid\n\njmap [ option ] executable core\n\njmap [ option ] [server-id@]remote-hostname-or-IP复制代码\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br")])]),s("p",[a._v("参数选项：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("-dump:[live,]format=b,file=<filename> 使用hprof二进制形式,输出jvm的heap内容到文件=. live子选项是可选的，假如指定live选项,那么只输出活的对象到文件. \n\n-finalizerinfo 打印正等候回收的对象的信息.\n\n-heap 打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况.\n\n-histo[:live] 打印每个class的实例数目,内存占用,类全名信息. VM的内部类名字开头会加上前缀”*”. 如果live子参数加上后,只统计活的对象数量. \n\n-permstat 打印classload和jvm heap长久层的信息. 包含每个classloader的名字,活泼性,地址,父classloader和加载的class数量. 另外,内部String的数量和占用内存数也会打印出来. \n\n-F 强迫.在pid没有相应的时候使用-dump或者-histo参数. 在这个模式下,live子参数无效. \n\n-h | -help 打印辅助信息 \n\n-J 传递参数给jmap启动的jvm. 复制代码\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br")])]),s("h3",{attrs:{id:"_5、jhat-jvm堆快照分析工具"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5、jhat-jvm堆快照分析工具"}},[a._v("#")]),a._v(" 5、jhat:jvm堆快照分析工具")]),a._v(" "),s("p",[a._v("jhat 命令与jamp搭配使用，用来分析map生产的堆快存储快照。jhat内置了一个微型http/Html服务器，可以在浏览器找那个查看。不过建议尽量不用，既然有dumpt文件，可以从生产环境拉取下来，然后通过本地可视化工具来分析，这样既减轻了线上服务器压力，有可以分析的足够详尽(比如 MAT/jprofile/visualVm)等。")]),a._v(" "),s("h3",{attrs:{id:"_6、jstack-java堆栈跟踪工具"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6、jstack-java堆栈跟踪工具"}},[a._v("#")]),a._v(" 6、jstack:java堆栈跟踪工具")]),a._v(" "),s("p",[a._v("jstack用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。")]),a._v(" "),s("p",[a._v("命令格式：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("jstack [ option ] pid\n\njstack [ option ] executable core\n\njstack [ option ] [server-id@]remote-hostname-or-IP复制代码\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br")])]),s("p",[a._v("参数：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("-F当’jstack [-l] pid’没有相应的时候强制打印栈信息\n\n-l长列表. 打印关于锁的附加信息,例如属于java.util.concurrent的ownable synchronizers列表.\n\n-m打印java和native c/c++框架的所有栈信息.\n\n-h | -help打印帮助信息\n\npid 需要被打印配置信息的java进程id,可以用jps查询.复制代码\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br")])]),s("p",[a._v("后续的查找耗费最高cpu例子会用到。")]),a._v(" "),s("h2",{attrs:{id:"二、可视化工具"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、可视化工具"}},[a._v("#")]),a._v(" 二、可视化工具")]),a._v(" "),s("p",[a._v("对jvm监控的常见可视化工具，除了jdk本身提供的Jconsole和visualVm以外，还有第三方提供的jprofilter，perfino,Yourkit，Perf4j，JProbe，MAT等。这些工具都极大的丰富了我们定位以及优化jvm方式。")]),a._v(" "),s("p",[a._v("这些工具的使用，网上有很多教程提供，这里就不再过多介绍了。对于VisualVm来说，比较推荐使用，它除了对jvm的侵入性比较低以外，还是jdk团队自己开发的，相信以后功能会更加丰富和完善。jprofilter对于第三方监控工具，提供的功能和可视化最为完善，目前多数ide都支持其插件，对于上线前的调试以及性能调优可以配合使用。")]),a._v(" "),s("p",[a._v("另外对于线上dump的heap信息，应该尽量拉去到线下用于可视化工具来分析，这样分析更详细。如果对于一些紧急的问题，必须需要通过线上监控，可以采用 VisualVm的远程功能来进行，这需要使用tool.jar下的MAT功能。")]),a._v(" "),s("h2",{attrs:{id:"三、应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、应用"}},[a._v("#")]),a._v(" 三、应用")]),a._v(" "),s("h3",{attrs:{id:"_1、cpu飙升"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、cpu飙升"}},[a._v("#")]),a._v(" 1、cpu飙升")]),a._v(" "),s("p",[a._v("在线上有时候某个时刻，可能会出现应用某个时刻突然cpu飙升的问题。对此我们应该熟悉一些指令，快速排查对应代码。")]),a._v(" "),s("p",[s("strong",[s("em",[a._v("1.找到最耗CPU的进程")])])]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("指令:top复制代码\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[s("strong",[s("em",[a._v("2.找到该进程下最耗费cpu的线程")])])]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("指令:top -Hp pid复制代码\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[s("strong",[s("em",[a._v("3.转换进制")])])]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("printf “%x\\n” 15332 // 转换16进制（转换后为0x3be4） 复制代码\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[s("strong",[s("em",[a._v("4.过滤指定线程，打印堆栈信息")])])]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("指令:\njstack pid |grep 'threadPid'  -C5 --color \n\njstack 13525 |grep '0x3be4'  -C5 --color  //  打印进程堆栈 并通过线程id，过滤得到线程堆栈信息。复制代码\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("p",[a._v("可以看到是一个上报程序，占用过多cpu了（以上例子只为示例，本身耗费cpu并不高）")]),a._v(" "),s("h3",{attrs:{id:"_2、线程死锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、线程死锁"}},[a._v("#")]),a._v(" 2、线程死锁")]),a._v(" "),s("p",[a._v("有时候部署场景会有线程死锁的问题发生，但又不常见。此时我们采用jstack查看下一下。比如说我们现在已经有一个线程死锁的程序，导致某些操作waiting中。")]),a._v(" "),s("p",[s("strong",[s("em",[a._v("1.查找java进程id")])])]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("指令:top 或者 jps 复制代码\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("h3",{attrs:{id:"_2-查看java进程的线程快照信息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-查看java进程的线程快照信息"}},[a._v("#")]),a._v(" 2.查看java进程的线程快照信息")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("指令：jstack -l pid复制代码\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("从输出信息可以看到，有一个线程死锁发生，并且指出了那行代码出现的。如此可以快速排查问题。")]),a._v(" "),s("h3",{attrs:{id:"_3、oom内存泄露"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、oom内存泄露"}},[a._v("#")]),a._v(" 3、OOM内存泄露")]),a._v(" "),s("p",[a._v("java堆内的OOM异常是实际应用中常见的内存溢出异常。一般我们都是先通过内存映射分析工具（比如MAT）对dump出来的堆转存快照进行分析，确认内存中对象是否出现问题。")]),a._v(" "),s("p",[a._v("当然了出现OOM的原因有很多，并非是堆中申请资源不足一种情况。还有可能是申请太多资源没有释放，或者是频繁频繁申请，系统资源耗尽。针对这三种情况我需要一一排查。")]),a._v(" "),s("p",[a._v("OOM的三种情况:")]),a._v(" "),s("blockquote",[s("p",[a._v("1.申请资源（内存）过小，不够用。")]),a._v(" "),s("p",[a._v("2.申请资源太多，没有释放。")]),a._v(" "),s("p",[a._v("3.申请资源过多，资源耗尽。比如：线程过多，线程内存过大等。")])]),a._v(" "),s("p",[s("strong",[a._v("1.排查申请申请资源问题。")])]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("指令:jmap -heap 11869 复制代码\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("查看新生代，老生代堆内存的分配大小以及使用情况，看是否本身分配过小。")]),a._v(" "),s("p",[a._v("从上述排查，发现程序申请的内存没有问题。")]),a._v(" "),s("p",[s("strong",[a._v("2.排查gc")])]),a._v(" "),s("p",[a._v("特别是fgc情况下，各个分代内存情况。")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("指令:jstat -gcutil 11938 1000 每秒输出一次gc的分代内存分配情况，以及gc时间复制代码\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[s("strong",[a._v("3.查找最费内存的对象")])]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("指令: jmap -histo:live 11869 | more复制代码\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("上述输出信息中，最大内存对象才161kb,属于正常范围。如果某个对象占用空间很大，比如超过了100Mb，应该着重分析，为何没有释放。")]),a._v(" "),s("p",[a._v("注意，上述指令:")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("jmap -histo:live 11869 | more\n\n执行之后，会造成jvm强制执行一次fgc，在线上不推荐使用，可以采取dump内存快照，线下采用可视化工具进行分析，更加详尽。\n\njmap -dump:format=b,file=/tmp/dump.dat 11869 \n\n或者采用线上运维工具，自动化处理，方便快速定位，遗失出错时间。复制代码\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br")])]),s("p",[s("strong",[a._v("4.确认资源是否耗尽")])]),a._v(" "),s("blockquote",[s("ul",[s("li",[a._v("pstree 查看进程线程数量")]),a._v(" "),s("li",[a._v("netstat 查看网络连接数量")])])]),a._v(" "),s("p",[a._v("或者采用:")]),a._v(" "),s("blockquote",[s("ul",[s("li",[a._v("ll /proc/${PID}/fd | wc -l // 打开的句柄数")]),a._v(" "),s("li",[a._v("ll /proc/${PID}/task | wc -l （效果等同pstree -p | wc -l） //打开的线程数")])])]),a._v(" "),s("p",[a._v("以上就是一些常见的jvm命令应用。")]),a._v(" "),s("p",[a._v("一种工具的应用并非是万能钥匙，包治百病，问题的解决往往是需要多种工具的结合才能更好的定位问题，无论使用何种分析工具，最重要的是熟悉每种工具的优势和劣势。这样才能取长补短，配合使用。")]),a._v(" "),s("h2",{attrs:{id:"参考文章"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[a._v("#")]),a._v(" 参考文章")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://segmentfault.com/a/1190000009707894",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://segmentfault.com/a/1190000009707894"),s("OutboundLink")],1)]),a._v(" "),s("p",[s("a",{attrs:{href:"https://www.cnblogs.com/hysum/p/7100874.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://www.cnblogs.com/hysum/p/7100874.html"),s("OutboundLink")],1)]),a._v(" "),s("p",[s("a",{attrs:{href:"http://c.biancheng.net/view/939.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("http://c.biancheng.net/view/939.html"),s("OutboundLink")],1)]),a._v(" "),s("p",[s("a",{attrs:{href:"https://www.runoob.com/",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://www.runoob.com/"),s("OutboundLink")],1)]),a._v(" "),s("p",[a._v("https://blog.csdn.net/android_hl/article/details/53228348")]),a._v(" "),s("h2",{attrs:{id:"微信公众号"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#微信公众号"}},[a._v("#")]),a._v(" 微信公众号")]),a._v(" "),s("h3",{attrs:{id:"java技术江湖"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java技术江湖"}},[a._v("#")]),a._v(" Java技术江湖")]),a._v(" "),s("p",[a._v("如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，作者黄小斜，专注 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！")]),a._v(" "),s("p",[s("strong",[a._v("Java工程师必备学习资源:")]),a._v(" 一些Java工程师常用学习资源，关注公众号后，后台回复关键字 "),s("strong",[a._v("“Java”")]),a._v(" 即可免费无套路获取。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190805090108984.jpg",alt:"我的公众号"}})]),a._v(" "),s("h3",{attrs:{id:"个人公众号-黄小斜"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#个人公众号-黄小斜"}},[a._v("#")]),a._v(" 个人公众号：黄小斜")]),a._v(" "),s("p",[a._v("作者是 985 硕士，蚂蚁金服 JAVA 工程师，专注于 JAVA 后端技术栈：SpringBoot、MySQL、分布式、中间件、微服务，同时也懂点投资理财，偶尔讲点算法和计算机理论基础，坚持学习和写作，相信终身学习的力量！")]),a._v(" "),s("p",[s("strong",[a._v("程序员3T技术学习资源：")]),a._v(" 一些程序员学习技术的资源大礼包，关注公众号后，后台回复关键字 "),s("strong",[a._v("“资料”")]),a._v(" 即可免费无套路获取。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190829222750556.jpg",alt:""}})])])}),[],!1,null,null,null);t.default=r.exports}}]);