(window.webpackJsonp=window.webpackJsonp||[]).push([[508],{897:function(t,a,r){"use strict";r.r(a);var e=r(13),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"集合"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#集合"}},[t._v("#")]),t._v(" 集合")]),t._v(" "),r("h3",{attrs:{id:"arraylist与linkedlist区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#arraylist与linkedlist区别"}},[t._v("#")]),t._v(" ArrayList与LinkedList区别")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("ArrayList")]),t._v(" "),r("th",[t._v("LinkedList")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("数组")]),t._v(" "),r("td",[t._v("双向链表")])]),t._v(" "),r("tr",[r("td",[t._v("增删的时候在扩容的时候慢，通过索引查询快，通过对象查索引慢")]),t._v(" "),r("td",[t._v("增删快，通过索引查询慢，通过对象查索引慢")])]),t._v(" "),r("tr",[r("td",[t._v("当数组无法容纳下此次添加的元素时进行扩容")]),t._v(" "),r("td",[t._v("无")])]),t._v(" "),r("tr",[r("td",[t._v("扩容之后容量为原来的1.5倍")]),t._v(" "),r("td",[t._v("无")])])])]),t._v(" "),r("h3",{attrs:{id:"hashmap"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[t._v("#")]),t._v(" HashMap")]),t._v(" "),r("ol",[r("li",[t._v("JDK 1.8 以前 HashMap 的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了它的优势。针对这种情况，JDK 1.8 中引入了红黑树（查找时间复杂度为 O(logn)）来优化这个问题")]),t._v(" "),r("li",[t._v("为什么线程不安全？多线程PUT操作时可能会覆盖刚PUT进去的值；扩容操作会让链表形成环形数据结构，形成死循环")]),t._v(" "),r("li",[t._v("容量的默认大小是 16，负载因子是 0.75，当 HashMap 的 size > 16*0.75 时就会发生扩容(容量和负载因子都可以自由调整)。")]),t._v(" "),r("li",[t._v("为什么容量是2的倍数？在根据hashcode查找数组中元素时，取模性能远远低于与性能，且和2^n-1进行与操作能保证各种不同的hashcode对应的元素也能均匀分布在数组中")])]),t._v(" "),r("h3",{attrs:{id:"concurrenthashmap原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap原理"}},[t._v("#")]),t._v(" ConcurrentHashMap原理")]),t._v(" "),r("p",[r("a",{attrs:{href:"http://www.jasongj.com/java/concurrenthashmap/",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://www.jasongj.com/java/concurrenthashmap/"),r("OutboundLink")],1)]),t._v(" "),r("p",[t._v("HashTable 在每次同步执行时都要锁住整个结构。ConcurrentHashMap 锁的方式是稍微细粒度的。 ConcurrentHashMap 将 hash 表分为 16 个桶（默认值）"),r("br"),t._v("\n最大并发个数就是Segment的个数，默认值是16，可以通过构造函数改变一经创建不可更改，这个值就是并发的粒度，每一个segment下面管理一个table数组，加锁的时候其实锁住的是整个segment")]),t._v(" "),r("h4",{attrs:{id:"java7"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java7"}},[t._v("#")]),t._v(" Java7")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://txxs.github.io/pic/javainterview/j3.jpg",alt:""}})]),t._v(" "),r("p",[t._v("ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封装映射表的键 / 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。")]),t._v(" "),r("h4",{attrs:{id:"java8"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java8"}},[t._v("#")]),t._v(" Java8")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://txxs.github.io/pic/javainterview/j4.jpg",alt:""}})]),t._v(" "),r("ol",[r("li",[t._v("为进一步提高并发性，放弃了分段锁，锁的级别控制在了更细粒度的table元素级别，也就是说只需要锁住这个链表的head节点，并不会影响其他的table元素的读写，好处在于并发的粒度更细，影响更小，从而并发效率更好")]),t._v(" "),r("li",[t._v("使用CAS + synchronized 来保证实现put操作：如果Key对应的数组元素为null，则通过CAS操作将其设置为当前值。如果Key对应的数组元素（也即链表表头或者树的根元素）不为null，则对该元素使用synchronized关键字申请锁，然后进行操作。如果该put操作使得当前链表长度超过一定阈值，则将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(log(N))，插入操作完成之后如果所有元素的数量大于当前容量（默认16）*负载因子（默认0.75）就进行扩容。")])]),t._v(" "),r("p",[t._v("欢迎光临"),r("a",{attrs:{href:"http://www.wangtianyi.top/?utm_source=github&utm_medium=github",target:"_blank",rel:"noopener noreferrer"}},[t._v("我的博客"),r("OutboundLink")],1),t._v("，发现更多技术资源~")])])}),[],!1,null,null,null);a.default=s.exports}}]);