(window.webpackJsonp=window.webpackJsonp||[]).push([[564],{960:function(n,a,i){"use strict";i.r(a);var t=i(13),l=Object(t.a)({},(function(){var n=this,a=n.$createElement,i=n._self._c||a;return i("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[i("h1",{attrs:{id:"目录"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[n._v("#")]),n._v(" 目录")]),n._v(" "),i("ul",[i("li",[i("a",{attrs:{href:"#final%E4%BD%BF%E7%94%A8"}},[n._v("final使用")]),n._v(" "),i("ul",[i("li",[i("a",{attrs:{href:"#final%E5%8F%98%E9%87%8F"}},[n._v("final变量")])]),n._v(" "),i("li",[i("a",{attrs:{href:"#final%E4%BF%AE%E9%A5%B0%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E5%92%8C%E5%BC%95%E7%94%A8"}},[n._v("final修饰基本数据类型变量和引用")])]),n._v(" "),i("li",[i("a",{attrs:{href:"#final%E7%B1%BB"}},[n._v("final类")])]),n._v(" "),i("li",[i("a",{attrs:{href:"#final%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9"}},[n._v("final关键字的知识点")])])])]),n._v(" "),i("li",[i("a",{attrs:{href:"#final%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"}},[n._v("final关键字的最佳实践")]),n._v(" "),i("ul",[i("li",[i("a",{attrs:{href:"#final%E7%9A%84%E7%94%A8%E6%B3%95"}},[n._v("final的用法")])]),n._v(" "),i("li",[i("a",{attrs:{href:"#%E5%85%B3%E4%BA%8E%E7%A9%BA%E7%99%BDfinal"}},[n._v("关于空白final")])]),n._v(" "),i("li",[i("a",{attrs:{href:"#final%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"}},[n._v("final内存分配")])]),n._v(" "),i("li",[i("a",{attrs:{href:"#%E4%BD%BF%E7%94%A8final%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95%E4%BC%9A%E6%8F%90%E9%AB%98%E9%80%9F%E5%BA%A6%E5%92%8C%E6%95%88%E7%8E%87%E5%90%97"}},[n._v("使用final修饰方法会提高速度和效率吗")])]),n._v(" "),i("li",[i("a",{attrs:{href:"#%E4%BD%BF%E7%94%A8final%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%E4%BC%9A%E8%AE%A9%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%E4%B8%8D%E8%83%BD%E8%A2%AB%E6%94%B9%E5%8F%98%E5%90%97%EF%BC%9B"}},[n._v("使用final修饰变量会让变量的值不能被改变吗；")])]),n._v(" "),i("li",[i("a",{attrs:{href:"#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E7%BB%84%E5%86%85%E9%83%A8%E4%B8%8D%E8%A2%AB%E4%BF%AE%E6%94%B9"}},[n._v("如何保证数组内部不被修改")])]),n._v(" "),i("li",[i("a",{attrs:{href:"#final%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%89%E6%9D%A1%E8%A7%84%E5%88%99"}},[n._v("final方法的三条规则")])])])]),n._v(" "),i("li",[i("a",{attrs:{href:"#final-%E5%92%8C-jvm%E7%9A%84%E5%85%B3%E7%B3%BB"}},[n._v("final 和 jvm的关系")]),n._v(" "),i("ul",[i("li",[i("a",{attrs:{href:"#%E5%86%99-final-%E5%9F%9F%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99"}},[n._v("写 final 域的重排序规则")])]),n._v(" "),i("li",[i("a",{attrs:{href:"#%E8%AF%BB-final-%E5%9F%9F%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99"}},[n._v("读 final 域的重排序规则")])]),n._v(" "),i("li",[i("a",{attrs:{href:"#%E5%A6%82%E6%9E%9C-final-%E5%9F%9F%E6%98%AF%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"}},[n._v("如果 final 域是引用类型")])])])]),n._v(" "),i("li",[i("a",{attrs:{href:"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"}},[n._v("参考文章")])]),n._v(" "),i("li",[i("a",{attrs:{href:"#%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7"}},[n._v("微信公众号")]),n._v(" "),i("ul",[i("li",[i("a",{attrs:{href:"#java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96"}},[n._v("Java技术江湖")])]),n._v(" "),i("li",[i("a",{attrs:{href:"#%E4%B8%AA%E4%BA%BA%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%BB%84%E5%B0%8F%E6%96%9C"}},[n._v("个人公众号：黄小斜")])])])])]),n._v(" "),i("p",[n._v("本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看")]),n._v(" "),i("blockquote",[i("p",[n._v("https://github.com/h2pl/Java-Tutorial")])]),n._v(" "),i("p",[n._v("喜欢的话麻烦点下Star哈")]),n._v(" "),i("p",[n._v("文章首发于我的个人博客：")]),n._v(" "),i("blockquote",[i("p",[n._v("www.how2playlife.com")])]),n._v(" "),i("p",[n._v("本文是微信公众号【Java技术江湖】的《夯实Java基础系列博文》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。\n该系列博文会告诉你如何从入门到进阶，一步步地学习Java基础知识，并上手进行实战，接着了解每个Java知识点背后的实现原理，更完整地了解整个Java技术体系，形成自己的知识框架。为了更好地总结和检验你的学习成果，本系列文章也会提供每个知识点对应的面试题以及参考答案。")]),n._v(" "),i("p",[n._v("如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。")]),n._v(" "),i("p",[n._v("final关键字在java中使用非常广泛，可以申明成员变量、方法、类、本地变量。一旦将引用声明为final，将无法再改变这个引用。final关键字还能保证内存同步，本博客将会从final关键字的特性到从java内存层面保证同步讲解。这个内容在面试中也有可能会出现。")]),n._v(" "),i("h2",{attrs:{id:"final使用"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#final使用"}},[n._v("#")]),n._v(" final使用")]),n._v(" "),i("h3",{attrs:{id:"final变量"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#final变量"}},[n._v("#")]),n._v(" final变量")]),n._v(" "),i("p",[n._v("final变量有成员变量或者是本地变量(方法内的局部变量)，在类成员中final经常和static一起使用，作为类常量使用。"),i("strong",[n._v("其中类常量必须在声明时初始化，final成员常量可以在构造函数初始化。")])]),n._v(" "),i("div",{staticClass:"language- line-numbers-mode"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("public class Main {\n    public static final int i; //报错，必须初始化 因为常量在常量池中就存在了，调用时不需要类的初始化，所以必须在声明时初始化\n    public static final int j;\n    Main() {\n        i = 2;\n        j = 3;\n    }\n}\n\n")])]),n._v(" "),i("div",{staticClass:"line-numbers-wrapper"},[i("span",{staticClass:"line-number"},[n._v("1")]),i("br"),i("span",{staticClass:"line-number"},[n._v("2")]),i("br"),i("span",{staticClass:"line-number"},[n._v("3")]),i("br"),i("span",{staticClass:"line-number"},[n._v("4")]),i("br"),i("span",{staticClass:"line-number"},[n._v("5")]),i("br"),i("span",{staticClass:"line-number"},[n._v("6")]),i("br"),i("span",{staticClass:"line-number"},[n._v("7")]),i("br"),i("span",{staticClass:"line-number"},[n._v("8")]),i("br"),i("span",{staticClass:"line-number"},[n._v("9")]),i("br")])]),i("p",[n._v("就如上所说的，对于类常量，JVM会缓存在常量池中，在读取该变量时不会加载这个类。")]),n._v(" "),i("div",{staticClass:"language- line-numbers-mode"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v('\npublic class Main {\n    public static final int i = 2;\n    Main() {\n        System.out.println("调用构造函数"); // 该方法不会调用\n    }\n    public static void main(String[] args) {\n        System.out.println(Main.i);\n    }\n}\n\n')])]),n._v(" "),i("div",{staticClass:"line-numbers-wrapper"},[i("span",{staticClass:"line-number"},[n._v("1")]),i("br"),i("span",{staticClass:"line-number"},[n._v("2")]),i("br"),i("span",{staticClass:"line-number"},[n._v("3")]),i("br"),i("span",{staticClass:"line-number"},[n._v("4")]),i("br"),i("span",{staticClass:"line-number"},[n._v("5")]),i("br"),i("span",{staticClass:"line-number"},[n._v("6")]),i("br"),i("span",{staticClass:"line-number"},[n._v("7")]),i("br"),i("span",{staticClass:"line-number"},[n._v("8")]),i("br"),i("span",{staticClass:"line-number"},[n._v("9")]),i("br"),i("span",{staticClass:"line-number"},[n._v("10")]),i("br"),i("span",{staticClass:"line-number"},[n._v("11")]),i("br")])]),i("h3",{attrs:{id:"final修饰基本数据类型变量和引用"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#final修饰基本数据类型变量和引用"}},[n._v("#")]),n._v(" final修饰基本数据类型变量和引用")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[n._v('@Test\npublic void final修饰基本类型变量和引用() {\n    final int a = 1;\n    final int[] b = {1};\n    final int[] c = {1};\n//  b = c;报错\n    b[0] = 1;\n    final String aa = "a";\n    final Fi f = new Fi();\n    //aa = "b";报错\n    // f = null;//报错\n    f.a = 1;\n}\n')])])]),i("p",[n._v("final方法表示该方法不能被子类的方法重写，将方法声明为final，在编译的时候就已经静态绑定了，不需要在运行时动态绑定。final方法调用时使用的是invokespecial指令。")]),n._v(" "),i("div",{staticClass:"language- line-numbers-mode"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v('class PersonalLoan{\n    public final String getName(){\n        return"personal loan”;\n    }\n}\n\nclass CheapPersonalLoan extends PersonalLoan{\n    @Override\n    public final String getName(){\n        return"cheap personal loan";//编译错误，无法被重载\n    }\n\n    public String test() {\n        return getName(); //可以调用，因为是public方法\n    }\n}\n\n')])]),n._v(" "),i("div",{staticClass:"line-numbers-wrapper"},[i("span",{staticClass:"line-number"},[n._v("1")]),i("br"),i("span",{staticClass:"line-number"},[n._v("2")]),i("br"),i("span",{staticClass:"line-number"},[n._v("3")]),i("br"),i("span",{staticClass:"line-number"},[n._v("4")]),i("br"),i("span",{staticClass:"line-number"},[n._v("5")]),i("br"),i("span",{staticClass:"line-number"},[n._v("6")]),i("br"),i("span",{staticClass:"line-number"},[n._v("7")]),i("br"),i("span",{staticClass:"line-number"},[n._v("8")]),i("br"),i("span",{staticClass:"line-number"},[n._v("9")]),i("br"),i("span",{staticClass:"line-number"},[n._v("10")]),i("br"),i("span",{staticClass:"line-number"},[n._v("11")]),i("br"),i("span",{staticClass:"line-number"},[n._v("12")]),i("br"),i("span",{staticClass:"line-number"},[n._v("13")]),i("br"),i("span",{staticClass:"line-number"},[n._v("14")]),i("br"),i("span",{staticClass:"line-number"},[n._v("15")]),i("br"),i("span",{staticClass:"line-number"},[n._v("16")]),i("br"),i("span",{staticClass:"line-number"},[n._v("17")]),i("br")])]),i("h3",{attrs:{id:"final类"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#final类"}},[n._v("#")]),n._v(" final类")]),n._v(" "),i("p",[n._v("final类不能被继承，final类中的方法默认也会是final类型的，java中的String类和Integer类都是final类型的。")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[n._v("class Si{\n    //一般情况下final修饰的变量一定要被初始化。\n    //只有下面这种情况例外，要求该变量必须在构造方法中被初始化。\n    //并且不能有空参数的构造方法。\n    //这样就可以让每个实例都有一个不同的变量，并且这个变量在每个实例中只会被初始化一次\n    //于是这个变量在单个实例里就是常量了。\n    final int s ;\n    Si(int s) {\n        this.s = s;\n    }\n}\nclass Bi {\n    final int a = 1;\n    final void go() {\n        //final修饰方法无法被继承\n    }\n}\nclass Ci extends Bi {\n    final int a = 1;\n//        void go() {\n//            //final修饰方法无法被继承\n//        }\n}\nfinal char[]a = {'a'};\nfinal int[]b = {1};\n")])])]),i("div",{staticClass:"language- line-numbers-mode"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("final class PersonalLoan{}\n\nclass CheapPersonalLoan extends PersonalLoan {  //编译错误，无法被继承 \n}\n\n")])]),n._v(" "),i("div",{staticClass:"line-numbers-wrapper"},[i("span",{staticClass:"line-number"},[n._v("1")]),i("br"),i("span",{staticClass:"line-number"},[n._v("2")]),i("br"),i("span",{staticClass:"line-number"},[n._v("3")]),i("br"),i("span",{staticClass:"line-number"},[n._v("4")]),i("br"),i("span",{staticClass:"line-number"},[n._v("5")]),i("br")])]),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[n._v("@Test\npublic void final修饰类() {\n    //引用没有被final修饰，所以是可变的。\n    //final只修饰了Fi类型，即Fi实例化的对象在堆中内存地址是不可变的。\n    //虽然内存地址不可变，但是可以对内部的数据做改变。\n    Fi f = new Fi();\n    f.a = 1;\n    System.out.println(f);\n    f.a = 2;\n    System.out.println(f);\n    //改变实例中的值并不改变内存地址。\n\n    Fi ff = f;\n    //让引用指向新的Fi对象，原来的f对象由新的引用ff持有。\n    //引用的指向改变也不会改变原来对象的地址\n    f = new Fi();\n    System.out.println(f);\n    System.out.println(ff);\n}\n")])])]),i("h3",{attrs:{id:"final关键字的知识点"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#final关键字的知识点"}},[n._v("#")]),n._v(" final关键字的知识点")]),n._v(" "),i("ol",[i("li",[n._v("final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。final变量一旦被初始化后不能再次赋值。")]),n._v(" "),i("li",[n._v("本地变量必须在声明时赋值。 因为没有初始化的过程")]),n._v(" "),i("li",[n._v("在匿名类中所有变量都必须是final变量。")]),n._v(" "),i("li",[n._v("final方法不能被重写, final类不能被继承")]),n._v(" "),i("li",[n._v("接口中声明的所有变量本身是final的。类似于匿名类")]),n._v(" "),i("li",[n._v("final和abstract这两个关键字是反相关的，final类就不可能是abstract的。")]),n._v(" "),i("li",[n._v("final方法在编译阶段绑定，称为静态绑定(static binding)。")]),n._v(" "),i("li",[n._v("将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。")])]),n._v(" "),i("p",[n._v("final方法的好处:")]),n._v(" "),i("ol",[i("li",[n._v("提高了性能，JVM在常量池中会缓存final变量")]),n._v(" "),i("li",[n._v("final变量在多线程中并发安全，无需额外的同步开销")]),n._v(" "),i("li",[n._v("final方法是静态编译的，提高了调用速度")]),n._v(" "),i("li",[i("strong",[n._v("final类创建的对象是只可读的，在多线程可以安全共享")])]),n._v(" "),i("li")]),n._v(" "),i("h2",{attrs:{id:"final关键字的最佳实践"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#final关键字的最佳实践"}},[n._v("#")]),n._v(" final关键字的最佳实践")]),n._v(" "),i("h3",{attrs:{id:"final的用法"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#final的用法"}},[n._v("#")]),n._v(" final的用法")]),n._v(" "),i("p",[n._v('1、final 对于常量来说，意味着值不能改变，例如 final int i=100。这个i的值永远都是100。\n但是对于变量来说又不一样，只是标识这个引用不可被改变，例如 final File f=new File("c:\\test.txt");')]),n._v(" "),i("p",[n._v("那么这个f一定是不能被改变的，如果f本身有方法修改其中的成员变量，例如是否可读，是允许修改的。有个形象的比喻：一个女子定义了一个final的老公，这个老公的职业和收入都是允许改变的，只是这个女人不会换老公而已。")]),n._v(" "),i("h3",{attrs:{id:"关于空白final"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#关于空白final"}},[n._v("#")]),n._v(" 关于空白final")]),n._v(" "),i("p",[n._v("final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。"),i("br"),n._v("\n　另外，final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。\n　\n但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[n._v("public class FinalTest { \nfinal int p; \nfinal int q=3; \nFinalTest(){ \np=1; \n} \nFinalTest(int i){ \np=i;//可以赋值，相当于直接定义p \nq=i;//不能为一个final变量赋值 \n} \n} \n")])])]),i("h3",{attrs:{id:"final内存分配"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#final内存分配"}},[n._v("#")]),n._v(" final内存分配")]),n._v(" "),i("p",[n._v("刚提到了内嵌机制，现在详细展开。\n要知道调用一个函数除了函数本身的执行时间之外，还需要额外的时间去寻找这个函数（类内部有一个函数签名和函数地址的映射表）。所以减少函数调用次数就等于降低了性能消耗。")]),n._v(" "),i("p",[n._v("final修饰的函数会被编译器优化，优化的结果是减少了函数调用的次数。如何实现的，举个例子给你看：")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[n._v('public class Test{ \nfinal void func(){System.out.println("g");}; \npublic void main(String[] args){ \nfor(int j=0;j<1000;j++)   \nfunc(); \n}} \n经过编译器优化之后，这个类变成了相当于这样写： \npublic class Test{ \nfinal void func(){System.out.println("g");}; \npublic void main(String[] args){ \nfor(int j=0;j<1000;j++)  \n{System.out.println("g");} \n}} \n')])])]),i("p",[n._v("看出来区别了吧？编译器直接将func的函数体内嵌到了调用函数的地方，这样的结果是节省了1000次函数调用，当然编译器处理成字节码，只是我们可以想象成这样，看个明白。")]),n._v(" "),i("p",[n._v("不过，当函数体太长的话，用final可能适得其反，因为经过编译器内嵌之后代码长度大大增加，于是就增加了jvm解释字节码的时间。")]),n._v(" "),i("p",[n._v("在使用final修饰方法的时候，编译器会将被final修饰过的方法插入到调用者代码处，提高运行速度和效率，但被final修饰的方法体不能过大，编译器可能会放弃内联，但究竟多大的方法会放弃，我还没有做测试来计算过。")]),n._v(" "),i("p",[i("strong",[n._v("下面这些内容是通过两个疑问来继续阐述的")])]),n._v(" "),i("h3",{attrs:{id:"使用final修饰方法会提高速度和效率吗"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#使用final修饰方法会提高速度和效率吗"}},[n._v("#")]),n._v(" 使用final修饰方法会提高速度和效率吗")]),n._v(" "),i("p",[n._v("见下面的测试代码，我会执行五次：")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[n._v('public class Test   \n{   \n    public static void getJava()   \n    {   \n        String str1 = "Java ";   \n        String str2 = "final ";   \n        for (int i = 0; i < 10000; i++)   \n        {   \n            str1 += str2;   \n        }   \n    }   \n    public static final void getJava_Final()   \n    {   \n        String str1 = "Java ";   \n        String str2 = "final ";   \n        for (int i = 0; i < 10000; i++)   \n        {   \n            str1 += str2;   \n        }   \n    }   \n    public static void main(String[] args)   \n    {   \n        long start = System.currentTimeMillis();   \n        getJava();   \n        System.out.println("调用不带final修饰的方法执行时间为:" + (System.currentTimeMillis() - start) + "毫秒时间");   \n        start = System.currentTimeMillis();   \n        String str1 = "Java ";   \n        String str2 = "final ";   \n        for (int i = 0; i < 10000; i++)   \n        {   \n            str1 += str2;   \n        }   \n        System.out.println("正常的执行时间为:" + (System.currentTimeMillis() - start) + "毫秒时间");   \n        start = System.currentTimeMillis();   \n        getJava_Final();   \n        System.out.println("调用final修饰的方法执行时间为:" + (System.currentTimeMillis() - start) + "毫秒时间");   \n    }   \n}  \n\n\n结果为： \n第一次： \n调用不带final修饰的方法执行时间为:1732毫秒时间 \n正常的执行时间为:1498毫秒时间 \n调用final修饰的方法执行时间为:1593毫秒时间 \n第二次： \n调用不带final修饰的方法执行时间为:1217毫秒时间 \n正常的执行时间为:1031毫秒时间 \n调用final修饰的方法执行时间为:1124毫秒时间 \n第三次： \n调用不带final修饰的方法执行时间为:1154毫秒时间 \n正常的执行时间为:1140毫秒时间 \n调用final修饰的方法执行时间为:1202毫秒时间 \n第四次： \n调用不带final修饰的方法执行时间为:1139毫秒时间 \n正常的执行时间为:999毫秒时间 \n调用final修饰的方法执行时间为:1092毫秒时间 \n第五次： \n调用不带final修饰的方法执行时间为:1186毫秒时间 \n正常的执行时间为:1030毫秒时间 \n调用final修饰的方法执行时间为:1109毫秒时间 \n\n由以上运行结果不难看出，执行最快的是“正常的执行”即代码直接编写，而使用final修饰的方法，不像有些书上或者文章上所说的那样，速度与效率与“正常的执行”无异，而是位于第二位，最差的是调用不加final修饰的方法。 \n')])])]),i("p",[n._v("观点：加了比不加好一点。")]),n._v(" "),i("h3",{attrs:{id:"使用final修饰变量会让变量的值不能被改变吗"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#使用final修饰变量会让变量的值不能被改变吗"}},[n._v("#")]),n._v(" 使用final修饰变量会让变量的值不能被改变吗；")]),n._v(" "),i("p",[n._v("见代码：")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[n._v('public class Final   \n{   \n    public static void main(String[] args)   \n    {   \n        Color.color[3] = "white";   \n        for (String color : Color.color)   \n            System.out.print(color+" ");   \n    }   \n}   \n  \nclass Color   \n{   \n    public static final String[] color = { "red", "blue", "yellow", "black" };   \n}  \n\n\n执行结果： \nred blue yellow white \n看！，黑色变成了白色。 \n')])])]),i("p",[n._v("​"),i("br"),n._v('\n​    在使用findbugs插件时，就会提示public static String[] color = { "red", "blue", "yellow", "black" };这行代码不安全，但加上final修饰，这行代码仍然是不安全的，因为final没有做到保证变量的值不会被修改！\n​'),i("br"),n._v('\n​    原因是：final关键字只能保证变量本身不能被赋与新值，而不能保证变量的内部结构不被修改。例如在main方法有如下代码Color.color = new String[]{""};就会报错了。')]),n._v(" "),i("h3",{attrs:{id:"如何保证数组内部不被修改"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#如何保证数组内部不被修改"}},[n._v("#")]),n._v(" 如何保证数组内部不被修改")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[n._v("那可能有的同学就会问了，加上final关键字不能保证数组不会被外部修改，那有什么方法能够保证呢？答案就是降低访问级别，把数组设为private。这样的话，就解决了数组在外部被修改的不安全性，但也产生了另一个问题，那就是这个数组要被外部使用的。 \n")])])]),i("p",[n._v("解决这个问题见代码：")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[n._v('import java.util.AbstractList;   \nimport java.util.List;   \n\npublic class Final   \n{   \n    public static void main(String[] args)   \n    {   \n        for (String color : Color.color)   \n            System.out.print(color + " ");   \n        Color.color.set(3, "white");   \n    }   \n}   \n  \nclass Color   \n{   \n    private static String[] _color = { "red", "blue", "yellow", "black" };   \n    public static List<String> color = new AbstractList<String>()   \n    {   \n        @Override  \n        public String get(int index)   \n        {   \n            return _color[index];   \n        }   \n        @Override  \n        public String set(int index, String value)   \n        {   \n            throw new RuntimeException("为了代码安全,不能修改数组");   \n        }   \n        @Override  \n        public int size()   \n        {   \n            return _color.length;   \n        }   \n    };  \n\n\n}\n')])])]),i("p",[n._v("这样就OK了，既保证了代码安全，又能让数组中的元素被访问了。")]),n._v(" "),i("h3",{attrs:{id:"final方法的三条规则"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#final方法的三条规则"}},[n._v("#")]),n._v(" final方法的三条规则")]),n._v(" "),i("p",[n._v("规则1：final修饰的方法不可以被重写。")]),n._v(" "),i("p",[n._v("规则2：final修饰的方法仅仅是不能重写，但它完全可以被重载。")]),n._v(" "),i("p",[n._v("规则3：父类中private final方法，子类可以重新定义，这种情况不是重写。")]),n._v(" "),i("p",[n._v("代码示例")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[n._v("规则1代码\n\npublic class FinalMethodTest\n{\n\tpublic final void test(){}\n}\nclass Sub extends FinalMethodTest\n{\n\t// 下面方法定义将出现编译错误，不能重写final方法\n\tpublic void test(){}\n}\n\n规则2代码\n\npublic class Finaloverload {\n\t//final 修饰的方法只是不能重写，完全可以重载\n\tpublic final void test(){}\n\tpublic final void test(String arg){}\n}\n\n规则3代码\n\npublic class PrivateFinalMethodTest\n{\n\tprivate final void test(){}\n}\nclass Sub extends PrivateFinalMethodTest\n{\n\t// 下面方法定义将不会出现问题\n\tpublic void test(){}\n}\n")])])]),i("h2",{attrs:{id:"final-和-jvm的关系"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#final-和-jvm的关系"}},[n._v("#")]),n._v(" final 和 jvm的关系")]),n._v(" "),i("p",[n._v("与前面介绍的锁和 volatile 相比较，对 final 域的读和写更像是普通的变量访问。对于 final 域，编译器和处理器要遵守两个重排序规则：")]),n._v(" "),i("ol",[i("li",[n._v("在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。")]),n._v(" "),i("li",[n._v("初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。")])]),n._v(" "),i("p",[n._v("下面，我们通过一些示例性的代码来分别说明这两个规则：")]),n._v(" "),i("pre",[n._v("public class FinalExample {\n    int i;                            // 普通变量 \n    final int j;                      //final 变量 \n    static FinalExample obj;\n\n    public void FinalExample () {     // 构造函数 \n        i = 1;                        // 写普通域 \n        j = 2;                        // 写 final 域 \n    }\n    \n    public static void writer () {    // 写线程 A 执行 \n        obj = new FinalExample ();\n    }\n    \n    public static void reader () {       // 读线程 B 执行 \n        FinalExample object = obj;       // 读对象引用 \n        int a = object.i;                // 读普通域 \n        int b = object.j;                // 读 final 域 \n    }\n}\n")]),n._v(" "),i("p",[n._v("这里假设一个线程 A 执行 writer () 方法，随后另一个线程 B 执行 reader () 方法。下面我们通过这两个线程的交互来说明这两个规则。")]),n._v(" "),i("h3",{attrs:{id:"写-final-域的重排序规则"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#写-final-域的重排序规则"}},[n._v("#")]),n._v(" 写 final 域的重排序规则")]),n._v(" "),i("p",[n._v("写 final 域的重排序规则禁止把 final 域的写重排序到构造函数之外。这个规则的实现包含下面 2 个方面：")]),n._v(" "),i("ul",[i("li",[n._v("JMM 禁止编译器把 final 域的写重排序到构造函数之外。")]),n._v(" "),i("li",[n._v("编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。这个屏障禁止处理器把 final 域的写重排序到构造函数之外。")])]),n._v(" "),i("p",[n._v("现在让我们分析 writer () 方法。writer () 方法只包含一行代码：finalExample = new FinalExample ()。这行代码包含两个步骤：")]),n._v(" "),i("ol",[i("li",[n._v("构造一个 FinalExample 类型的对象；")]),n._v(" "),i("li",[n._v("把这个对象的引用赋值给引用变量 obj。")])]),n._v(" "),i("p",[n._v("假设线程 B 读对象引用与读对象的成员域之间没有重排序（马上会说明为什么需要这个假设），下图是一种可能的执行时序：")]),n._v(" "),i("p",[i("img",{attrs:{src:"https://static001.infoq.cn/resource/image/66/3a/6628576a54f0ba625c8c3af4586cef3a.jpg",alt:""}})]),n._v(" "),i("p",[n._v("在上图中，写普通域的操作被编译器重排序到了构造函数之外，读线程 B 错误的读取了普通变量 i 初始化之前的值。而写 final 域的操作，被写 final 域的重排序规则“限定”在了构造函数之内，读线程 B 正确的读取了 final 变量初始化之后的值。")]),n._v(" "),i("p",[n._v("写 final 域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的 final 域已经被正确初始化过了，而普通域不具有这个保障。以上图为例，在读线程 B“看到”对象引用 obj 时，很可能 obj 对象还没有构造完成（对普通域 i 的写操作被重排序到构造函数外，此时初始值 1 还没有写入普通域 i）。")]),n._v(" "),i("h3",{attrs:{id:"读-final-域的重排序规则"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#读-final-域的重排序规则"}},[n._v("#")]),n._v(" 读 final 域的重排序规则")]),n._v(" "),i("p",[n._v("读 final 域的重排序规则如下：")]),n._v(" "),i("ul",[i("li",[n._v("在一个线程中，初次读对象引用与初次读该对象包含的 final 域，JMM 禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障。")])]),n._v(" "),i("p",[n._v("初次读对象引用与初次读该对象包含的 final 域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，大多数处理器也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如 alpha 处理器），这个规则就是专门用来针对这种处理器。")]),n._v(" "),i("p",[n._v("reader() 方法包含三个操作：")]),n._v(" "),i("ol",[i("li",[n._v("初次读引用变量 obj;")]),n._v(" "),i("li",[n._v("初次读引用变量 obj 指向对象的普通域 i。")]),n._v(" "),i("li",[n._v("初次读引用变量 obj 指向对象的 final 域 j。")])]),n._v(" "),i("p",[n._v("现在我们假设写线程 A 没有发生任何重排序，同时程序在不遵守间接依赖的处理器上执行，下面是一种可能的执行时序：")]),n._v(" "),i("p",[i("img",{attrs:{src:"https://static001.infoq.cn/resource/image/a0/36/a0a9b023bc56ab97bbda8812cdca7236.png",alt:""}})]),n._v(" "),i("p",[n._v("在上图中，读对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该域还没有被写线程 A 写入，这是一个错误的读取操作。而读 final 域的重排序规则会把读对象 final 域的操作“限定”在读对象引用之后，此时该 final 域已经被 A 线程初始化过了，这是一个正确的读取操作。")]),n._v(" "),i("p",[n._v("读 final 域的重排序规则可以确保：在读一个对象的 final 域之前，一定会先读包含这个 final 域的对象的引用。在这个示例程序中，如果该引用不为 null，那么引用对象的 final 域一定已经被 A 线程初始化过了。")]),n._v(" "),i("h3",{attrs:{id:"如果-final-域是引用类型"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#如果-final-域是引用类型"}},[n._v("#")]),n._v(" 如果 final 域是引用类型")]),n._v(" "),i("p",[n._v("上面我们看到的 final 域是基础数据类型，下面让我们看看如果 final 域是引用类型，将会有什么效果？")]),n._v(" "),i("p",[n._v("请看下列示例代码：")]),n._v(" "),i("pre",[n._v("public class FinalReferenceExample {\nfinal int[] intArray;                     //final 是引用类型 \nstatic FinalReferenceExample obj;\n\npublic FinalReferenceExample () {        // 构造函数 \n    intArray = new int[1];              //1\n    intArray[0] = 1;                   //2\n}\n\npublic static void writerOne () {          // 写线程 A 执行 \n    obj = new FinalReferenceExample ();  //3\n}\n\npublic static void writerTwo () {          // 写线程 B 执行 \n    obj.intArray[0] = 2;                 //4\n}\n\npublic static void reader () {              // 读线程 C 执行 \n    if (obj != null) {                    //5\n        int temp1 = obj.intArray[0];       //6\n    }\n}\n}\n")]),n._v(" "),i("p",[n._v("这里 final 域为一个引用类型，它引用一个 int 型的数组对象。对于引用类型，写 final 域的重排序规则对编译器和处理器增加了如下约束：")]),n._v(" "),i("ol",[i("li",[n._v("在构造函数内对一个 final 引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。")])]),n._v(" "),i("p",[n._v("对上面的示例程序，我们假设首先线程 A 执行 writerOne() 方法，执行完后线程 B 执行 writerTwo() 方法，执行完后线程 C 执行 reader () 方法。下面是一种可能的线程执行时序：")]),n._v(" "),i("p",[i("img",{attrs:{src:"https://static001.infoq.cn/resource/image/29/db/29b097c36fd531028991826bb7c835db.png",alt:""}})]),n._v(" "),i("p",[n._v("在上图中，1 是对 final 域的写入，2 是对这个 final 域引用的对象的成员域的写入，3 是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的 1 不能和 3 重排序外，2 和 3 也不能重排序。")]),n._v(" "),i("p",[n._v("JMM 可以确保读线程 C 至少能看到写线程 A 在构造函数中对 final 引用对象的成员域的写入。即 C 至少能看到数组下标 0 的值为 1。而写线程 B 对数组元素的写入，读线程 C 可能看的到，也可能看不到。JMM 不保证线程 B 的写入对读线程 C 可见，因为写线程 B 和读线程 C 之间存在数据竞争，此时的执行结果不可预知。")]),n._v(" "),i("p",[n._v("如果想要确保读线程 C 看到写线程 B 对数组元素的写入，写线程 B 和读线程 C 之间需要使用同步原语（lock 或 volatile）来确保内存可见性。")]),n._v(" "),i("h2",{attrs:{id:"参考文章"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[n._v("#")]),n._v(" 参考文章")]),n._v(" "),i("p",[n._v("https://www.infoq.cn/article/java-memory-model-6\nhttps://www.jianshu.com/p/067b6c89875a\nhttps://www.jianshu.com/p/f68d6ef2dcf0\nhttps://www.cnblogs.com/xiaoxi/p/6392154.html\nhttps://www.iteye.com/blog/cakin24-2334965\nhttps://blog.csdn.net/chengqiuming/article/details/70139503\nhttps://blog.csdn.net/hupuxiang/article/details/7362267")]),n._v(" "),i("h2",{attrs:{id:"微信公众号"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#微信公众号"}},[n._v("#")]),n._v(" 微信公众号")]),n._v(" "),i("h3",{attrs:{id:"java技术江湖"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#java技术江湖"}},[n._v("#")]),n._v(" Java技术江湖")]),n._v(" "),i("p",[n._v("如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，作者黄小斜，专注 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！")]),n._v(" "),i("p",[i("strong",[n._v("Java工程师必备学习资源:")]),n._v(" 一些Java工程师常用学习资源，关注公众号后，后台回复关键字 "),i("strong",[n._v("“Java”")]),n._v(" 即可免费无套路获取。")]),n._v(" "),i("p",[i("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190805090108984.jpg",alt:"我的公众号"}})]),n._v(" "),i("h3",{attrs:{id:"个人公众号-黄小斜"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#个人公众号-黄小斜"}},[n._v("#")]),n._v(" 个人公众号：黄小斜")]),n._v(" "),i("p",[n._v("作者是 985 硕士，蚂蚁金服 JAVA 工程师，专注于 JAVA 后端技术栈：SpringBoot、MySQL、分布式、中间件、微服务，同时也懂点投资理财，偶尔讲点算法和计算机理论基础，坚持学习和写作，相信终身学习的力量！")]),n._v(" "),i("p",[i("strong",[n._v("程序员3T技术学习资源：")]),n._v(" 一些程序员学习技术的资源大礼包，关注公众号后，后台回复关键字 "),i("strong",[n._v("“资料”")]),n._v(" 即可免费无套路获取。")]),n._v(" "),i("p",[i("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190829222750556.jpg",alt:""}})])])}),[],!1,null,null,null);a.default=l.exports}}]);