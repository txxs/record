(window.webpackJsonp=window.webpackJsonp||[]).push([[1303],{1705:function(s,e,n){"use strict";n.r(e);var t=n(13),d=Object(t.a)({},(function(){var s=this,e=s.$createElement,n=s._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"table-of-contents"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#table-of-contents"}},[s._v("#")]),s._v(" Table of Contents")]),s._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#%E5%89%8D%E8%A8%80"}},[s._v("前言")])]),s._v(" "),n("li",[n("a",{attrs:{href:"#sds%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"}},[s._v("sds的数据结构定义")]),s._v("\n* "),n("a",{attrs:{href:"#sds_type_5--0"}},[s._v("SDS_TYPE_5  0")]),s._v("\n* "),n("a",{attrs:{href:"#sds_type_8--1"}},[s._v("SDS_TYPE_8  1")]),s._v("\n* "),n("a",{attrs:{href:"#sds_type_16-2"}},[s._v("SDS_TYPE_16 2")]),s._v("\n* "),n("a",{attrs:{href:"#sds_type_32-3"}},[s._v("SDS_TYPE_32 3")]),s._v("\n* "),n("a",{attrs:{href:"#sds_type_64-4"}},[s._v("SDS_TYPE_64 4")])]),s._v(" "),n("li",[n("a",{attrs:{href:"#redis-dict%E7%BB%93%E6%9E%84%E4%B8%BE%E4%BE%8B"}},[s._v("Redis dict结构举例")]),s._v("\n* "),n("a",{attrs:{href:"#sds_type_mask-7"}},[s._v("SDS_TYPE_MASK 7")]),s._v("\n* "),n("a",{attrs:{href:"#sds_type_bits-3"}},[s._v("SDS_TYPE_BITS 3")]),s._v("\n* "),n("a",{attrs:{href:"#sds_hdr_varts-struct-sdshdrt-sh--voids-sizeofstruct-sdshdrt"}},[s._v("SDS_HDR_VAR(T,s) struct sdshdr##T "),n("em",[s._v("sh = (void")]),s._v(")((s)-(sizeof(struct sdshdr##T)));")]),s._v("\n* "),n("a",{attrs:{href:"#sds_hdrts-struct-sdshdrt-s-sizeofstruct-sdshdrt"}},[s._v("SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))")]),s._v("\n* "),n("a",{attrs:{href:"#sds_type_5_lenf-fsds_type_bits"}},[s._v("SDS_TYPE_5_LEN(f) ((f)>>SDS_TYPE_BITS)")])]),s._v(" "),n("li",[n("a",{attrs:{href:"#sds%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81"}},[s._v("sds的创建和销毁")])]),s._v(" "),n("li",[n("a",{attrs:{href:"#sds%E7%9A%84%E8%BF%9E%E6%8E%A5%EF%BC%88%E8%BF%BD%E5%8A%A0%EF%BC%89%E6%93%8D%E4%BD%9C"}},[s._v("sds的连接（追加）操作")])]),s._v(" "),n("li",[n("a",{attrs:{href:"#%E6%B5%85%E8%B0%88sds%E4%B8%8Estring%E7%9A%84%E5%85%B3%E7%B3%BB"}},[s._v("浅谈sds与string的关系")])])]),s._v(" "),n("p",[s._v("本文转自互联网")]),s._v(" "),n("p",[s._v("本文将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看")]),s._v(" "),n("blockquote",[n("p",[s._v("https://github.com/h2pl/Java-Tutorial")])]),s._v(" "),n("p",[s._v("喜欢的话麻烦点下Star哈")]),s._v(" "),n("p",[s._v("本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。")]),s._v(" "),n("p",[s._v("该系列博文会告诉你如何从入门到进阶，Redis基本的使用方法，Redis的基本数据结构，以及一些进阶的使用方法，同时也需要进一步了解Redis的底层数据结构，再接着，还会带来Redis主从复制、集群、分布式锁等方面的相关内容，以及作为缓存的一些使用方法和注意事项，以便让你更完整地了解整个Redis相关的技术体系，形成自己的知识框架。")]),s._v(" "),n("p",[s._v("如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。")]),s._v(" "),n("h2",{attrs:{id:"前言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[s._v("#")]),s._v(" 前言")]),s._v(" "),n("p",[s._v("本文是《Redis内部数据结构详解》系列的第二篇，讲述Redis中使用最多的一个基础数据结构：sds。")]),s._v(" "),n("p",[s._v("不管在哪门编程语言当中，字符串都几乎是使用最多的数据结构。sds正是在Redis中被广泛使用的字符串结构，它的全称是Simple Dynamic String。与其它语言环境中出现的字符串相比，它具有如下显著的特点：")]),s._v(" "),n("p",[s._v("可动态扩展内存。sds表示的字符串其内容可以修改，也可以追加。在很多语言中字符串会分为mutable和immutable两种，显然sds属于mutable类型的。\n二进制安全（Binary Safe）。sds能存储任意二进制数据，而不仅仅是可打印字符。\n与传统的C语言字符串类型兼容。这个的含义接下来马上会讨论。\n看到这里，很多对Redis有所了解的同学可能已经产生了一个疑问：Redis已经对外暴露了一个字符串结构，叫做string，那这里所说的sds到底和string是什么关系呢？可能有人会猜：string是基于sds实现的。这个猜想已经非常接近事实，但在描述上还不太准确。有关string和sds之间关系的详细分析，我们放在后面再讲。现在为了方便讨论，让我们先暂时简单地认为，string的底层实现就是sds。")]),s._v(" "),n("p",[s._v("在讨论sds的具体实现之前，我们先站在Redis使用者的角度，来观察一下string所支持的一些主要操作。下面是一个操作示例：")]),s._v(" "),n("p",[n("img",{attrs:{src:"http://zhangtielei.com/assets/photos_redis/redis_string_op_examples.png",alt:"image"}}),s._v("\nRedis string操作示例")]),s._v(" "),n("p",[s._v("以上这些操作都比较简单，我们简单解释一下：")]),s._v(" "),n("p",[s._v("初始的字符串的值设为”tielei”。\n第3步通过append命令对字符串进行了追加，变成了”tielei zhang”。\n然后通过setbit命令将第53个bit设置成了1。bit的偏移量从左边开始算，从0开始。其中第48～55bit是中间的空格那个字符，它的ASCII码是0x20。将第53个bit设置成1之后，它的ASCII码变成了0x24，打印出来就是’$’。因此，现在字符串的值变成了”tielei$zhang”。\n最后通过getrange取从倒数第5个字节到倒数第1个字节的内容，得到”zhang”。\n这些命令的实现，有一部分是和sds的实现有关的。下面我们开始详细讨论。")]),s._v(" "),n("h2",{attrs:{id:"sds的数据结构定义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#sds的数据结构定义"}},[s._v("#")]),s._v(" sds的数据结构定义")]),s._v(" "),n("p",[s._v("我们知道，在C语言中，字符串是以’\\0’字符结尾（NULL结束符）的字符数组来存储的，通常表达为字符指针的形式（char *）。它不允许字节0出现在字符串中间，因此，它不能用来存储任意的二进制数据。")]),s._v(" "),n("p",[s._v("我们可以在sds.h中找到sds的类型定义：")]),s._v(" "),n("p",[s._v("typedef char *sds;\n肯定有人感到困惑了，竟然sds就等同于char *？我们前面提到过，sds和传统的C语言字符串保持类型兼容，因此它们的类型定义是一样的，都是char *。在有些情况下，需要传入一个C语言字符串的地方，也确实可以传入一个sds。但是，sds和char *并不等同。sds是Binary Safe的，它可以存储任意二进制数据，不能像C语言字符串那样以字符’\\0’来标识字符串的结束，因此它必然有个长度字段。但这个长度字段在哪里呢？实际上sds还包含一个header结构：")]),s._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[s._v("struct __attribute__ ((__packed__)) sdshdr5 {\n    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr8 {\n    uint8_t len; /* used */\n    uint8_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr16 {\n    uint16_t len; /* used */\n    uint16_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr32 {\n    uint32_t len; /* used */\n    uint32_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr64 {\n    uint64_t len; /* used */\n    uint64_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\n")])])]),n("p",[s._v("sds一共有5种类型的header。之所以有5种，是为了能让不同长度的字符串可以使用不同大小的header。这样，短字符串就能使用较小的header，从而节省内存。")]),s._v(" "),n("p",[s._v("一个sds字符串的完整结构，由在内存地址上前后相邻的两部分组成：")]),s._v(" "),n("p",[s._v("一个header。通常包含字符串的长度(len)、最大容量(alloc)和flags。sdshdr5有所不同。\n一个字符数组。这个字符数组的长度等于最大容量+1。真正有效的字符串数据，其长度通常小于最大容量。在真正的字符串数据之后，是空余未用的字节（一般以字节0填充），允许在不重新分配内存的前提下让字符串数据向后做有限的扩展。在真正的字符串数据之后，还有一个NULL结束符，即ASCII码为0的’\\0’字符。这是为了和传统C字符串兼容。之所以字符数组的长度比最大容量多1个字节，就是为了在字符串长度达到最大容量时仍然有1个字节存放NULL结束符。\n除了sdshdr5之外，其它4个header的结构都包含3个字段：")]),s._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[s._v("len: 表示字符串的真正长度（不包含NULL结束符在内）。\nalloc: 表示字符串的最大容量（不包含最后多余的那个字节）。\nflags: 总是占用一个字节。其中的最低3个bit用来表示header的类型。header的类型共有5种，在sds.h中有常量定义。\n#define SDS_TYPE_5  0\n#define SDS_TYPE_8  1\n#define SDS_TYPE_16 2\n#define SDS_TYPE_32 3\n#define SDS_TYPE_64 4\n")])])]),n("p",[s._v("sds的数据结构，我们有必要非常仔细地去解析它。")]),s._v(" "),n("h2",{attrs:{id:"redis-dict结构举例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-dict结构举例"}},[s._v("#")]),s._v(" Redis dict结构举例")]),s._v(" "),n("p",[s._v("上图是sds的一个内部结构的例子。图中展示了两个sds字符串s1和s2的内存结构，一个使用sdshdr8类型的header，另一个使用sdshdr16类型的header。但它们都表达了同样的一个长度为6的字符串的值：”tielei”。下面我们结合代码，来解释每一部分的组成。")]),s._v(" "),n("p",[s._v("sds的字符指针（s1和s2）就是指向真正的数据（字符数组）开始的位置，而header位于内存地址较低的方向。在sds.h中有一些跟解析header有关的宏定义：")]),s._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[s._v("#define SDS_TYPE_MASK 7\n#define SDS_TYPE_BITS 3\n#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));\n#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))\n#define SDS_TYPE_5_LEN(f) ((f)>>SDS_TYPE_BITS)\n")])])]),n("p",[s._v("其中SDS_HDR用来从sds字符串获得header起始位置的指针，比如SDS_HDR(8, s1)表示s1的header指针，SDS_HDR(16, s2)表示s2的header指针。")]),s._v(" "),n("p",[s._v("当然，使用SDS_HDR之前我们必须先知道到底是哪一种header，这样我们才知道SDS_HDR第1个参数应该传什么。由sds字符指针获得header类型的方法是，先向低地址方向偏移1个字节的位置，得到flags字段。比如，s1[-1]和s2[-1]分别获得了s1和s2的flags的值。然后取flags的最低3个bit得到header的类型。")]),s._v(" "),n("p",[s._v("由于s1[-1] == 0x01 == SDS_TYPE_8，因此s1的header类型是sdshdr8。\n由于s2[-1] == 0x02 == SDS_TYPE_16，因此s2的header类型是sdshdr16。\n有了header指针，就能很快定位到它的len和alloc字段：")]),s._v(" "),n("p",[s._v("s1的header中，len的值为0x06，表示字符串数据长度为6；alloc的值为0x80，表示字符数组最大容量为128。\ns2的header中，len的值为0x0006，表示字符串数据长度为6；alloc的值为0x03E8，表示字符数组最大容量为1000。（注意：图中是按小端地址构成）\n在各个header的类型定义中，还有几个需要我们注意的地方：")]),s._v(" "),n("p",[s._v("在各个header的定义中使用了__attribute__ ((packed))，是为了让编译器以紧凑模式来分配内存。如果没有这个属性，编译器可能会为struct的字段做优化对齐，在其中填充空字节。那样的话，就不能保证header和sds的数据部分紧紧前后相邻，也不能按照固定向低地址方向偏移1个字节的方式来获取flags字段了。")]),s._v(" "),n("p",[s._v("在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为柔性数组（flexible array member），只能定义在一个结构体的最后一个字段上。")]),s._v(" "),n("p",[s._v("它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在为header分配的内存的时候，它并不占用内存空间。")]),s._v(" "),n("p",[s._v("如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。\nsdshdr5与其它几个header结构不同，它不包含alloc字段，而长度使用flags的高5位来存储。")]),s._v(" "),n("p",[s._v("因此，它不能为字符串分配空余空间。如果字符串需要动态增长，那么它就必然要重新分配内存才行。所以说，这种类型的sds字符串更适合存储静态的短字符串（长度小于32）。")]),s._v(" "),n("p",[s._v("至此，我们非常清楚地看到了：sds字符串的header，其实隐藏在真正的字符串数据的前面（低地址方向）。这样的一个定义，有如下几个好处：")]),s._v(" "),n("p",[s._v("header和数据相邻，而不用分成两块内存空间来单独分配。这有利于减少内存碎片，提高存储效率（memory efficiency）。")]),s._v(" "),n("p",[s._v("虽然header有多个类型，但sds可以用统一的char *来表达。且它与传统的C语言字符串保持类型兼容。")]),s._v(" "),n("p",[s._v("如果一个sds里面存储的是可打印字符串，那么我们可以直接把它传给C函数，比如使用strcmp比较字符串大小，或者使用printf进行打印。\n弄清了sds的数据结构，它的具体操作函数就比较好理解了。")]),s._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[s._v("sds的一些基础函数\nsdslen(const sds s): 获取sds字符串长度。\nsdssetlen(sds s, size_t newlen): 设置sds字符串长度。\nsdsinclen(sds s, size_t inc): 增加sds字符串长度。\nsdsalloc(const sds s): 获取sds字符串容量。\nsdssetalloc(sds s, size_t newlen): 设置sds字符串容量。\nsdsavail(const sds s): 获取sds字符串空余空间（即alloc - len）。\nsdsHdrSize(char type): 根据header类型得到header大小。\nsdsReqType(size_t string_size):\n")])])]),n("p",[s._v("根据字符串数据长度计算所需要的header类型。\n这里我们挑选sdslen和sdsReqType的代码，察看一下。")]),s._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[s._v("static inline size_t sdslen(const sds s) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            return SDS_TYPE_5_LEN(flags);\n        case SDS_TYPE_8:\n            return SDS_HDR(8,s)->len;\n        case SDS_TYPE_16:\n            return SDS_HDR(16,s)->len;\n        case SDS_TYPE_32:\n            return SDS_HDR(32,s)->len;\n        case SDS_TYPE_64:\n            return SDS_HDR(64,s)->len;\n    }\n    return 0;\n}\n\nstatic inline char sdsReqType(size_t string_size) {\n    if (string_size < 1<<5)\n        return SDS_TYPE_5;\n    if (string_size < 1<<8)\n        return SDS_TYPE_8;\n    if (string_size < 1<<16)\n        return SDS_TYPE_16;\n    if (string_size < 1ll<<32)\n        return SDS_TYPE_32;\n    return SDS_TYPE_64;\n}\n")])])]),n("p",[s._v("跟前面的分析类似，sdslen先用s[-1]向低地址方向偏移1个字节，得到flags；然后与SDS_TYPE_MASK进行按位与，得到header类型；然后根据不同的header类型，调用SDS_HDR得到header起始指针，进而获得len字段。")]),s._v(" "),n("p",[s._v("通过sdsReqType的代码，很容易看到：")]),s._v(" "),n("p",[s._v("长度在0和2^5-1之间，选用SDS_TYPE_5类型的header。\n长度在2^5和2^8-1之间，选用SDS_TYPE_8类型的header。\n长度在2^8和2^16-1之间，选用SDS_TYPE_16类型的header。\n长度在2^16和2^32-1之间，选用SDS_TYPE_32类型的header。\n长度大于2^32的，选用SDS_TYPE_64类型的header。能表示的最大长度为2^64-1。\n注：sdsReqType的实现代码，直到3.2.0，它在长度边界值上都一直存在问题，直到最近3.2 branch上的commit 6032340才修复。")]),s._v(" "),n("h2",{attrs:{id:"sds的创建和销毁"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#sds的创建和销毁"}},[s._v("#")]),s._v(" sds的创建和销毁")]),s._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[s._v("sds sdsnewlen(const void *init, size_t initlen) {\n    void *sh;\n    sds s;\n    char type = sdsReqType(initlen);\n    /* Empty strings are usually created in order to append. Use type 8\n     * since type 5 is not good at this. */\n    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;\n    int hdrlen = sdsHdrSize(type);\n    unsigned char *fp; /* flags pointer. */\n \n    sh = s_malloc(hdrlen+initlen+1);\n    if (!init)\n        memset(sh, 0, hdrlen+initlen+1);\n    if (sh == NULL) return NULL;\n    s = (char*)sh+hdrlen;\n    fp = ((unsigned char*)s)-1;\n    switch(type) {\n        case SDS_TYPE_5: {\n            *fp = type | (initlen << SDS_TYPE_BITS);\n            break;\n        }\n        case SDS_TYPE_8: {\n            SDS_HDR_VAR(8,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n    }\n    if (initlen && init)\n        memcpy(s, init, initlen);\n    s[initlen] = '\\0';\n    return s;\n}\n \nsds sdsempty(void) {\n    return sdsnewlen(\"\",0);\n}\n \nsds sdsnew(const char *init) {\n    size_t initlen = (init == NULL) ? 0 : strlen(init);\n    return sdsnewlen(init, initlen);\n}\n \nvoid sdsfree(sds s) {\n    if (s == NULL) return;\n    s_free((char*)s-sdsHdrSize(s[-1]));\n}\n")])])]),n("p",[s._v("sdsnewlen创建一个长度为initlen的sds字符串，并使用init指向的字符数组（任意二进制数据）来初始化数据。如果init为NULL，那么使用全0来初始化数据。它的实现中，我们需要注意的是：")]),s._v(" "),n("p",[s._v("如果要创建一个长度为0的空字符串，那么不使用SDS_TYPE_5类型的header，而是转而使用SDS_TYPE_8类型的header。这是因为创建的空字符串一般接下来的操作很可能是追加数据，但SDS_TYPE_5类型的sds字符串不适合追加数据（会引发内存重新分配）。\n需要的内存空间一次性进行分配，其中包含三部分：header、数据、最后的多余字节（hdrlen+initlen+1）。\n初始化的sds字符串数据最后会追加一个NULL结束符（s[initlen] = ‘\\0’）。\n关于sdsfree，需要注意的是：内存要整体释放，所以要先计算出header起始指针，把它传给s_free函数。这个指针也正是在sdsnewlen中调用s_malloc返回的那个地址。")]),s._v(" "),n("h2",{attrs:{id:"sds的连接-追加-操作"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#sds的连接-追加-操作"}},[s._v("#")]),s._v(" sds的连接（追加）操作")]),s._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[s._v("sds sdscatlen(sds s, const void *t, size_t len) {\n    size_t curlen = sdslen(s);\n \n    s = sdsMakeRoomFor(s,len);\n    if (s == NULL) return NULL;\n    memcpy(s+curlen, t, len);\n    sdssetlen(s, curlen+len);\n    s[curlen+len] = '\\0';\n    return s;\n}\n \nsds sdscat(sds s, const char *t) {\n    return sdscatlen(s, t, strlen(t));\n}\n \nsds sdscatsds(sds s, const sds t) {\n    return sdscatlen(s, t, sdslen(t));\n}\n \nsds sdsMakeRoomFor(sds s, size_t addlen) {\n    void *sh, *newsh;\n    size_t avail = sdsavail(s);\n    size_t len, newlen;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n \n    /* Return ASAP if there is enough space left. */\n    if (avail >= addlen) return s;\n \n    len = sdslen(s);\n    sh = (char*)s-sdsHdrSize(oldtype);\n    newlen = (len+addlen);\n    if (newlen < SDS_MAX_PREALLOC)\n        newlen *= 2;\n    else\n        newlen += SDS_MAX_PREALLOC;\n \n    type = sdsReqType(newlen);\n \n    /* Don't use type 5: the user is appending to the string and type 5 is\n     * not able to remember empty space, so sdsMakeRoomFor() must be called\n     * at every appending operation. */\n    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n \n    hdrlen = sdsHdrSize(type);\n    if (oldtype==type) {\n        newsh = s_realloc(sh, hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+hdrlen;\n    } else {\n        /* Since the header size changes, need to move the string forward,\n         * and can't use realloc */\n        newsh = s_malloc(hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    sdssetalloc(s, newlen);\n    return s;\n}\n")])])]),n("p",[s._v("sdscatlen将t指向的长度为len的任意二进制数据追加到sds字符串s的后面。本文开头演示的string的append命令，内部就是调用sdscatlen来实现的。")]),s._v(" "),n("p",[s._v("在sdscatlen的实现中，先调用sdsMakeRoomFor来保证字符串s有足够的空间来追加长度为len的数据。sdsMakeRoomFor可能会分配新的内存，也可能不会。")]),s._v(" "),n("p",[s._v("sdsMakeRoomFor是sds实现中很重要的一个函数。关于它的实现代码，我们需要注意的是：")]),s._v(" "),n("p",[s._v("如果原来字符串中的空余空间够用（avail >= addlen），那么它什么也不做，直接返回。")]),s._v(" "),n("p",[s._v("如果需要分配空间，它会比实际请求的要多分配一些，以防备接下来继续追加。它在字符串已经比较长的情况下要至少多分配SDS_MAX_PREALLOC个字节，这个常量在sds.h中定义为(1024*1024)=1MB。")]),s._v(" "),n("p",[s._v("按分配后的空间大小，可能需要更换header类型（原来header的alloc字段太短，表达不了增加后的容量）。")]),s._v(" "),n("p",[s._v("如果需要更换header，那么整个字符串空间（包括header）都需要重新分配（s_malloc），并拷贝原来的数据到新的位置。")]),s._v(" "),n("p",[s._v("如果不需要更换header（原来的header够用），那么调用一个比较特殊的s_realloc，试图在原来的地址上重新分配空间。s_realloc的具体实现得看Redis编译的时候选用了哪个allocator（在Linux上默认使用jemalloc）。")]),s._v(" "),n("p",[s._v("但不管是哪个realloc的实现，它所表达的含义基本是相同的：它尽量在原来分配好的地址位置重新分配，如果原来的地址位置有足够的空余空间完成重新分配，那么它返回的新地址与传入的旧地址相同；否则，它分配新的地址块，并进行数据搬迁。参见http://man.cx/realloc。")]),s._v(" "),n("p",[s._v("从sdscatlen的函数接口，我们可以看到一种使用模式：调用它的时候，传入一个旧的sds变量，然后它返回一个新的sds变量。由于它的内部实现可能会造成地址变化，因此调用者在调用完之后，原来旧的变量就失效了，而都应该用新返回的变量来替换。不仅仅是sdscatlen函数，sds中的其它函数（比如sdscpy、sdstrim、sdsjoin等），还有Redis中其它一些能自动扩展内存的数据结构（如ziplist），也都是同样的使用模式。")]),s._v(" "),n("h2",{attrs:{id:"浅谈sds与string的关系"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#浅谈sds与string的关系"}},[s._v("#")]),s._v(" 浅谈sds与string的关系")]),s._v(" "),n("p",[s._v("现在我们回过头来看看本文开头给出的string操作的例子。")]),s._v(" "),n("p",[s._v("append操作使用sds的sdscatlen来实现。前面已经提到。")]),s._v(" "),n("p",[s._v("setbit和getrange都是先根据key取到整个sds字符串，然后再从字符串选取或修改指定的部分。由于sds就是一个字符数组，所以对它的某一部分进行操作似乎都比较简单。")]),s._v(" "),n("p",[s._v("但是，string除了支持这些操作之外，当它存储的值是个数字的时候，它还支持incr、decr等操作。那么，当string存储数字值的时候，它的内部存储还是sds吗？")]),s._v(" "),n("p",[s._v("实际上，不是了。而且，这种情况下，setbit和getrange的实现也会有所不同。这些细节，我们放在下一篇介绍robj的时候再进行系统地讨论。")])])}),[],!1,null,null,null);e.default=d.exports}}]);