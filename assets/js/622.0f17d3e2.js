(window.webpackJsonp=window.webpackJsonp||[]).push([[622],{1014:function(t,e,n){"use strict";n.r(e);var r=n(13),a=Object(r.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("本文转自：https://github.com/jasonGeng88/blog")]),t._v(" "),n("p",[t._v("本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看")]),t._v(" "),n("blockquote",[n("p",[t._v("https://github.com/h2pl/Java-Tutorial")])]),t._v(" "),n("p",[t._v("喜欢的话麻烦点下Star哈")]),t._v(" "),n("p",[t._v("文章将同步到我的个人博客：")]),t._v(" "),n("blockquote",[n("p",[t._v("www.how2playlife.com")])]),t._v(" "),n("p",[t._v("本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。")]),t._v(" "),n("p",[t._v("该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。")]),t._v(" "),n("p",[t._v("为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。")]),t._v(" "),n("p",[t._v("如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。")]),t._v(" "),n("h2",{attrs:{id:"当前环境"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#当前环境"}},[t._v("#")]),t._v(" 当前环境")]),t._v(" "),n("ol",[n("li",[t._v("jdk == 1.8")])]),t._v(" "),n("h2",{attrs:{id:"知识点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#知识点"}},[t._v("#")]),t._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E7%9F%A5%E8%AF%86%E7%82%B9",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),t._v("知识点")]),t._v(" "),n("ul",[n("li",[t._v("socket 的连接处理")]),t._v(" "),n("li",[t._v("IO 输入、输出流的处理")]),t._v(" "),n("li",[t._v("请求数据格式处理")]),t._v(" "),n("li",[t._v("请求模型优化")])]),t._v(" "),n("h2",{attrs:{id:"场景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#场景"}},[t._v("#")]),t._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E5%9C%BA%E6%99%AF",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),t._v("场景")]),t._v(" "),n("p",[t._v("今天，和大家聊一下 JAVA 中的 socket 通信问题。这里采用最简单的一请求一响应模型为例，假设我们现在需要向 baidu 站点进行通信。我们用 JAVA 原生的 socket 该如何实现。")]),t._v(" "),n("h3",{attrs:{id:"建立-socket-连接"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#建立-socket-连接"}},[t._v("#")]),t._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E5%BB%BA%E7%AB%8B-socket-%E8%BF%9E%E6%8E%A5",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),t._v("建立 socket 连接")]),t._v(" "),n("p",[t._v("首先，我们需要建立 socket 连接（"),n("em",[t._v("核心代码")]),t._v("）")]),t._v(" "),n("pre",[t._v("import java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\n\n// 初始化 socket\nSocket socket = new Socket();\n// 初始化远程连接地址\nSocketAddress remote = new InetSocketAddress(host, port);\n// 建立连接\nsocket.connect(remote);\n")]),t._v(" "),n("h3",{attrs:{id:"处理-socket-输入输出流"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#处理-socket-输入输出流"}},[t._v("#")]),t._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E5%A4%84%E7%90%86-socket-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),t._v("处理 socket 输入输出流")]),t._v(" "),n("p",[t._v("成功建立 socket 连接后，我们就能获得它的输入输出流，通信的本质是对输入输出流的处理。通过输入流，读取网络连接上传来的数据，通过输出流，将本地的数据传出给远端。")]),t._v(" "),n("p",[n("em",[t._v("socket 连接实际与处理文件流有点类似，都是在进行 IO 操作。")])]),t._v(" "),n("p",[t._v("获取输入、输出流代码如下：")]),t._v(" "),n("pre",[t._v("// 输入流\nInputStream in = socket.getInputStream();\n// 输出流\nOutputStream out = socket.getOutputStream();")]),t._v(" "),n("p",[t._v("关于 IO 流的处理，我们一般会用相应的包装类来处理 IO 流，如果直接处理的话，我们需要对 "),n("code",[t._v("byte[]")]),t._v(" 进行操作，而这是相对比较繁琐的。如果采用包装类，我们可以直接以"),n("code",[t._v("string")]),t._v("、"),n("code",[t._v("int")]),t._v("等类型进行处理，简化了 IO 字节操作。")]),t._v(" "),n("p",[t._v("下面以 "),n("code",[t._v("BufferedReader")]),t._v(" 与 "),n("code",[t._v("PrintWriter")]),t._v(" 作为输入输出的包装类进行处理。")]),t._v(" "),n("pre",[t._v("// 获取 socket 输入流\nprivate BufferedReader getReader(Socket socket) throws IOException {\n    InputStream in = socket.getInputStream();\n    return new BufferedReader(new InputStreamReader(in));\n}\n\n// 获取 socket 输出流\nprivate PrintWriter getWriter(Socket socket) throws IOException {\n    OutputStream out = socket.getOutputStream();\n    return new PrintWriter(new OutputStreamWriter(out));\n}\n")]),t._v(" "),n("h3",{attrs:{id:"数据请求与响应"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据请求与响应"}},[t._v("#")]),t._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),t._v("数据请求与响应")]),t._v(" "),n("p",[t._v("有了 socket 连接、IO 输入输出流，下面就该向发送请求数据，以及获取请求的响应结果。")]),t._v(" "),n("p",[t._v("因为有了 IO 包装类的支持，我们可以直接以字符串的格式进行传输，由包装类帮我们将数据装换成相应的字节流。")]),t._v(" "),n("p",[t._v("因为我们与 baidu 站点进行的是 HTTP 访问，所有我们不需要额外定义输出格式。采用标准的 HTTP 传输格式，就能进行请求响应了（"),n("em",[t._v("某些特定的 RPC 框架，可能会有自定义的通信格式")]),t._v("）。")]),t._v(" "),n("p",[t._v("请求的数据内容处理如下：")]),t._v(" "),n("pre",[t._v('public class HttpUtil {\n\n    public static String compositeRequest(String host){\n\n        return "GET / HTTP/1.1\\r\\n" +\n                "Host: " + host + "\\r\\n" +\n                "User-Agent: curl/7.43.0\\r\\n" +\n                "Accept: */*\\r\\n\\r\\n";\n    }\n\n}')]),t._v(" "),n("p",[t._v("发送请求数据代码如下：")]),t._v(" "),n("pre",[t._v("// 发起请求\nPrintWriter writer = getWriter(socket);\nwriter.write(HttpUtil.compositeRequest(host));\nwriter.flush();")]),t._v(" "),n("p",[t._v("接收响应数据代码如下：")]),t._v(" "),n("pre",[t._v("// 读取响应\nString msg;\nBufferedReader reader = getReader(socket);\nwhile ((msg = reader.readLine()) != null){\n    System.out.println(msg);\n}")]),t._v(" "),n("h3",{attrs:{id:"结果展示"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#结果展示"}},[t._v("#")]),t._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),t._v("结果展示")]),t._v(" "),n("p",[t._v("至此，讲完了原生 socket 下的创建连接、发送请求与接收响应的所有核心代码。")]),t._v(" "),n("p",[t._v("完整代码如下：")]),t._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import java.io.*;import java.net.InetSocketAddress;import java.net.Socket;import java.net.SocketAddress;import com.test.network.util.HttpUtil; public class SocketHttpClient {     public void start(String host, int port) {         // 初始化 socket        Socket socket = new Socket();         try {            // 设置 socket 连接            SocketAddress remote = new InetSocketAddress(host, port);            socket.setSoTimeout(5000);            socket.connect(remote);             // 发起请求            PrintWriter writer = getWriter(socket);            System.out.println(HttpUtil.compositeRequest(host));            writer.write(HttpUtil.compositeRequest(host));            writer.flush();             // 读取响应            String msg;            BufferedReader reader = getReader(socket);            while ((msg = reader.readLine()) != null){                System.out.println(msg);            }         } catch (IOException e) {            e.printStackTrace();        } finally {            try {                socket.close();            } catch (IOException e) {                e.printStackTrace();            }        }     } \tprivate BufferedReader getReader(Socket socket) throws IOException {        InputStream in = socket.getInputStream();        return new BufferedReader(new InputStreamReader(in));    }     private PrintWriter getWriter(Socket socket) throws IOException {        OutputStream out = socket.getOutputStream();        return new PrintWriter(new OutputStreamWriter(out));    } }\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br")])]),n("p",[t._v("下面，我们通过实例化一个客户端，来展示 socket 通信的结果。")]),t._v(" "),n("pre",[t._v('public class Application {\n\n    public static void main(String[] args) {\n\n        new SocketHttpClient().start("www.baidu.com", 80);\n\n    }\n}')]),t._v(" "),n("p",[t._v("结果输出：")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/assets/java-socket-01.png",target:"_blank",rel:"noopener noreferrer"}},[n("img",{attrs:{src:"https://github.com/jasonGeng88/blog/raw/master/201708/assets/java-socket-01.png",alt:""}}),n("OutboundLink")],1)]),t._v(" "),n("h2",{attrs:{id:"请求模型优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#请求模型优化"}},[t._v("#")]),t._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),t._v("请求模型优化")]),t._v(" "),n("p",[t._v("这种方式，虽然实现功能没什么问题。但是我们细看，发现在 IO 写入与读取过程，是发生了 IO 阻塞的情况。即：")]),t._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 会发生 IO 阻塞writer.write(HttpUtil.compositeRequest(host));reader.readLine();\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br")])]),n("p",[t._v("所以如果要同时请求10个不同的站点，如下：")]),t._v(" "),n("pre",[t._v("public class SingleThreadApplication {\n\n    public static void main(String[] args) {\n\n\t\t// HttpConstant.HOSTS 为 站点集合\n        for (String host: HttpConstant.HOSTS) {\n\n            new SocketHttpClient().start(host, HttpConstant.PORT);\n\n        }\n\n    }\n}")]),t._v(" "),n("p",[t._v("它一定是第一个请求响应结束后，才会发起下一个站点处理。")]),t._v(" "),n("p",[n("em",[t._v("这在服务端更明显，虽然这里的代码是客户端连接，但是具体的操作和服务端是差不多的。请求只能一个个串行处理，这在响应时间上肯定不能达标。")])]),t._v(" "),n("ul",[n("li",[t._v("多线程处理")])]),t._v(" "),n("p",[t._v("有人觉得这根本不是问题，JAVA 是多线程的编程语言。对于这种情况，采用多线程的模型再合适不过。")]),t._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("public class MultiThreadApplication {     public static void main(String[] args) {         for (final String host: HttpConstant.HOSTS) {             Thread t = new Thread(new Runnable() {                public void run() {                    new SocketHttpClient().start(host, HttpConstant.PORT);                }            });             t.start();         }    }}\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br")])]),n("p",[t._v("这种方式起初看起来挺有用的，但并发量一大，应用会起很多的线程。都知道，在服务器上，每一个线程实际都会占据一个文件句柄。而服务器上的句柄数是有限的，而且大量的线程，造成的线程间切换的消耗也会相当的大。所以这种方式在并发量大的场景下，一定是承载不住的。")]),t._v(" "),n("ul",[n("li",[t._v("多线程 + 线程池 处理")])]),t._v(" "),n("p",[t._v("既然线程太多不行，那我们控制一下线程创建的数目不就行了。只启动固定的线程数来进行 socket 处理，既利用了多线程的处理，又控制了系统的资源消耗。")]),t._v(" "),n("pre",[t._v("public class ThreadPoolApplication {\n\n    public static void main(String[] args) {\n\n        ExecutorService executorService = Executors.newFixedThreadPool(8);\n\n        for (final String host: HttpConstant.HOSTS) {\n\n            Thread t = new Thread(new Runnable() {\n                public void run() {\n                    new SocketHttpClient().start(host, HttpConstant.PORT);\n                }\n            });\n\n            executorService.submit(t);\n            new SocketHttpClient().start(host, HttpConstant.PORT);\n\n        }\n\n    }\n}")]),t._v(" "),n("p",[n("em",[t._v("关于启动的线程数，一般 CPU 密集型会设置在 N+1（N为CPU核数），IO 密集型设置在 2N + 1。")])]),t._v(" "),n("p",[t._v("这种方式，看起来是最优的了。那有没有更好的呢，如果一个线程能同时处理多个 socket 连接，并且在每个 socket 输入输出数据没有准备好的情况下，不进行阻塞，那是不是更优呢。这种技术叫做“IO多路复用”。在 JAVA 的 nio 包中，提供了相应的实现。")]),t._v(" "),n("h2",{attrs:{id:"补充1-tcp客户端与服务端"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#补充1-tcp客户端与服务端"}},[t._v("#")]),t._v(" 补充1：TCP客户端与服务端")]),t._v(" "),n("pre",[t._v('public class TCP客户端 {\n    public static void main(String[] args) {\n        new Thread(new Runnable() {\n            @Override\n  public void run() {\n                try {\n                    Socket s = new Socket("127.0.0.1",1234);    //构建IO\n  InputStream is = s.getInputStream();\n  OutputStream os = s.getOutputStream();    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(os));\n  //向服务器端发送一条消息\n  bw.write("测试客户端和服务器通信，服务器接收到消息返回到客户端\\n");\n  bw.flush();    //读取服务器返回的消息\n  BufferedReader br = new BufferedReader(new InputStreamReader(is));\n  String mess = br.readLine();\n  System._out_.println("服务器："+mess);\n  } catch (UnknownHostException e) {\n                    e.printStackTrace();\n  } catch (IOException e) {\n                    e.printStackTrace();\n  }\n            }\n        }).start();\n  }\n}')]),t._v(" "),n("pre",[t._v('public class TCP服务端 {\n    public static void main(String[] args) {\n        new Thread(new Runnable() {\n            @Override\n  public void run() {\n                try {\n                    ServerSocket ss = new ServerSocket(1234);\n while (true) {\n                        System._out_.println("启动服务器....");\n  Socket s = ss.accept();\n  System._out_.println("客户端:" + s.getInetAddress().getLocalHost() + "已连接到服务器");\n  BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));\n  //读取客户端发送来的消息\n  String mess = br.readLine();\n  System._out_.println("客户端：" + mess);\n  BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));\n  bw.write(mess + "\\n");\n  bw.flush();\n  }\n                } catch (IOException e) {\n                    e.printStackTrace();\n  }\n            }\n        }).start();\n  }\n}')]),t._v(" "),n("h2",{attrs:{id:"补充2-udp客户端和服务端"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#补充2-udp客户端和服务端"}},[t._v("#")]),t._v(" 补充2：UDP客户端和服务端")]),t._v(" "),n("pre",[t._v('public class UDP客户端 {\n    public static void main(String[] args) {\n        new Thread(new Runnable() {\n            @Override\n  public void run() {\n                byte []arr = "Hello Server".getBytes();\n try {\n                    InetAddress inetAddress = InetAddress.getLocalHost();\n  DatagramSocket datagramSocket = new DatagramSocket();\n  DatagramPacket datagramPacket = new DatagramPacket(arr, arr.length, inetAddress, 1234);\n  datagramSocket.send(datagramPacket);\n  System._out_.println("send end");\n  } catch (UnknownHostException e) {\n                    e.printStackTrace();\n  } catch (SocketException e) {\n                    e.printStackTrace();\n  } catch (IOException e) {\n                    e.printStackTrace();\n  }\n            }\n        }).start();\n  }\n}')]),t._v(" "),n("pre",[t._v('public class UDP服务端 {\n    public static void main(String[] args) {\n        new Thread(new Runnable() {\n            @Override\n  public void run() {\n                try {\n                    DatagramSocket datagramSocket = new DatagramSocket(1234);\n byte[] buffer = new byte[1024];\n  DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n  datagramSocket.receive(packet);\n  System._out_.println("server recv");\n  String msg = new String(packet.getData(), "utf-8");\n  System._out_.println(msg);\n  } catch (SocketException e) {\n                    e.printStackTrace();\n  } catch (IOException e) {\n                    e.printStackTrace();\n  }\n            }\n        }).start();\n  }\n}\n')]),t._v(" "),n("h2",{attrs:{id:"后续"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#后续"}},[t._v("#")]),t._v(" "),n("a",{attrs:{href:"https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E5%90%8E%E7%BB%AD",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),t._v("后续")]),t._v(" "),n("ul",[n("li",[t._v("JAVA 中是如何实现 IO多路复用")]),t._v(" "),n("li",[t._v("Netty 下的实现异步请求的")])])])}),[],!1,null,null,null);e.default=a.exports}}]);