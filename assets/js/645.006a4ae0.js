(window.webpackJsonp=window.webpackJsonp||[]).push([[645],{1037:function(t,s,a){"use strict";a.r(s);var e=a(13),i=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("首先要区分开两种不同的场景：")]),t._v(" "),a("ul",[a("li",[t._v("声明一个泛型类或泛型方法\n类型参数“"),a("T",[t._v("”主要用于第一种，声明泛型类或泛型方法")])],1),t._v(" "),a("li",[t._v("使用泛型类或泛型方法\n无界通配符“<?>”主要用于第二种，使用泛型类或泛型方法")])]),t._v(" "),a("h1",{attrs:{id:"_1-声明泛型类的类型参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-声明泛型类的类型参数"}},[t._v("#")]),t._v(" 1  "),a("T",[t._v("声明泛型类的类型参数")])],1),t._v(" "),a("p",[t._v("List"),a("T",[t._v("最应该出现的地方，应该是定义一个泛型List容器\n但List是库里自带的容器，看看ArrayList的源码头一行：\n"),a("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-84ea03662073cea7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}}),t._v("\nArrayList"),a("E",[t._v("中的“E”也是类型参数。只是表示容器中元素Element的时候，习惯用“E”\n换一个简单的例子，我们自己定义一个新泛型容器叫Box"),a("T",[t._v("。")])],1)],1)],1),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("class Box<T>{\n    private T item1;\n    private T item2;\n}\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[t._v("为什么这里要用类型参数？因为这是一种”约束“，为了保证Box里的item1, item2都是同一个类型T。Box"),a("String",[t._v("，代表两个item都是String。Box"),a("Integer",[t._v("里两个item都是Integer。")])],1)],1),t._v(" "),a("p",[t._v("List容器库里都帮我们写好了，所以我们是不会去定义List"),a("T",[t._v("的")])],1),t._v(" "),a("p",[t._v("那什么时候会出现List"),a("T",[t._v("\n要么是作为泛型类的成员字段或成员方法的参数间接出现。还是刚才Box"),a("T",[t._v("的例子，")])],1)],1),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("class Box<T>{\n    private List<T> item;\n    public List<T> get(){return item;}\n    public void set(List<T> t){item=t;}\n}\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("p",[t._v("现在Box类里有三个地方出现了List"),a("T",[t._v("：")])],1),t._v(" "),a("ul",[a("li",[t._v("成员字段item的类型")]),t._v(" "),a("li",[t._v("get( )方法的返回值")]),t._v(" "),a("li",[t._v("set( )方法的参数")])]),t._v(" "),a("p",[t._v("这里写成List"),a("T",[t._v("为了表示和Box"),a("T",[t._v("类型参数保持一致")])],1)],1),t._v(" "),a("h1",{attrs:{id:"_2-声明泛型方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-声明泛型方法"}},[t._v("#")]),t._v(" 2 "),a("T",[t._v("声明泛型方法")])],1),t._v(" "),a("p",[t._v("另外一种会出现List"),a("T",[t._v("的地方是泛型方法\n比如Function类的reduce是个静态泛型方法，负责对列表里的所有元素求和\n这里的List"),a("T",[t._v("出现在参数，函数返回值和函数内部，也是为了保持泛型类型的一致性")])],1)],1),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("class Fuction{\n    public static <T> List<T> reduce(List<T> list){\n        //...do something\n    }\n}\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("h1",{attrs:{id:"_3-声明泛型类不能用无界通配符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-声明泛型类不能用无界通配符"}},[t._v("#")]),t._v(" 3  声明泛型类不能用无界通配符<?>")]),t._v(" "),a("p",[t._v("反观List<?>，首先要明确"),a("code",[t._v("通配符不能拿来声明泛型")]),t._v('\n像下面这样用通配符"?"来表示类型参数的约束是不行的\n'),a("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-ffe6bcebda2d1168.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"Error Example"}}),t._v("\n通配符是拿来使用定义好的泛型的\n比如用<?>声明List容器的变量类型，然后用一个实例对象给它赋值的时候就比较灵活。\n"),a("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-b0642daae444a300.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}})]),t._v(" "),a("h1",{attrs:{id:"_4-的坑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-的坑"}},[t._v("#")]),t._v(" 4 <?>的坑")]),t._v(" "),a("p",[t._v("List<?>这个写法非常坑。因为，这时候通配符会捕获具体的String类型，但编译器不叫它String，而是起个临时的代号，比如”capture#1“\n所以以后再也不能往list里存任何元素，包括String,唯一能存的就是null\n"),a("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-7f914a83dbef3b07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}}),t._v(" "),a("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-973e44c8d7a90e88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}}),t._v("\n另外如果拿List<?>做参数，也会有奇妙的事情发生。还是刚才Box"),a("T",[t._v("的例子，有get()和set()两个方法，一个存，一个取。\n"),a("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-1ae09c9e4b5cfdb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}}),t._v("\n新的getSet()方法，只是把item先用get()方法读出来，然后再用set()方法存回去。按理说不可能有问题。实际运行却会报错。")])],1),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("error: incompatible types: Object cannot be converted to capture#1\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("原因和前面一样，通配符box<?>.set()的参数类型被编译器捕获，命名为capture#1，和box<?>.get()返回的Object对象无法匹配")]),t._v(" "),a("p",[t._v("解决方法，是要给getSet()方法写一个辅助函数\n"),a("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4685968-7e4ad9a8b84347bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}})]),t._v(" "),a("h1",{attrs:{id:"_5-有界通配符-extends-xxx-super-xxx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-有界通配符-extends-xxx-super-xxx"}},[t._v("#")]),t._v(" 5. 有界通配符<? extends XXX>，<? super XXX>")]),t._v(" "),a("p",[t._v("实际更常用的是<? extends XXX>或者<? super XXX>两种，带有上下界的通配符")])])}),[],!1,null,null,null);s.default=i.exports}}]);