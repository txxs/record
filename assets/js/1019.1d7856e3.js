(window.webpackJsonp=window.webpackJsonp||[]).push([[1019],{1416:function(r,t,_){"use strict";_.r(t);var v=_(13),e=Object(v.a)({},(function(){var r=this,t=r.$createElement,_=r._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[_("p",{attrs:{align:"center"}},[_("a",{attrs:{href:"https://programmercarl.com/other/kstar.html",target:"_blank"}},[_("img",{attrs:{src:"https://code-thinking-1253855093.file.myqcloud.com/pics/20210924105952.png",width:"1000"}})])]),_("p",{attrs:{align:"center"}},[_("strong",[_("a",{attrs:{href:"https://mp.weixin.qq.com/s/tqCxrMEU-ajQumL1i8im9A"}},[r._v("参与本项目")]),r._v("，贡献其他语言版本的代码，拥抱开源，让更多学习算法的小伙伴们收益！")])]),r._v(" "),_("h1",{attrs:{id:"栈与队列的理论基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栈与队列的理论基础"}},[r._v("#")]),r._v(" 栈与队列的理论基础")]),r._v(" "),_("p",[r._v("首先我们在"),_("a",{attrs:{href:"https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("栈与队列：来看看栈和队列不为人知的一面"),_("OutboundLink")],1),r._v("中讲解了栈和队列的理论基础。")]),r._v(" "),_("p",[r._v("里面提到了灵魂四问：")]),r._v(" "),_("ol",[_("li",[r._v("C++中stack，queue 是容器么？")]),r._v(" "),_("li",[r._v("我们使用的stack，queue是属于那个版本的STL？")]),r._v(" "),_("li",[r._v("我们使用的STL中stack，queue是如何实现的？")]),r._v(" "),_("li",[r._v("stack，queue 提供迭代器来遍历空间么？")])]),r._v(" "),_("p",[r._v("相信不仅仅是C++中有这些问题，那么大家使用其他编程语言，也可以考虑一下这四个问题，栈和队列是如何实现的。")]),r._v(" "),_("p",[r._v("栈与队列是我们熟悉的不能再熟悉的数据结构，但它们的底层实现，很多同学都比较模糊，这其实就是基础所在。")]),r._v(" "),_("p",[r._v("可以出一道面试题：栈里面的元素在内存中是连续分布的么？")]),r._v(" "),_("p",[r._v("这个问题有两个陷阱：")]),r._v(" "),_("ul",[_("li",[r._v("陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中是不是连续分布。")]),r._v(" "),_("li",[r._v("陷阱2：缺省情况下，默认底层容器是deque，那么deque的在内存中的数据分布是什么样的呢？ 答案是：不连续的，下文也会提到deque。")])]),r._v(" "),_("p",[r._v("所以这就是考察候选者基础知识扎不扎实的好问题。")]),r._v(" "),_("p",[r._v("大家还是要多多重视起来！")]),r._v(" "),_("p",[r._v("了解了栈与队列基础之后，那么可以用"),_("a",{attrs:{href:"https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("栈与队列：栈实现队列"),_("OutboundLink")],1),r._v(" 和 "),_("a",{attrs:{href:"https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("栈与队列：队列实现栈"),_("OutboundLink")],1),r._v(" 来练习一下栈与队列的基本操作。")]),r._v(" "),_("p",[r._v("值得一提的是，用"),_("a",{attrs:{href:"https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("栈与队列：用队列实现栈还有点别扭"),_("OutboundLink")],1),r._v("中，其实只用一个队列就够了。")]),r._v(" "),_("p",[_("strong",[r._v("一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。")])]),r._v(" "),_("h1",{attrs:{id:"栈经典题目"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栈经典题目"}},[r._v("#")]),r._v(" 栈经典题目")]),r._v(" "),_("h2",{attrs:{id:"栈在系统中的应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栈在系统中的应用"}},[r._v("#")]),r._v(" 栈在系统中的应用")]),r._v(" "),_("p",[r._v("如果还记得编译原理的话，编译器在 词法分析的过程中处理括号、花括号等这个符号的逻辑，就是使用了栈这种数据结构。")]),r._v(" "),_("p",[r._v("再举个例子，linux系统中，cd这个进入目录的命令我们应该再熟悉不过了。")]),r._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[r._v("cd a/b/c/../../\n")])]),r._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[r._v("1")]),_("br")])]),_("p",[r._v("这个命令最后进入a目录，系统是如何知道进入了a目录呢 ，这就是栈的应用。"),_("strong",[r._v("这在leetcode上也是一道题目，编号：71. 简化路径，大家有空可以做一下。")])]),r._v(" "),_("p",[_("strong",[r._v("递归的实现是栈：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中")]),r._v("，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。")]),r._v(" "),_("p",[r._v("所以栈在计算机领域中应用是非常广泛的。")]),r._v(" "),_("p",[r._v("有的同学经常会想学的这些数据结构有什么用，也开发不了什么软件，大多数同学说的软件应该都是可视化的软件例如APP、网站之类的，那都是非常上层的应用了，底层很多功能的实现都是基础的数据结构和算法。")]),r._v(" "),_("p",[_("strong",[r._v("所以数据结构与算法的应用往往隐藏在我们看不到的地方！")])]),r._v(" "),_("h2",{attrs:{id:"括号匹配问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#括号匹配问题"}},[r._v("#")]),r._v(" 括号匹配问题")]),r._v(" "),_("p",[r._v("在"),_("a",{attrs:{href:"https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("栈与队列：系统中处处都是栈的应用"),_("OutboundLink")],1),r._v("中我们讲解了括号匹配问题。")]),r._v(" "),_("p",[_("strong",[r._v("括号匹配是使用栈解决的经典问题。")])]),r._v(" "),_("p",[r._v("建议要写代码之前要分析好有哪几种不匹配的情况，如果不动手之前分析好，写出的代码也会有很多问题。")]),r._v(" "),_("p",[r._v("先来分析一下 这里有三种不匹配的情况，")]),r._v(" "),_("ol",[_("li",[r._v("第一种情况，字符串里左方向的括号多余了 ，所以不匹配。")]),r._v(" "),_("li",[r._v("第二种情况，括号没有多余，但是 括号的类型没有匹配上。")]),r._v(" "),_("li",[r._v("第三种情况，字符串里右方向的括号多余了，所以不匹配。")])]),r._v(" "),_("p",[r._v("这里还有一些技巧，在匹配左括号的时候，右括号先入栈，就只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈代码实现要简单的多了！")]),r._v(" "),_("h2",{attrs:{id:"字符串去重问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#字符串去重问题"}},[r._v("#")]),r._v(" 字符串去重问题")]),r._v(" "),_("p",[r._v("在"),_("a",{attrs:{href:"https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("栈与队列：匹配问题都是栈的强项"),_("OutboundLink")],1),r._v("中讲解了字符串去重问题。\n1047. 删除字符串中的所有相邻重复项")]),r._v(" "),_("p",[r._v("思路就是可以把字符串顺序放到一个栈中，然后如果相同的话 栈就弹出，这样最后栈里剩下的元素都是相邻不相同的元素了。")]),r._v(" "),_("h2",{attrs:{id:"逆波兰表达式问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#逆波兰表达式问题"}},[r._v("#")]),r._v(" 逆波兰表达式问题")]),r._v(" "),_("p",[r._v("在"),_("a",{attrs:{href:"https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("栈与队列：有没有想过计算机是如何处理表达式的？"),_("OutboundLink")],1),r._v("中讲解了求逆波兰表达式。")]),r._v(" "),_("p",[r._v("本题中每一个子表达式要得出一个结果，然后拿这个结果再进行运算，那么"),_("strong",[r._v("这岂不就是一个相邻字符串消除的过程，和"),_("a",{attrs:{href:"https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("栈与队列：匹配问题都是栈的强项"),_("OutboundLink")],1),r._v("中的对对碰游戏是不是就非常像了。")])]),r._v(" "),_("h1",{attrs:{id:"队列的经典题目"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#队列的经典题目"}},[r._v("#")]),r._v(" 队列的经典题目")]),r._v(" "),_("h2",{attrs:{id:"滑动窗口最大值问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口最大值问题"}},[r._v("#")]),r._v(" 滑动窗口最大值问题")]),r._v(" "),_("p",[r._v("在"),_("a",{attrs:{href:"https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("栈与队列：滑动窗口里求最大值引出一个重要数据结构"),_("OutboundLink")],1),r._v("中讲解了一种数据结构：单调队列。")]),r._v(" "),_("p",[r._v("这道题目还是比较绕的，如果第一次遇到这种题目，需要反复琢磨琢磨")]),r._v(" "),_("p",[r._v("主要思想是"),_("strong",[r._v("队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。")])]),r._v(" "),_("p",[r._v("那么这个维护元素单调递减的队列就叫做"),_("strong",[r._v("单调队列，即单调递减或单调递增的队列。C++中没有直接支持单调队列，需要我们自己来一个单调队列")])]),r._v(" "),_("p",[r._v("而且"),_("strong",[r._v("不要以为实现的单调队列就是 对窗口里面的数进行排序，如果排序的话，那和优先级队列又有什么区别了呢。")])]),r._v(" "),_("p",[r._v("设计单调队列的时候，pop，和push操作要保持如下规则：")]),r._v(" "),_("ol",[_("li",[r._v("pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作")]),r._v(" "),_("li",[r._v("push(value)：如果push的元素value大于入口元素的数值，那么就将队列出口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止")])]),r._v(" "),_("p",[r._v("保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。")]),r._v(" "),_("p",[r._v("一些同学还会对单调队列都有一些困惑，首先要明确的是，"),_("strong",[r._v("题解中单调队列里的pop和push接口，仅适用于本题。")])]),r._v(" "),_("p",[_("strong",[r._v("单调队列不是一成不变的，而是不同场景不同写法")]),r._v("，总之要保证队列里单调递减或递增的原则，所以叫做单调队列。")]),r._v(" "),_("p",[_("strong",[r._v("不要以为本地中的单调队列实现就是固定的写法。")])]),r._v(" "),_("p",[r._v("我们用deque作为单调队列的底层数据结构，C++中deque是stack和queue默认的底层实现容器（这个我们之前已经讲过），deque是可以两边扩展的，而且deque里元素并不是严格的连续分布的。")]),r._v(" "),_("h2",{attrs:{id:"求前-k-个高频元素"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#求前-k-个高频元素"}},[r._v("#")]),r._v(" 求前 K 个高频元素")]),r._v(" "),_("p",[r._v("在"),_("a",{attrs:{href:"https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("栈与队列：求前 K 个高频元素和队列有啥关系？"),_("OutboundLink")],1),r._v("中讲解了求前 K 个高频元素。")]),r._v(" "),_("p",[r._v("通过求前 K 个高频元素，引出另一种队列就是"),_("strong",[r._v("优先级队列")]),r._v("。")]),r._v(" "),_("p",[r._v("什么是优先级队列呢？")]),r._v(" "),_("p",[r._v("其实"),_("strong",[r._v("就是一个披着队列外衣的堆")]),r._v("，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。")]),r._v(" "),_("p",[r._v("而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？")]),r._v(" "),_("p",[r._v("缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。")]),r._v(" "),_("p",[r._v("什么是堆呢？")]),r._v(" "),_("p",[_("strong",[r._v("堆是一颗完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。")]),r._v(" 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。")]),r._v(" "),_("p",[r._v("所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。")]),r._v(" "),_("p",[r._v("本题就要"),_("strong",[r._v("使用优先级队列来对部分频率进行排序。")]),r._v("  注意这里是对部分数据进行排序而不需要对所有数据排序！")]),r._v(" "),_("p",[r._v("所以排序的过程的时间复杂度是$O(\\log k)$，整个算法的时间复杂度是$O(n\\log k)$。")]),r._v(" "),_("h1",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[r._v("#")]),r._v(" 总结")]),r._v(" "),_("p",[r._v("在栈与队列系列中，我们强调栈与队列的基础，也是很多同学容易忽视的点。")]),r._v(" "),_("p",[r._v("使用抽象程度越高的语言，越容易忽视其底层实现，而C++相对来说是比较接近底层的语言。")]),r._v(" "),_("p",[r._v("我们用栈实现队列，用队列实现栈来掌握的栈与队列的基本操作。")]),r._v(" "),_("p",[r._v("接着，通过括号匹配问题、字符串去重问题、逆波兰表达式问题来系统讲解了栈在系统中的应用，以及使用技巧。")]),r._v(" "),_("p",[r._v("通过求滑动窗口最大值，以及前K个高频元素介绍了两种队列：单调队列和优先级队列，这是特殊场景解决问题的利器，是一定要掌握的。")]),r._v(" "),_("p",[r._v("好了，栈与队列我们就总结到这里了，接下来Carl就要带大家开启新的篇章了，大家加油！")]),r._v(" "),_("h2",{attrs:{id:"其他语言版本"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#其他语言版本"}},[r._v("#")]),r._v(" 其他语言版本")]),r._v(" "),_("p",[r._v("Java：")]),r._v(" "),_("p",[r._v("Python：")]),r._v(" "),_("p",[r._v("Go：")]),r._v(" "),_("hr"),r._v(" "),_("div",{attrs:{align:"center"}},[_("img",{attrs:{src:"https://code-thinking.cdn.bcebos.com/pics/01二维码一.jpg",width:"500"}})])])}),[],!1,null,null,null);t.default=e.exports}}]);