(window.webpackJsonp=window.webpackJsonp||[]).push([[982],{1373:function(t,_,e){"use strict";e.r(_);var v=e(13),i=Object(v.a)({},(function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"代码风格"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码风格"}},[t._v("#")]),t._v(" 代码风格")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("不甚了解")]),t._v("是不能更了解的意思，这个地方应该使用存疑。")]),t._v(" "),e("li",[e("code",[t._v("后期在不断优化")]),t._v("，'在'应为'再'。")]),t._v(" "),e("li",[e("code",[t._v("googlec++编程规范")]),t._v(",Google拼写错误")])]),t._v(" "),e("h2",{attrs:{id:"代码本地编译"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码本地编译"}},[t._v("#")]),t._v(" 代码本地编译")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("粘到本例来运行")]),t._v("存疑，应为本地")]),t._v(" "),e("li",[e("code",[t._v("本题运行")]),t._v("存疑，应为本地")])]),t._v(" "),e("h2",{attrs:{id:"acm二叉树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#acm二叉树"}},[t._v("#")]),t._v(" ACM二叉树")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("左孩子和右孩子的下标不太好理解。我给出证明过程：")]),t._v(" "),e("p",[t._v("如果父节点在第$k$层，第$m,m \\in [0,2^k]$个节点，则其左孩子所在的位置必然为$k+1$层，第$2*(m-1)+1$个节点。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("计算父节点在数组中的索引：\n$$\nindex_{father}=(\\sum_{i=0}^{i=k-1}2^i)+m-1=2^k-1+m-1\n$$")])]),t._v(" "),e("li",[e("p",[t._v("计算左子节点在数组的索引：\n$$\nindex_{left}=(\\sum_{i=0}^{i=k}2^i)+2*m-1-1=2^{k+1}+2m-3\n$$")])]),t._v(" "),e("li",[e("p",[t._v("故左孩子的下表为$index_{left}=index_{father}\\times2+1$，同理可得到右子孩子的索引关系。也可以直接在左子孩子的基础上"),e("code",[t._v("+1")]),t._v("。")])])])])])])}),[],!1,null,null,null);_.default=i.exports}}]);