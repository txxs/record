(window.webpackJsonp=window.webpackJsonp||[]).push([[1399],{1791:function(a,t,_){"use strict";_.r(t);var s=_(13),v=Object(s.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"_1-项目中如何使用缓存的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-项目中如何使用缓存的"}},[a._v("#")]),a._v(" 1   项目中如何使用缓存的？")]),a._v(" "),_("p",[a._v("这个问题大家都懂，反正得有应用场景。")]),a._v(" "),_("h1",{attrs:{id:"_2-为啥用缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-为啥用缓存"}},[a._v("#")]),a._v(" 2 为啥用缓存？")]),a._v(" "),_("p",[a._v("缓存，主要用途如下：")]),a._v(" "),_("h2",{attrs:{id:"_2-1-高性能"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-高性能"}},[a._v("#")]),a._v(" 2.1 高性能")]),a._v(" "),_("h3",{attrs:{id:"mysql太久-受不了"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql太久-受不了"}},[a._v("#")]),a._v(" MySQL太久，受不了!")]),a._v(" "),_("p",[a._v("假设你有个操作，一个请求过来，各种操作MySQL，半天查出来一个结果，耗时600ms。\n但这结果可能接下来几个小时都不会再变，或者变了也可以不用立即反馈给用户。那么此时咋办？")]),a._v(" "),_("h3",{attrs:{id:"使用缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用缓存"}},[a._v("#")]),a._v(" 使用缓存！")]),a._v(" "),_("p",[a._v("折腾600ms查出来的结果，扔缓存里，一个key对应一个value，下次再有人查，别走MySQL折腾600ms了。\n直接从缓存里，通过一个key查出来一个value，2ms搞定。性能提升300倍。")]),a._v(" "),_("ul",[_("li",[a._v("即高性能\n就是把你一些复杂操作耗时查出来的结果，如果确定后面不咋变了，然后但是马上还有很多读请求，那么直接结果放缓存，后面直接读缓存就好了。")])]),a._v(" "),_("h3",{attrs:{id:"应用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[a._v("#")]),a._v(" 应用场景")]),a._v(" "),_("p",[a._v("某商品信息，在1天之内都不会改变。但是这个商品每次查询一次要耗费2s , 1天要被浏览百万次")]),a._v(" "),_("p",[a._v("用户1请求数据1，第一次检查，发现缓存里没数据1，从 MySQL 里查询耗时 800ms，假设数据1在10分钟之内不再变化\n第一次查询之后放入缓存。如果后续数据1变化，只要系统A修改数据库的同时，也更新缓存里的值即可。\n第二次检查缓存，缓存里有数据1，直接返回。从缓存里获取数据1返回给用户2 ,耗费10ms")]),a._v(" "),_("p",[a._v("假设10分钟之内有1000个用户都查询了同一个数据\n10分钟之内，那1000个用户，每个人查询这个数据都感觉很慢, 800ms\n假设10分钟之内数据没有变化，然后1000个人来查询这条数据，第一个人是800ms ,后面999个人都是\n取数据10ms就可以看到结果")]),a._v(" "),_("h2",{attrs:{id:"_2-2-高并发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-高并发"}},[a._v("#")]),a._v(" 2.2 高并发")]),a._v(" "),_("h3",{attrs:{id:"应用场景-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-2"}},[a._v("#")]),a._v(" 应用场景")]),a._v(" "),_("p",[a._v("查电商里的商品, 3/4的数据放在缓存, 1/4的数据留在数据库。")]),a._v(" "),_("p",[a._v("在中午高峰期,有100万用户同时访问系统A，每秒有4000个请求去查询MySQL，其中3000个请求走缓存; 1000个请求走MySQL")]),a._v(" "),_("ul",[_("li",[a._v("为什么数据库支撑不了高并发，然后缓存可以支撑高并发呢?\n缓存是走内存的，内存天然就可以支撑。别说是4000/s , 4万/s请求也没问题\n但是数据库一般建议并发请求不要超过2000/s，如果数据承载每秒4000个请求，可能会宕机。")])]),a._v(" "),_("p",[a._v("MySQL天然支持不好高并发。MySQL单机支撑到2000qps就开始容易报警。")]),a._v(" "),_("p",[a._v("所以要是你有个系统，高峰期一秒钟过来的请求有1万，那一个 MySQL单机绝对会死掉。\n你这个时候就只能上缓存，把很多数据放缓存，别放mysql。\n缓存功能简单，说白了就是key-value式操作，单机支撑的并发量轻松一秒几万十几万，并发量是MySQL单机的几十倍。")]),a._v(" "),_("h1",{attrs:{id:"_3-所以结合上述场景-为啥要用缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-所以结合上述场景-为啥要用缓存"}},[a._v("#")]),a._v(" 3 所以结合上述场景，为啥要用缓存？")]),a._v(" "),_("p",[a._v("一般项目里没啥高并发，别折腾了，直接高性能场景，就思考有没有可以缓存结果的复杂查询场景，后续可以大幅度提升性能，优化用户体验。")]),a._v(" "),_("h1",{attrs:{id:"_4-缓存的不良后果"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-缓存的不良后果"}},[a._v("#")]),a._v(" 4 缓存的不良后果")]),a._v(" "),_("p",[a._v("常见的缓存问题：")]),a._v(" "),_("ul",[_("li",[a._v("缓存与数据库双写不一致")]),a._v(" "),_("li",[a._v("缓存雪崩")]),a._v(" "),_("li",[a._v("缓存穿透")]),a._v(" "),_("li",[a._v("缓存并发竞争")])])])}),[],!1,null,null,null);t.default=v.exports}}]);