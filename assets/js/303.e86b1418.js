(window.webpackJsonp=window.webpackJsonp||[]).push([[303],{687:function(t,a,s){"use strict";s.r(a);var v=s(13),h=Object(v.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"一致-hash-算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一致-hash-算法"}},[t._v("#")]),t._v(" 一致 Hash 算法")]),t._v(" "),s("p",[t._v("分布式缓存中，如何将数据均匀的分散到各个节点中，并且尽量的在加减节点时能使受影响的数据最少。")]),t._v(" "),s("h2",{attrs:{id:"hash-取模"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hash-取模"}},[t._v("#")]),t._v(" Hash 取模")]),t._v(" "),s("p",[t._v("随机放置就不说了，会带来很多问题。通常最容易想到的方案就是 "),s("code",[t._v("hash 取模")]),t._v("了。")]),t._v(" "),s("p",[t._v("可以将传入的 Key 按照 "),s("code",[t._v("index = hash(key) % N")]),t._v(" 这样来计算出需要存放的节点。其中 hash 函数是一个将字符串转换为正整数的哈希映射方法，N 就是节点的数量。")]),t._v(" "),s("p",[t._v("这样可以满足数据的均匀分配，但是这个算法的容错性和扩展性都较差。")]),t._v(" "),s("p",[t._v("比如增加或删除了一个节点时，所有的 Key 都需要重新计算，显然这样成本较高，为此需要一个算法满足分布均匀同时也要有良好的容错性和拓展性。")]),t._v(" "),s("h2",{attrs:{id:"一致-hash-算法-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一致-hash-算法-2"}},[t._v("#")]),t._v(" 一致 Hash 算法")]),t._v(" "),s("p",[t._v("一致 Hash 算法是将所有的哈希值构成了一个环，其范围在 "),s("code",[t._v("0 ~ 2^32-1")]),t._v("。如下图：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://txxs.github.io/pic/javainterview/%E4%B8%80%E8%87%B4%E6%80%A7hash1.jpg",alt:""}})]),t._v(" "),s("p",[t._v("之后将各个节点散列到这个环上，可以用节点的 IP、hostname 这样的唯一性字段作为 Key 进行 "),s("code",[t._v("hash(key)")]),t._v("，散列之后如下：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://txxs.github.io/pic/javainterview/%E4%B8%80%E8%87%B4%E6%80%A7hash2.jpg",alt:""}})]),t._v(" "),s("p",[t._v("之后需要将数据定位到对应的节点上，使用同样的 "),s("code",[t._v("hash 函数")]),t._v(" 将 Key 也映射到这个环上。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://txxs.github.io/pic/javainterview/%E4%B8%80%E8%87%B4%E6%80%A7hash3.jpg",alt:""}})]),t._v(" "),s("p",[t._v("这样按照顺时针方向就可以把 k1 定位到 "),s("code",[t._v("N1节点")]),t._v("，k2 定位到 "),s("code",[t._v("N3节点")]),t._v("，k3 定位到 "),s("code",[t._v("N2节点")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"容错性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#容错性"}},[t._v("#")]),t._v(" 容错性")]),t._v(" "),s("p",[t._v("这时假设 N1 宕机了：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://txxs.github.io/pic/javainterview/%E4%B8%80%E8%87%B4%E6%80%A7hash4.jpg",alt:""}})]),t._v(" "),s("p",[t._v("依然根据顺时针方向，k2 和 k3 保持不变，只有 k1 被重新映射到了 N3。这样就很好的保证了容错性，当一个节点宕机时只会影响到少少部分的数据。")]),t._v(" "),s("h3",{attrs:{id:"拓展性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#拓展性"}},[t._v("#")]),t._v(" 拓展性")]),t._v(" "),s("p",[t._v("当新增一个节点时:")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://txxs.github.io/pic/javainterview/%E4%B8%80%E8%87%B4%E6%80%A7hash5.jpg",alt:""}})]),t._v(" "),s("p",[t._v("在 N2 和 N3 之间新增了一个节点 N4 ，这时会发现受印象的数据只有 k3，其余数据也是保持不变，所以这样也很好的保证了拓展性。")]),t._v(" "),s("h2",{attrs:{id:"虚拟节点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟节点"}},[t._v("#")]),t._v(" 虚拟节点")]),t._v(" "),s("p",[t._v("到目前为止该算法依然也有点问题:")]),t._v(" "),s("p",[t._v("当节点较少时会出现数据分布不均匀的情况：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://txxs.github.io/pic/javainterview/%E4%B8%80%E8%87%B4%E6%80%A7hash6.jpg",alt:""}})]),t._v(" "),s("p",[t._v("这样会导致大部分数据都在 N1 节点，只有少量的数据在 N2 节点。")]),t._v(" "),s("p",[t._v("为了解决这个问题，一致哈希算法引入了虚拟节点。将每一个节点都进行多次 hash，生成多个节点放置在环上称为虚拟节点:")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://txxs.github.io/pic/javainterview/%E4%B8%80%E8%87%B4%E6%80%A7hash7.jpg",alt:""}})]),t._v(" "),s("p",[t._v("计算时可以在 IP 后加上编号来生成哈希值。")]),t._v(" "),s("p",[t._v("这样只需要在原有的基础上多一步由虚拟节点映射到实际节点的步骤即可让少量节点也能满足均匀性。")]),t._v(" "),s("p",[t._v("https://github.com/crossoverJie/JCSprout/blob/master/MD/Consistent-Hash.md")]),t._v(" "),s("p",[t._v("欢迎光临"),s("a",{attrs:{href:"http://www.wangtianyi.top/?utm_source=github&utm_medium=github",target:"_blank",rel:"noopener noreferrer"}},[t._v("我的博客"),s("OutboundLink")],1),t._v("，发现更多技术资源~")])])}),[],!1,null,null,null);a.default=h.exports}}]);