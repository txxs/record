(window.webpackJsonp=window.webpackJsonp||[]).push([[1192],{1585:function(t,a,s){"use strict";s.r(a);var _=s(13),e=Object(_.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("默认使用MySQL 5.5后的InnoDB引擎。")]),t._v(" "),s("h1",{attrs:{id:"_1-隔离性与隔离级别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-隔离性与隔离级别"}},[t._v("#")]),t._v(" 1 隔离性与隔离级别")]),t._v(" "),s("p",[t._v("ACID的I - “隔离性”。当db上有多事务同时执行时，可能出现如下问题：")]),t._v(" "),s("ul",[s("li",[t._v("脏读（dirty read）")]),t._v(" "),s("li",[t._v("不可重复读（non-repeatable read）")]),t._v(" "),s("li",[t._v("幻读（phantom read）")])]),t._v(" "),s("p",[t._v("为解决上述问题，隔离级别诞生了。级别越高，性能越低。因此要根据业务折中选择。")]),t._v(" "),s("h2",{attrs:{id:"_1-1-事务隔离级别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-事务隔离级别"}},[t._v("#")]),t._v(" 1.1 事务隔离级别")]),t._v(" "),s("ul",[s("li",[t._v("读未提交（read uncommitted，RU）\n一个事务还没提交，它的变更就能被其它事务看到")]),t._v(" "),s("li",[t._v("读已提交（read committed，RC）\n一个事务提交后，其变更才会被其他事务看到")]),t._v(" "),s("li",[t._v("可重复读（repeatable read，RR）\n一个事务执行过程中看到的数据，和该事务在启动时看到的数据一致。\n自然未提交的变更对其他事务也是不可见的。一个事务启动时，能够看到所有已提交的事务结果。但之后的该事务执行期间，其他事务的更新对它就不可见了")]),t._v(" "),s("li",[t._v("串行化（serializable）\n对同行记录，“写”加“写锁”，“读”加“读锁”。出现读写锁冲突时，后访问的事务必须等前一个事务执行完成")])]),t._v(" "),s("h2",{attrs:{id:"_1-2-示例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-示例"}},[t._v("#")]),t._v(" 1.2 示例")]),t._v(" "),s("p",[t._v("假设表T中仅一列，一行值1：")]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("create")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("table")]),t._v(" T"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("engine")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("InnoDB")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("insert")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("into")]),t._v(" T"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("values")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("ul",[s("li",[t._v("如下为按照时间顺序执行两个事务的行为。（B 比 A 稍后被访问）")])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("事务 A")]),t._v(" "),s("th",[t._v("事务 B")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("启动事务，查询得到值 1")]),t._v(" "),s("td",[t._v("启动事务")])]),t._v(" "),s("tr",[s("td"),t._v(" "),s("td",[t._v("查询得到值 1")])]),t._v(" "),s("tr",[s("td"),t._v(" "),s("td",[t._v("将 1改成 2")])]),t._v(" "),s("tr",[s("td",[t._v("查询得到值 V1")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td"),t._v(" "),s("td",[t._v("提交事务B")])]),t._v(" "),s("tr",[s("td",[t._v("查询得到值 V2")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("提交事务A")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("查询得到值 V3")]),t._v(" "),s("td")])])]),t._v(" "),s("p",[t._v("下面具体来看不同隔离级别的事务A返回结果，即V1、V2、V3是什么。")]),t._v(" "),s("ul",[s("li",[t._v("读未提交\n显然读取了未提交的事务B修改后的值都是2")]),t._v(" "),s("li",[t._v("读已提交\nV1是1；读取到提交后的B，V2、V3值为2")]),t._v(" "),s("li",[t._v("可重复读\nV1、V2（事务在执行期间，即未提交前，看到的数据全程一致）是1，V3是2")]),t._v(" "),s("li",[t._v("串行化\n事务B执行“将1改成2”时，会被锁。直到事务A提交后，事务B（后访问的事务）才可继续执行。\n所以在A看来， V1、V2是1，V3是2。")])]),t._v(" "),s("h2",{attrs:{id:"_1-3-原来是视图"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-原来是视图"}},[t._v("#")]),t._v(" 1.3 原来是视图")]),t._v(" "),s("p",[t._v("实现上，db里会创建一个视图，访问时以视图的逻辑结果为准。")]),t._v(" "),s("ul",[s("li",[t._v("可重复读\n视图在事务启动时创建，整个事务存在期间都只用该视图")]),t._v(" "),s("li",[t._v("读提交\n视图在每个SQL语句开始执行时创建。RC下，一个select语句S1在它开始时刻照快照，然后S1语句运行期间如果有其他并发事务提交并且他们正好修改了满足S1过滤条件的行，那么S1并不能看到那些事务最新的改动，返回的是S1的快照中已提交的事务的改动。")]),t._v(" "),s("li",[t._v("读未提交\n直接返回记录上的最新值，无视图")]),t._v(" "),s("li",[t._v("串行化\n直接加锁避免并行（注意这里不是并发概念的同时间段）访问")])]),t._v(" "),s("h1",{attrs:{id:"_2-隔离级别的配置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-隔离级别的配置"}},[t._v("#")]),t._v(" 2 隔离级别的配置")]),t._v(" "),s("p",[t._v("若想更改，可将启动参数transaction-isolation的值set成READ-COMMITTED。")]),t._v(" "),s("p",[t._v("可用show variables来查看当前值。")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("show variables like 'transaction_isolation'")]),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200715234500847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_1,color_FFFFFF,t_70",alt:""}})])]),t._v(" "),s("h1",{attrs:{id:"_3-何时使用可重复读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-何时使用可重复读"}},[t._v("#")]),t._v(" 3 何时使用可重复读？")]),t._v(" "),s("p",[t._v("比如银行账户表。一个表存每月月底的余额，一个表存账单明细。")]),t._v(" "),s("ul",[s("li",[t._v("业务要求做数据校对\n即判断上月余额和当前余额的差额，是否与本月账单明细一致。")]),t._v(" "),s("li",[t._v("希望在校对过程中，即使有用户发生了一笔新的交易，也不影响校对结果\n这时候使用“可重复读”隔离级别就很方便。")])]),t._v(" "),s("p",[t._v("事务启动时的视图可认为是静态的，不受其他事务更新影响。")]),t._v(" "),s("h1",{attrs:{id:"_4-实现事务隔离-undo-log"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-实现事务隔离-undo-log"}},[t._v("#")]),t._v(" 4 实现事务隔离 - undo log")]),t._v(" "),s("p",[t._v("MySQL的每条记录在更新时都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可得到前一个状态的值。")]),t._v(" "),s("h2",{attrs:{id:"_4-1-示例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-示例"}},[t._v("#")]),t._v(" 4.1 示例")]),t._v(" "),s("p",[t._v("假设一个值从1被按顺改成2、3、4")]),t._v(" "),s("ul",[s("li",[t._v("undo log中的记录：\n"),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200911032936782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70#pic_center",alt:""}})])]),t._v(" "),s("blockquote",[s("p",[t._v("回滚段(rollback segment)")])]),t._v(" "),s("p",[t._v("当前值4，但在查询该记录时，在不同时刻启动事务有不同read-view。\n在视图A、B、C，该记录的值分别是1、2、4，同一记录在系统中可存在多版本，即多版本并发控制（MVCC）。")]),t._v(" "),s("p",[t._v("对read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。\n即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务不会冲突。")]),t._v(" "),s("h2",{attrs:{id:"何时删除undo-log"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#何时删除undo-log"}},[t._v("#")]),t._v(" 何时删除undo log")]),t._v(" "),s("p",[t._v("不需要时才删除。即系统会自己判断，当没有事务再用到这些undo log，undo log就会被删除。")]),t._v(" "),s("h2",{attrs:{id:"何时不需要undo-log"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#何时不需要undo-log"}},[t._v("#")]),t._v(" 何时不需要undo log")]),t._v(" "),s("p",[t._v("当系统里没有比该undo log更早的read-view时。")]),t._v(" "),s("h2",{attrs:{id:"意义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#意义"}},[t._v("#")]),t._v(" 意义")]),t._v(" "),s("p",[t._v("保证事务的原子性。")]),t._v(" "),s("ul",[s("li",[t._v("事务回滚, 一致性读、崩溃恢复")]),t._v(" "),s("li",[t._v("记录事务回滚时所需的撤消操作")]),t._v(" "),s("li",[t._v("一条 INSERT 语句，对应一条 DELETE 的 undo log")]),t._v(" "),s("li",[t._v("每个 UPDATE 语句，对应一条相反 UPDATE 的 undo log")])]),t._v(" "),s("h2",{attrs:{id:"保存位置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#保存位置"}},[t._v("#")]),t._v(" 保存位置")]),t._v(" "),s("ul",[s("li",[t._v("system tablespace (MySQL 5.7默认)")]),t._v(" "),s("li",[t._v("undo tablespaces (MySQL 8.0默认)")])]),t._v(" "),s("h1",{attrs:{id:"多版本并发控制-mvcc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多版本并发控制-mvcc"}},[t._v("#")]),t._v(" 多版本并发控制（MVCC）")]),t._v(" "),s("p",[t._v("使InnoDB支持一致性读")]),t._v(" "),s("ul",[s("li",[t._v("READ COMMITTED")]),t._v(" "),s("li",[t._v("REPEATABLE READ")])]),t._v(" "),s("p",[t._v("让查询不被阻塞、无需等待被其他事务持有的锁，这种技术手段可以增加并发度。")]),t._v(" "),s("p",[t._v("InnoDB保留被修改行的旧版本。查询正在被其他事务更新的数据时，会读取更新之前的版本。每行数据都存在一个版本号，每次更新时都更新该版本。这种技术在数据库领域的使用并不普遍。某些数据库，以及某些MySQL存储引擎都不支持。")]),t._v(" "),s("p",[t._v("聚簇索引的更新=替换更新\n二级索引的更新=删除+新建")]),t._v(" "),s("h1",{attrs:{id:"避免长事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#避免长事务"}},[t._v("#")]),t._v(" 避免长事务")]),t._v(" "),s("p",[t._v("长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问db里的任何数据，所以该事务提交之前，db里它可能用到的回滚记录都必须保留，导致大量占存储。")]),t._v(" "),s("p",[t._v("在MySQL 5.5及以前，undo log是跟数据字典一起放在ibdata文件，即使长事务最终提交，回滚段被清理，文件也不会变小。")]),t._v(" "),s("p",[t._v("除了对回滚段影响，长事务还占用锁资源，可能拖慢全库。")]),t._v(" "),s("h1",{attrs:{id:"_6-事务启动方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-事务启动方式"}},[t._v("#")]),t._v(" 6 事务启动方式")]),t._v(" "),s("h2",{attrs:{id:"_6-1-显式启动事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-显式启动事务"}},[t._v("#")]),t._v(" 6.1 显式启动事务")]),t._v(" "),s("p",[t._v("begin 或 start transaction 开启事务：")]),t._v(" "),s("ul",[s("li",[t._v("提交语句 commit")]),t._v(" "),s("li",[t._v("回滚语句 rollback")])]),t._v(" "),s("h2",{attrs:{id:"_6-2-set-autocommit-1"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-set-autocommit-1"}},[t._v("#")]),t._v(" 6.2 set autocommit=1")]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" autocommit"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" \n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("将该线程的自动提交关闭。如果你只执行一个select，事务就启动了，且不会自动提交。\n该事务会持续存在，直到主动执行commit 或 rollback，或断开连接。")]),t._v(" "),s("p",[t._v("有些客户端连接框架会默认连接成功后先执行")]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" autocommit"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("导致接下来的查询都在事务中，若是长连接，就导致意外的长事务。\n因此建议总用")]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" autocommit"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("显式启动事务。")]),t._v(" "),s("p",[t._v("频繁事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句交互次数。如果你也有这个顾虑，建议使用commit work and chain。")]),t._v(" "),s("p",[t._v("autocommit为1时，用begin显式启动的事务，若执行commit，则提交事务。\n若执行 commit work and chain，则是提交事务并自动启动下个事务，省去执行begin语句的开销。从程序开发的角度也能明确知道每个语句是否处于事务。")]),t._v(" "),s("h1",{attrs:{id:"_7-查询长事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-查询长事务"}},[t._v("#")]),t._v(" 7 查询长事务")]),t._v(" "),s("p",[t._v("information_schema库的innodb_trx表中查询长事务")]),t._v(" "),s("ul",[s("li",[t._v("查找持续时间超过60s的事务。")])]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" information_schema"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("innodb_trx "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v("\nTIME_TO_SEC"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("timediff"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("now")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("trx_started"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("60")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("h1",{attrs:{id:"_8-日备-v-s-周备"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-日备-v-s-周备"}},[t._v("#")]),t._v(" 8 日备 V.S 周备")]),t._v(" "),s("p",[t._v("好处是“最长恢复时间”更短。")]),t._v(" "),s("ul",[s("li",[t._v("一天一备\n最坏情况下需要应用一天的binlog。比如，你每天0点做一次全量备份，而要恢复出一个到昨天晚上23点的备份")]),t._v(" "),s("li",[t._v("一周一备\n最坏情况就要应用一周的binlog啦！")])]),t._v(" "),s("p",[t._v("系统的对应指标是RTO（恢复目标时间）。\n当然这个是有成本的，因为更频繁全量备份需要消耗更多存储空间，所以这个RTO是成本换来的，需要根据业务评估。")]),t._v(" "),s("h1",{attrs:{id:"_9-避免长事务对业务的影响"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-避免长事务对业务的影响"}},[t._v("#")]),t._v(" 9 避免长事务对业务的影响")]),t._v(" "),s("h2",{attrs:{id:"_9-1-应用开发端"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-应用开发端"}},[t._v("#")]),t._v(" 9.1 应用开发端")]),t._v(" "),s("p",[t._v("确认是否使用")]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" autocommit"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("确认可在测试环境中，把MySQL的general_log开启，随便跑个业务逻辑，通过general_log确认。\n一般框架如果设置该值，也会提供参数来控制，目标就是把它改成1。")]),t._v(" "),s("p",[t._v("确认是否有不必要的只读事务。有些框架不管什么语句先begin/commit框。有些是业务并没有这需要，但也把好几个select语句放到事务。这种只读事务可以去掉。")]),t._v(" "),s("p",[t._v("业务连接数据库时，根据业务预估，通过SET MAX_EXECUTION_TIME命令，控制每个语句执行最长时间，避免单语句意外执行太长时间。")]),t._v(" "),s("h2",{attrs:{id:"_9-2-数据库端"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-数据库端"}},[t._v("#")]),t._v(" 9.2 数据库端")]),t._v(" "),s("p",[t._v("监控 information_schema.Innodb_trx表，设置长事务阈值，超过就报警/或者kill。")]),t._v(" "),s("blockquote",[s("p",[t._v("Percona的pt-kill这个工具不错，推荐。")])]),t._v(" "),s("p",[t._v("在业务功能测试阶段要求输出所有的general_log，分析日志行为提前发现问题。\n使用的MySQL 5.6或更新版本，把innodb_undo_tablespaces设置成2或更大值。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。")])])}),[],!1,null,null,null);a.default=e.exports}}]);