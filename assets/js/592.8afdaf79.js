(window.webpackJsonp=window.webpackJsonp||[]).push([[592],{996:function(n,s,e){"use strict";e.r(s);var a=e(13),t=Object(a.a)({},(function(){var n=this,s=n.$createElement,e=n._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"table-of-contents"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#table-of-contents"}},[n._v("#")]),n._v(" Table of Contents")]),n._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"}},[n._v("公平锁和非公平锁")])]),n._v(" "),e("li",[e("a",{attrs:{href:"#condition"}},[n._v("Condition")]),n._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"#1-%E5%B0%86%E8%8A%82%E7%82%B9%E5%8A%A0%E5%85%A5%E5%88%B0%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97"}},[n._v("1. 将节点加入到条件队列")])]),n._v(" "),e("li",[e("a",{attrs:{href:"#2-%E5%AE%8C%E5%85%A8%E9%87%8A%E6%94%BE%E7%8B%AC%E5%8D%A0%E9%94%81"}},[n._v("2. 完全释放独占锁")])]),n._v(" "),e("li",[e("a",{attrs:{href:"#3-%E7%AD%89%E5%BE%85%E8%BF%9B%E5%85%A5%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"}},[n._v("3. 等待进入阻塞队列")])]),n._v(" "),e("li",[e("a",{attrs:{href:"#4-signal-%E5%94%A4%E9%86%92%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BD%AC%E7%A7%BB%E5%88%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"}},[n._v("4. signal 唤醒线程，转移到阻塞队列")])]),n._v(" "),e("li",[e("a",{attrs:{href:"#5-%E5%94%A4%E9%86%92%E5%90%8E%E6%A3%80%E6%9F%A5%E4%B8%AD%E6%96%AD%E7%8A%B6%E6%80%81"}},[n._v("5. 唤醒后检查中断状态")])]),n._v(" "),e("li",[e("a",{attrs:{href:"#6-%E8%8E%B7%E5%8F%96%E7%8B%AC%E5%8D%A0%E9%94%81"}},[n._v("6. 获取独占锁")])]),n._v(" "),e("li",[e("a",{attrs:{href:"#7-%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%AD%E7%8A%B6%E6%80%81"}},[n._v("7. 处理中断状态")])]),n._v(" "),e("li",[e("a",{attrs:{href:"#-%E5%B8%A6%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6%E7%9A%84-await"}},[n._v("* 带超时机制的 await")])]),n._v(" "),e("li",[e("a",{attrs:{href:"#-%E4%B8%8D%E6%8A%9B%E5%87%BA-interruptedexception-%E7%9A%84-await"}},[n._v("* 不抛出 InterruptedException 的 await")])])])]),n._v(" "),e("li",[e("a",{attrs:{href:"#abstractqueuedsynchronizer-%E7%8B%AC%E5%8D%A0%E9%94%81%E7%9A%84%E5%8F%96%E6%B6%88%E6%8E%92%E9%98%9F"}},[n._v("AbstractQueuedSynchronizer 独占锁的取消排队")])]),n._v(" "),e("li",[e("a",{attrs:{href:"#%E5%86%8D%E8%AF%B4-java-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E5%92%8C-interruptedexception-%E5%BC%82%E5%B8%B8"}},[n._v("再说 java 线程中断和 InterruptedException 异常")]),n._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD"}},[n._v("线程中断")])]),n._v(" "),e("li",[e("a",{attrs:{href:"#interruptedexception-%E6%A6%82%E8%BF%B0"}},[n._v("InterruptedException 概述")])]),n._v(" "),e("li",[e("a",{attrs:{href:"#%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%AD"}},[n._v("处理中断")])])])]),n._v(" "),e("li",[e("a",{attrs:{href:"#%E6%80%BB%E7%BB%93"}},[n._v("总结")])])]),n._v(" "),e("p",[n._v("本文转自：http://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer")]),n._v(" "),e("p",[n._v("本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看")]),n._v(" "),e("blockquote",[e("p",[n._v("https://github.com/h2pl/Java-Tutorial")])]),n._v(" "),e("p",[n._v("喜欢的话麻烦点下Star哈")]),n._v(" "),e("p",[n._v("文章同步发于我的个人博客：")]),n._v(" "),e("blockquote",[e("p",[n._v("www.how2playlife.com")])]),n._v(" "),e("p",[n._v("本文是微信公众号【Java技术江湖】的《Java并发指南》其中一篇，本文大部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。")]),n._v(" "),e("p",[n._v("该系列博文会告诉你如何全面深入地学习Java并发技术，从Java多线程基础，再到并发编程的基础知识，从Java并发包的入门和实战，再到JUC的源码剖析，一步步地学习Java并发编程，并上手进行实战，以便让你更完整地了解整个Java并发编程知识体系，形成自己的知识框架。")]),n._v(" "),e("p",[n._v("为了更好地总结和检验你的学习成果，本系列文章也会提供一些对应的面试题以及参考答案。")]),n._v(" "),e("p",[n._v("如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。\n")]),n._v(" "),e("p",[n._v("文章比较长，信息量比较大，建议在 pc 上阅读。文章标题是为了呼应前文，其实可以单独成文的，主要是希望读者看文章能系统看。")]),n._v(" "),e("p",[n._v("本文关注以下几点内容：")]),n._v(" "),e("ol",[e("li",[n._v("深入理解 ReentrantLock 公平锁和非公平锁的区别")]),n._v(" "),e("li",[n._v("深入分析 AbstractQueuedSynchronizer 中的 ConditionObject")]),n._v(" "),e("li",[n._v("深入理解 Java 线程中断和 InterruptedException 异常")])]),n._v(" "),e("p",[n._v("基本上本文把以上几点都说清楚了，我假设读者看过"),e("a",{attrs:{href:"http://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer/",target:"_blank",rel:"noopener noreferrer"}},[n._v("上一篇文章中对 AbstractQueuedSynchronizer 的介绍 "),e("OutboundLink")],1),n._v("，当然如果你已经熟悉 AQS 中的独占锁了，那也可以直接看这篇。各小节之间基本上没什么关系，大家可以只关注自己感兴趣的部分。")]),n._v(" "),e("p",[n._v("其实这篇文章的信息量很大，初学者估计"),e("strong",[n._v("至少要 1 小时")]),n._v("才能看完，希望本文对得起大家的时间。")]),n._v(" "),e("h2",{attrs:{id:"公平锁和非公平锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#公平锁和非公平锁"}},[n._v("#")]),n._v(" 公平锁和非公平锁")]),n._v(" "),e("p",[n._v("ReentrantLock 默认采用非公平锁，除非你在构造方法中传入参数 true 。")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("public ReentrantLock() {\n    // 默认非公平锁\n    sync = new NonfairSync();\n}\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br")])]),e("p",[n._v("公平锁的 lock 方法：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('static final class FairSync extends Sync {\n    final void lock() {\n        acquire(1);\n    }\n    // AbstractQueuedSynchronizer.acquire(int arg)\n    public final void acquire(int arg) {\n        if (!tryAcquire(arg) &&\n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n    }\n    protected final boolean tryAcquire(int acquires) {\n        final Thread current = Thread.currentThread();\n        int c = getState();\n        if (c == 0) {\n            // 1\\. 和非公平锁相比，这里多了一个判断：是否有线程在等待\n            if (!hasQueuedPredecessors() &&\n                compareAndSetState(0, acquires)) {\n                setExclusiveOwnerThread(current);\n                return true;\n            }\n        }\n        else if (current == getExclusiveOwnerThread()) {\n            int nextc = c + acquires;\n            if (nextc < 0)\n                throw new Error("Maximum lock count exceeded");\n            setState(nextc);\n            return true;\n        }\n        return false;\n    }\n}\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br")])]),e("p",[n._v("非公平锁的 lock 方法：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('static final class NonfairSync extends Sync {\n    final void lock() {\n        // 2\\. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了\n        if (compareAndSetState(0, 1))\n            setExclusiveOwnerThread(Thread.currentThread());\n        else\n            acquire(1);\n    }\n    // AbstractQueuedSynchronizer.acquire(int arg)\n    public final void acquire(int arg) {\n        if (!tryAcquire(arg) &&\n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n    }\n    protected final boolean tryAcquire(int acquires) {\n        return nonfairTryAcquire(acquires);\n    }\n}\n/**\n * Performs non-fair tryLock.  tryAcquire is implemented in\n * subclasses, but both need nonfair try for trylock method.\n */\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        // 这里没有对阻塞队列进行判断\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new Error("Maximum lock count exceeded");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br"),e("span",{staticClass:"line-number"},[n._v("32")]),e("br"),e("span",{staticClass:"line-number"},[n._v("33")]),e("br"),e("span",{staticClass:"line-number"},[n._v("34")]),e("br"),e("span",{staticClass:"line-number"},[n._v("35")]),e("br"),e("span",{staticClass:"line-number"},[n._v("36")]),e("br"),e("span",{staticClass:"line-number"},[n._v("37")]),e("br"),e("span",{staticClass:"line-number"},[n._v("38")]),e("br"),e("span",{staticClass:"line-number"},[n._v("39")]),e("br"),e("span",{staticClass:"line-number"},[n._v("40")]),e("br"),e("span",{staticClass:"line-number"},[n._v("41")]),e("br")])]),e("p",[n._v("总结：公平锁和非公平锁只有两处不同：")]),n._v(" "),e("ol",[e("li",[n._v("非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。")]),n._v(" "),e("li",[n._v("非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。")])]),n._v(" "),e("p",[n._v("公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。")]),n._v(" "),e("p",[n._v("相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。")]),n._v(" "),e("h2",{attrs:{id:"condition"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#condition"}},[n._v("#")]),n._v(" Condition")]),n._v(" "),e("p",[n._v("Tips: 这里重申一下，要看懂这个，必须要先看懂上一篇关于 "),e("a",{attrs:{href:"http://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer/",target:"_blank",rel:"noopener noreferrer"}},[n._v("AbstractQueuedSynchronizer"),e("OutboundLink")],1),n._v(" 的介绍，或者你已经有相关的知识了，否则这节肯定是看不懂的。")]),n._v(" "),e("p",[n._v("我们先来看看 Condition 的使用场景，Condition 经常可以用在"),e("strong",[n._v("生产者-消费者")]),n._v("的场景中，请看 Doug Lea 给出的这个例子：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("import java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nclass BoundedBuffer {\n    final Lock lock = new ReentrantLock();\n    // condition 依赖于 lock 来产生\n    final Condition notFull = lock.newCondition();\n    final Condition notEmpty = lock.newCondition();\n\n    final Object[] items = new Object[100];\n    int putptr, takeptr, count;\n\n    // 生产\n    public void put(Object x) throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == items.length)\n                notFull.await();  // 队列已满，等待，直到 not full 才能继续生产\n            items[putptr] = x;\n            if (++putptr == items.length) putptr = 0;\n            ++count;\n            notEmpty.signal(); // 生产成功，队列已经 not empty 了，发个通知出去\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    // 消费\n    public Object take() throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == 0)\n                notEmpty.await(); // 队列为空，等待，直到队列 not empty，才能继续消费\n            Object x = items[takeptr];\n            if (++takeptr == items.length) takeptr = 0;\n            --count;\n            notFull.signal(); // 被我消费掉一个，队列 not full 了，发个通知出去\n            return x;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br"),e("span",{staticClass:"line-number"},[n._v("32")]),e("br"),e("span",{staticClass:"line-number"},[n._v("33")]),e("br"),e("span",{staticClass:"line-number"},[n._v("34")]),e("br"),e("span",{staticClass:"line-number"},[n._v("35")]),e("br"),e("span",{staticClass:"line-number"},[n._v("36")]),e("br"),e("span",{staticClass:"line-number"},[n._v("37")]),e("br"),e("span",{staticClass:"line-number"},[n._v("38")]),e("br"),e("span",{staticClass:"line-number"},[n._v("39")]),e("br"),e("span",{staticClass:"line-number"},[n._v("40")]),e("br"),e("span",{staticClass:"line-number"},[n._v("41")]),e("br"),e("span",{staticClass:"line-number"},[n._v("42")]),e("br"),e("span",{staticClass:"line-number"},[n._v("43")]),e("br"),e("span",{staticClass:"line-number"},[n._v("44")]),e("br")])]),e("blockquote",[e("p",[n._v("1、我们可以看到，在使用 condition 时，必须先持有相应的锁。这个和 Object 类中的方法有相似的语义，需要先持有某个对象的监视器锁才可以执行 wait(), notify() 或 notifyAll() 方法。")]),n._v(" "),e("p",[n._v("2、ArrayBlockingQueue 采用这种方式实现了生产者-消费者，所以请只把这个例子当做学习例子，实际生产中可以直接使用 ArrayBlockingQueue")])]),n._v(" "),e("p",[n._v("我们常用 obj.wait()，obj.notify() 或 obj.notifyAll() 来实现相似的功能，但是，它们是基于对象的监视器锁的。需要深入了解这几个方法的读者，可以参考我的另一篇文章《"),e("a",{attrs:{href:"http://hongjiev.github.io/2017/07/05/Threads-And-Locks-md/",target:"_blank",rel:"noopener noreferrer"}},[n._v("深入分析 java 8 编程语言规范：Threads and Locks"),e("OutboundLink")],1),n._v("》。而这里说的 Condition 是基于 ReentrantLock 实现的，而 ReentrantLock 是依赖于 AbstractQueuedSynchronizer 实现的。")]),n._v(" "),e("p",[n._v("在往下看之前，读者心里要有一个整体的概念。condition 是依赖于 ReentrantLock 的，不管是调用 await 进入等待还是 signal 唤醒，"),e("strong",[n._v("都必须获取到锁才能进行操作")]),n._v("。")]),n._v(" "),e("p",[n._v("每个 ReentrantLock 实例可以通过调用多次 newCondition 产生多个 ConditionObject 的实例：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("final ConditionObject newCondition() {\n    // 实例化一个 ConditionObject\n    return new ConditionObject();\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br")])]),e("p",[n._v("我们首先来看下我们关注的 Condition 的实现类 "),e("code",[n._v("AbstractQueuedSynchronizer")]),n._v(" 类中的 "),e("code",[n._v("ConditionObject")]),n._v("。")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("public class ConditionObject implements Condition, java.io.Serializable {\n        private static final long serialVersionUID = 1173984872572414699L;\n        // 条件队列的第一个节点\n          // 不要管这里的关键字 transient，是不参与序列化的意思\n        private transient Node firstWaiter;\n        // 条件队列的最后一个节点\n        private transient Node lastWaiter;\n        ......\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br")])]),e("p",[n._v("在上一篇介绍 AQS 的时候，我们有一个"),e("strong",[n._v("阻塞队列")]),n._v("，用于保存等待获取锁的线程的队列。这里我们引入另一个概念，叫"),e("strong",[n._v("条件队列")]),n._v("（condition queue），我画了一张简单的图用来说明这个。")]),n._v(" "),e("blockquote",[e("p",[n._v("这里的阻塞队列如果叫做同步队列（sync queue）其实比较贴切，不过为了和前篇呼应，我就继续使用阻塞队列了。记住这里的两个概念，"),e("strong",[n._v("阻塞队列")]),n._v("和"),e("strong",[n._v("条件队列")]),n._v("。")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer-2/aqs2-2.png",alt:"condition-2"}})]),n._v(" "),e("blockquote",[e("p",[n._v("这里，我们简单回顾下 Node 的属性：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("volatile int waitStatus; // 可取值 0、CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)、PROPAGATE(-3)\nvolatile Node prev;\nvolatile Node next;\nvolatile Thread thread;\nNode nextWaiter;\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br")])]),e("p",[n._v("prev 和 next 用于实现阻塞队列的双向链表，这里的 nextWaiter 用于实现条件队列的单向链表")])]),n._v(" "),e("p",[n._v("基本上，把这张图看懂，你也就知道 condition 的处理流程了。所以，我先简单解释下这图，然后再具体地解释代码实现。")]),n._v(" "),e("ol",[e("li",[n._v("条件队列和阻塞队列的节点，都是 Node 的实例，因为条件队列的节点是需要转移到阻塞队列中去的；")]),n._v(" "),e("li",[n._v("我们知道一个 ReentrantLock 实例可以通过多次调用 newCondition() 来产生多个 Condition 实例，这里对应 condition1 和 condition2。注意，ConditionObject 只有两个属性 firstWaiter 和 lastWaiter；")]),n._v(" "),e("li",[n._v("每个 condition 有一个关联的"),e("strong",[n._v("条件队列")]),n._v("，如线程 1 调用 "),e("code",[n._v("condition1.await()")]),n._v(" 方法即可将当前线程 1 包装成 Node 后加入到条件队列中，然后阻塞在这里，不继续往下执行，条件队列是一个单向链表；")]),n._v(" "),e("li",[n._v("调用"),e("code",[n._v("condition1.signal()")]),n._v(" 触发一次唤醒，此时唤醒的是队头，会将condition1 对应的"),e("strong",[n._v("条件队列")]),n._v("的 firstWaiter（队头） 移到"),e("strong",[n._v("阻塞队列的队尾")]),n._v("，等待获取锁，获取锁后 await 方法才能返回，继续往下执行。")])]),n._v(" "),e("p",[n._v("上面的 2->3->4 描述了一个最简单的流程，没有考虑中断、signalAll、还有带有超时参数的 await 方法等，不过把这里弄懂是这节的主要目的。")]),n._v(" "),e("p",[n._v("同时，从图中也可以很直观地看出，哪些操作是线程安全的，哪些操作是线程不安全的。")]),n._v(" "),e("p",[n._v("这个图看懂后，下面的代码分析就简单了。")]),n._v(" "),e("p",[n._v("接下来，我们一步步按照流程来走代码分析，我们先来看看 wait 方法：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 首先，这个方法是可被中断的，不可被中断的是另一个方法 awaitUninterruptibly()\n// 这个方法会阻塞，直到调用 signal 方法（指 signal() 和 signalAll()，下同），或被中断\npublic final void await() throws InterruptedException {\n    // 老规矩，既然该方法要响应中断，那么在最开始就判断中断状态\n    if (Thread.interrupted())\n        throw new InterruptedException();\n\n    // 添加到 condition 的条件队列中\n    Node node = addConditionWaiter();\n\n    // 释放锁，返回值是释放锁之前的 state 值\n    // await() 之前，当前线程是必须持有锁的，这里肯定要释放掉\n    int savedState = fullyRelease(node);\n\n    int interruptMode = 0;\n    // 这里退出循环有两种情况，之后再仔细分析\n    // 1\\. isOnSyncQueue(node) 返回 true，即当前 node 已经转移到阻塞队列了\n    // 2\\. checkInterruptWhileWaiting(node) != 0 会到 break，然后退出循环，代表的是线程中断\n    while (!isOnSyncQueue(node)) {\n        LockSupport.park(this);\n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n            break;\n    }\n    // 被唤醒后，将进入阻塞队列，等待获取锁\n    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n        interruptMode = REINTERRUPT;\n    if (node.nextWaiter != null) // clean up if cancelled\n        unlinkCancelledWaiters();\n    if (interruptMode != 0)\n        reportInterruptAfterWait(interruptMode);\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br")])]),e("p",[n._v("其实，我大体上也把整个 await 过程说得十之八九了，下面我们分步把上面的几个点用源码说清楚。")]),n._v(" "),e("h3",{attrs:{id:"_1-将节点加入到条件队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-将节点加入到条件队列"}},[n._v("#")]),n._v(" 1. 将节点加入到条件队列")]),n._v(" "),e("p",[n._v("addConditionWaiter() 是将当前节点加入到条件队列，看图我们知道，这种条件队列内的操作是线程安全的。")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 将当前线程对应的节点入队，插入队尾\nprivate Node addConditionWaiter() {\n    Node t = lastWaiter;\n    // 如果条件队列的最后一个节点取消了，将其清除出去\n    // 为什么这里把 waitStatus 不等于 Node.CONDITION，就判定为该节点发生了取消排队？\n    if (t != null && t.waitStatus != Node.CONDITION) {\n        // 这个方法会遍历整个条件队列，然后会将已取消的所有节点清除出队列\n        unlinkCancelledWaiters();\n        t = lastWaiter;\n    }\n    // node 在初始化的时候，指定 waitStatus 为 Node.CONDITION\n    Node node = new Node(Thread.currentThread(), Node.CONDITION);\n\n    // t 此时是 lastWaiter，队尾\n    // 如果队列为空\n    if (t == null)\n        firstWaiter = node;\n    else\n        t.nextWaiter = node;\n    lastWaiter = node;\n    return node;\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br")])]),e("p",[n._v("上面的这块代码很简单，就是将当前线程进入到条件队列的队尾。")]),n._v(" "),e("p",[n._v("在addWaiter 方法中，有一个 unlinkCancelledWaiters() 方法，该方法用于清除队列中已经取消等待的节点。")]),n._v(" "),e("p",[n._v("当 await 的时候如果发生了取消操作（这点之后会说），或者是在节点入队的时候，发现最后一个节点是被取消的，会调用一次这个方法。")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 等待队列是一个单向链表，遍历链表将已经取消等待的节点清除出去\n// 纯属链表操作，很好理解，看不懂多看几遍就可以了\nprivate void unlinkCancelledWaiters() {\n    Node t = firstWaiter;\n    Node trail = null;\n    while (t != null) {\n        Node next = t.nextWaiter;\n        // 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的\n        if (t.waitStatus != Node.CONDITION) {\n            t.nextWaiter = null;\n            if (trail == null)\n                firstWaiter = next;\n            else\n                trail.nextWaiter = next;\n            if (next == null)\n                lastWaiter = trail;\n        }\n        else\n            trail = t;\n        t = next;\n    }\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br")])]),e("h3",{attrs:{id:"_2-完全释放独占锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-完全释放独占锁"}},[n._v("#")]),n._v(" 2. 完全释放独占锁")]),n._v(" "),e("p",[n._v("回到 wait 方法，节点入队了以后，会调用 "),e("code",[n._v("int savedState = fullyRelease(node);")]),n._v(" 方法释放锁，注意，这里是完全释放独占锁（fully release），因为 ReentrantLock 是可以重入的。")]),n._v(" "),e("blockquote",[e("p",[n._v("考虑一下这里的 savedState。如果在 condition1.await() 之前，假设线程先执行了 2 次 lock() 操作，那么 state 为 2，我们理解为该线程持有 2 把锁，这里 await() 方法必须将 state 设置为 0，然后再进入挂起状态，这样其他线程才能持有锁。当它被唤醒的时候，它需要重新持有 2 把锁，才能继续下去。")])]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('// 首先，我们要先观察到返回值 savedState 代表 release 之前的 state 值\n// 对于最简单的操作：先 lock.lock()，然后 condition1.await()。\n//         那么 state 经过这个方法由 1 变为 0，锁释放，此方法返回 1\n//         相应的，如果 lock 重入了 n 次，savedState == n\n// 如果这个方法失败，会将节点设置为"取消"状态，并抛出异常 IllegalMonitorStateException\nfinal int fullyRelease(Node node) {\n    boolean failed = true;\n    try {\n        int savedState = getState();\n        // 这里使用了当前的 state 作为 release 的参数，也就是完全释放掉锁，将 state 置为 0\n        if (release(savedState)) {\n            failed = false;\n            return savedState;\n        } else {\n            throw new IllegalMonitorStateException();\n        }\n    } finally {\n        if (failed)\n            node.waitStatus = Node.CANCELLED;\n    }\n}\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br")])]),e("blockquote",[e("p",[n._v("考虑一下，如果一个线程在不持有 lock 的基础上，就去调用 condition1.await() 方法，它能进入条件队列，但是在上面的这个方法中，由于它不持有锁，release(savedState) 这个方法肯定要返回 false，进入到异常分支，然后进入 finally 块设置 "),e("code",[n._v("node.waitStatus = Node.CANCELLED")]),n._v("，这个已经入队的节点之后会被后继的节点”请出去“。")])]),n._v(" "),e("h3",{attrs:{id:"_3-等待进入阻塞队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-等待进入阻塞队列"}},[n._v("#")]),n._v(" 3. 等待进入阻塞队列")]),n._v(" "),e("p",[n._v("释放掉锁以后，接下来是这段，这边会自旋，如果发现自己还没到阻塞队列，那么挂起，等待被转移到阻塞队列。")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("int interruptMode = 0;\n// 如果不在阻塞队列中，注意了，是阻塞队列\nwhile (!isOnSyncQueue(node)) {\n    // 线程挂起\n    LockSupport.park(this);\n\n    // 这里可以先不用看了，等看到它什么时候被 unpark 再说\n    if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n        break;\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br")])]),e("p",[n._v("isOnSyncQueue(Node node) 用于判断节点是否已经转移到阻塞队列了：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 在节点入条件队列的时候，初始化时设置了 waitStatus = Node.CONDITION\n// 前面我提到，signal 的时候需要将节点从条件队列移到阻塞队列，\n// 这个方法就是判断 node 是否已经移动到阻塞队列了\nfinal boolean isOnSyncQueue(Node node) {\n\n    // 移动过去的时候，node 的 waitStatus 会置为 0，这个之后在说 signal 方法的时候会说到\n    // 如果 waitStatus 还是 Node.CONDITION，也就是 -2，那肯定就是还在条件队列中\n    // 如果 node 的前驱 prev 指向还是 null，说明肯定没有在 阻塞队列(prev是阻塞队列链表中使用的)\n    if (node.waitStatus == Node.CONDITION || node.prev == null)\n        return false;\n    // 如果 node 已经有后继节点 next 的时候，那肯定是在阻塞队列了\n    if (node.next != null) \n        return true;\n\n    // 下面这个方法从阻塞队列的队尾开始从后往前遍历找，如果找到相等的，说明在阻塞队列，否则就是不在阻塞队列\n\n    // 可以通过判断 node.prev() != null 来推断出 node 在阻塞队列吗？答案是：不能。\n    // 这个可以看上篇 AQS 的入队方法，首先设置的是 node.prev 指向 tail，\n    // 然后是 CAS 操作将自己设置为新的 tail，可是这次的 CAS 是可能失败的。\n\n    return findNodeFromTail(node);\n}\n\n// 从阻塞队列的队尾往前遍历，如果找到，返回 true\nprivate boolean findNodeFromTail(Node node) {\n    Node t = tail;\n    for (;;) {\n        if (t == node)\n            return true;\n        if (t == null)\n            return false;\n        t = t.prev;\n    }\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br"),e("span",{staticClass:"line-number"},[n._v("32")]),e("br"),e("span",{staticClass:"line-number"},[n._v("33")]),e("br"),e("span",{staticClass:"line-number"},[n._v("34")]),e("br")])]),e("p",[n._v("回到前面的循环，isOnSyncQueue(node) 返回 false 的话，那么进到 "),e("code",[n._v("LockSupport.park(this);")]),n._v(" 这里线程挂起。")]),n._v(" "),e("h3",{attrs:{id:"_4-signal-唤醒线程-转移到阻塞队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-signal-唤醒线程-转移到阻塞队列"}},[n._v("#")]),n._v(" 4. signal 唤醒线程，转移到阻塞队列")]),n._v(" "),e("p",[n._v("为了大家理解，这里我们先看唤醒操作，因为刚刚到 "),e("code",[n._v("LockSupport.park(this);")]),n._v(" 把线程挂起了，等待唤醒。")]),n._v(" "),e("p",[n._v("唤醒操作通常由另一个线程来操作，就像生产者-消费者模式中，如果线程因为等待消费而挂起，那么当生产者生产了一个东西后，会调用 signal 唤醒正在等待的线程来消费。")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 唤醒等待了最久的线程\n// 其实就是，将这个线程对应的 node 从条件队列转移到阻塞队列\npublic final void signal() {\n    // 调用 signal 方法的线程必须持有当前的独占锁\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    Node first = firstWaiter;\n    if (first != null)\n        doSignal(first);\n}\n\n// 从条件队列队头往后遍历，找出第一个需要转移的 node\n// 因为前面我们说过，有些线程会取消排队，但是可能还在队列中\nprivate void doSignal(Node first) {\n    do {\n          // 将 firstWaiter 指向 first 节点后面的第一个，因为 first 节点马上要离开了\n        // 如果将 first 移除后，后面没有节点在等待了，那么需要将 lastWaiter 置为 null\n        if ( (firstWaiter = first.nextWaiter) == null)\n            lastWaiter = null;\n        // 因为 first 马上要被移到阻塞队列了，和条件队列的链接关系在这里断掉\n        first.nextWaiter = null;\n    } while (!transferForSignal(first) &&\n             (first = firstWaiter) != null);\n      // 这里 while 循环，如果 first 转移不成功，那么选择 first 后面的第一个节点进行转移，依此类推\n}\n\n// 将节点从条件队列转移到阻塞队列\n// true 代表成功转移\n// false 代表在 signal 之前，节点已经取消了\nfinal boolean transferForSignal(Node node) {\n\n    // CAS 如果失败，说明此 node 的 waitStatus 已不是 Node.CONDITION，说明节点已经取消，\n    // 既然已经取消，也就不需要转移了，方法返回，转移后面一个节点\n    // 否则，将 waitStatus 置为 0\n    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))\n        return false;\n\n    // enq(node): 自旋进入阻塞队列的队尾\n    // 注意，这里的返回值 p 是 node 在阻塞队列的前驱节点\n    Node p = enq(node);\n    int ws = p.waitStatus;\n    // ws > 0 说明 node 在阻塞队列中的前驱节点取消了等待锁，直接唤醒 node 对应的线程。唤醒之后会怎么样，后面再解释\n    // 如果 ws <= 0, 那么 compareAndSetWaitStatus 将会被调用，上篇介绍的时候说过，节点入队后，需要把前驱节点的状态设为 Node.SIGNAL(-1)\n    if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))\n        // 如果前驱节点取消或者 CAS 失败，会进到这里唤醒线程，之后的操作看下一节\n        LockSupport.unpark(node.thread);\n    return true;\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br"),e("span",{staticClass:"line-number"},[n._v("32")]),e("br"),e("span",{staticClass:"line-number"},[n._v("33")]),e("br"),e("span",{staticClass:"line-number"},[n._v("34")]),e("br"),e("span",{staticClass:"line-number"},[n._v("35")]),e("br"),e("span",{staticClass:"line-number"},[n._v("36")]),e("br"),e("span",{staticClass:"line-number"},[n._v("37")]),e("br"),e("span",{staticClass:"line-number"},[n._v("38")]),e("br"),e("span",{staticClass:"line-number"},[n._v("39")]),e("br"),e("span",{staticClass:"line-number"},[n._v("40")]),e("br"),e("span",{staticClass:"line-number"},[n._v("41")]),e("br"),e("span",{staticClass:"line-number"},[n._v("42")]),e("br"),e("span",{staticClass:"line-number"},[n._v("43")]),e("br"),e("span",{staticClass:"line-number"},[n._v("44")]),e("br"),e("span",{staticClass:"line-number"},[n._v("45")]),e("br"),e("span",{staticClass:"line-number"},[n._v("46")]),e("br"),e("span",{staticClass:"line-number"},[n._v("47")]),e("br"),e("span",{staticClass:"line-number"},[n._v("48")]),e("br")])]),e("p",[n._v("正常情况下，"),e("code",[n._v("ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)")]),n._v(" 这句中，ws <= 0，而且 "),e("code",[n._v("compareAndSetWaitStatus(p, ws, Node.SIGNAL)")]),n._v(" 会返回 true，所以一般也不会进去 if 语句块中唤醒 node 对应的线程。然后这个方法返回 true，也就意味着 signal 方法结束了，节点进入了阻塞队列。")]),n._v(" "),e("p",[n._v("假设发生了阻塞队列中的前驱节点取消等待，或者 CAS 失败，只要唤醒线程，让其进到下一步即可。")]),n._v(" "),e("h3",{attrs:{id:"_5-唤醒后检查中断状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-唤醒后检查中断状态"}},[n._v("#")]),n._v(" 5. 唤醒后检查中断状态")]),n._v(" "),e("p",[n._v("上一步 signal 之后，我们的线程由条件队列转移到了阻塞队列，之后就准备获取锁了。只要重新获取到锁了以后，继续往下执行。")]),n._v(" "),e("p",[n._v("等线程从挂起中恢复过来，继续往下看")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("int interruptMode = 0;\nwhile (!isOnSyncQueue(node)) {\n    // 线程挂起\n    LockSupport.park(this);\n\n    if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n        break;\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br")])]),e("p",[n._v("先解释下 interruptMode。interruptMode 可以取值为 REINTERRUPT（1），THROW_IE（-1），0")]),n._v(" "),e("ul",[e("li",[n._v("REINTERRUPT： 代表 await 返回的时候，需要重新设置中断状态")]),n._v(" "),e("li",[n._v("THROW_IE： 代表 await 返回的时候，需要抛出 InterruptedException 异常")]),n._v(" "),e("li",[n._v("0 ：说明在 await 期间，没有发生中断")])]),n._v(" "),e("p",[n._v("有以下三种情况会让 LockSupport.park(this); 这句返回继续往下执行：")]),n._v(" "),e("ol",[e("li",[n._v("常规路径。signal -> 转移节点到阻塞队列 -> 获取了锁（unpark）")]),n._v(" "),e("li",[n._v("线程中断。在 park 的时候，另外一个线程对这个线程进行了中断")]),n._v(" "),e("li",[n._v("signal 的时候我们说过，转移以后的前驱节点取消了，或者对前驱节点的CAS操作失败了")]),n._v(" "),e("li",[n._v("假唤醒。这个也是存在的，和 Object.wait() 类似，都有这个问题")])]),n._v(" "),e("p",[n._v("线程唤醒后第一步是调用 checkInterruptWhileWaiting(node) 这个方法，此方法用于判断是否在线程挂起期间发生了中断，如果发生了中断，是 signal 调用之前中断的，还是 signal 之后发生的中断。")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 1\\. 如果在 signal 之前已经中断，返回 THROW_IE\n// 2\\. 如果是 signal 之后中断，返回 REINTERRUPT\n// 3\\. 没有发生中断，返回 0\nprivate int checkInterruptWhileWaiting(Node node) {\n    return Thread.interrupted() ?\n        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :\n        0;\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br")])]),e("blockquote",[e("p",[n._v("Thread.interrupted()：如果当前线程已经处于中断状态，那么该方法返回 true，同时将中断状态重置为 false，所以，才有后续的 "),e("code",[n._v("重新中断（REINTERRUPT）")]),n._v(" 的使用。")])]),n._v(" "),e("p",[n._v("看看怎么判断是 signal 之前还是之后发生的中断：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 只有线程处于中断状态，才会调用此方法\n// 如果需要的话，将这个已经取消等待的节点转移到阻塞队列\n// 返回 true：如果此线程在 signal 之前被取消，\nfinal boolean transferAfterCancelledWait(Node node) {\n    // 用 CAS 将节点状态设置为 0 \n    // 如果这步 CAS 成功，说明是 signal 方法之前发生的中断，因为如果 signal 先发生的话，signal 中会将 waitStatus 设置为 0\n    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {\n        // 将节点放入阻塞队列\n        // 这里我们看到，即使中断了，依然会转移到阻塞队列\n        enq(node);\n        return true;\n    }\n\n    // 到这里是因为 CAS 失败，肯定是因为 signal 方法已经将 waitStatus 设置为了 0\n    // signal 方法会将节点转移到阻塞队列，但是可能还没完成，这边自旋等待其完成\n    // 当然，这种事情还是比较少的吧：signal 调用之后，没完成转移之前，发生了中断\n    while (!isOnSyncQueue(node))\n        Thread.yield();\n    return false;\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br")])]),e("blockquote",[e("p",[n._v("这里再说一遍，即使发生了中断，节点依然会转移到阻塞队列。")])]),n._v(" "),e("p",[n._v("到这里，大家应该都知道这个 while 循环怎么退出了吧。要么中断，要么转移成功。")]),n._v(" "),e("p",[n._v("这里描绘了一个场景，本来有个线程，它是排在条件队列的后面的，但是因为它被中断了，那么它会被唤醒，然后它发现自己不是被 signal 的那个，但是它会自己主动去进入到阻塞队列。")]),n._v(" "),e("h3",{attrs:{id:"_6-获取独占锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-获取独占锁"}},[n._v("#")]),n._v(" 6. 获取独占锁")]),n._v(" "),e("p",[n._v("while 循环出来以后，下面是这段代码：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n    interruptMode = REINTERRUPT;\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br")])]),e("p",[n._v("由于 while 出来后，我们确定节点已经进入了阻塞队列，准备获取锁。")]),n._v(" "),e("p",[n._v("这里的 acquireQueued(node, savedState) 的第一个参数 node 之前已经经过 enq(node) 进入了队列，参数 savedState 是之前释放锁前的 state，这个方法返回的时候，代表当前线程获取了锁，而且 state == savedState了。")]),n._v(" "),e("p",[n._v("注意，前面我们说过，不管有没有发生中断，都会进入到阻塞队列，而 acquireQueued(node, savedState) 的返回值就是代表线程是否被中断。如果返回 true，说明被中断了，而且 interruptMode != THROW_IE，说明在 signal 之前就发生中断了，这里将 interruptMode 设置为 REINTERRUPT，用于待会重新中断。")]),n._v(" "),e("p",[n._v("继续往下：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("if (node.nextWaiter != null) // clean up if cancelled\n    unlinkCancelledWaiters();\nif (interruptMode != 0)\n    reportInterruptAfterWait(interruptMode);\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br")])]),e("p",[n._v("本着一丝不苟的精神，这边说说 "),e("code",[n._v("node.nextWaiter != null")]),n._v(" 怎么满足。我前面也说了 signal 的时候会将节点转移到阻塞队列，有一步是 node.nextWaiter = null，将断开节点和条件队列的联系。")]),n._v(" "),e("p",[n._v("可是，"),e("code",[n._v("在判断发生中断的情况下，是 signal 之前还是之后发生的？")]),n._v(" 这部分的时候，我也介绍了，如果 signal 之前就中断了，也需要将节点进行转移到阻塞队列，这部分转移的时候，是没有设置 node.nextWaiter = null 的。")]),n._v(" "),e("p",[n._v("之前我们说过，如果有节点取消，也会调用 unlinkCancelledWaiters 这个方法，就是这里了。")]),n._v(" "),e("h3",{attrs:{id:"_7-处理中断状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-处理中断状态"}},[n._v("#")]),n._v(" 7. 处理中断状态")]),n._v(" "),e("p",[n._v("到这里，我们终于可以好好说下这个 interruptMode 干嘛用了。")]),n._v(" "),e("ul",[e("li",[n._v("0：什么都不做，没有被中断过；")]),n._v(" "),e("li",[n._v("THROW_IE：await 方法抛出 InterruptedException 异常，因为它代表在 await() 期间发生了中断；")]),n._v(" "),e("li",[n._v("REINTERRUPT：重新中断当前线程，因为它代表 await() 期间没有被中断，而是 signal() 以后发生的中断")])]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("private void reportInterruptAfterWait(int interruptMode)\n    throws InterruptedException {\n    if (interruptMode == THROW_IE)\n        throw new InterruptedException();\n    else if (interruptMode == REINTERRUPT)\n        selfInterrupt();\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br")])]),e("blockquote",[e("p",[n._v("这个中断状态这部分内容，大家应该都理解了吧，不理解的话，多看几遍就是了。")])]),n._v(" "),e("h3",{attrs:{id:"带超时机制的-await"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#带超时机制的-await"}},[n._v("#")]),n._v(" * 带超时机制的 await")]),n._v(" "),e("p",[n._v("经过前面的 7 步，整个 ConditionObject 类基本上都分析完了，接下来简单分析下带超时机制的 await 方法。")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("public final long awaitNanos(long nanosTimeout) \n                  throws InterruptedException\npublic final boolean awaitUntil(Date deadline)\n                throws InterruptedException\npublic final boolean await(long time, TimeUnit unit)\n                throws InterruptedException\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br")])]),e("p",[n._v("这三个方法都差不多，我们就挑一个出来看看吧：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("public final boolean await(long time, TimeUnit unit)\n        throws InterruptedException {\n    // 等待这么多纳秒\n    long nanosTimeout = unit.toNanos(time);\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    Node node = addConditionWaiter();\n    int savedState = fullyRelease(node);\n    // 当前时间 + 等待时长 = 过期时间\n    final long deadline = System.nanoTime() + nanosTimeout;\n    // 用于返回 await 是否超时\n    boolean timedout = false;\n    int interruptMode = 0;\n    while (!isOnSyncQueue(node)) {\n        // 时间到啦\n        if (nanosTimeout <= 0L) {\n            // 这里因为要 break 取消等待了。取消等待的话一定要调用 transferAfterCancelledWait(node) 这个方法\n            // 如果这个方法返回 true，在这个方法内，将节点转移到阻塞队列成功\n            // 返回 false 的话，说明 signal 已经发生，signal 方法将节点转移了。也就是说没有超时嘛\n            timedout = transferAfterCancelledWait(node);\n            break;\n        }\n        // spinForTimeoutThreshold 的值是 1000 纳秒，也就是 1 毫秒\n        // 也就是说，如果不到 1 毫秒了，那就不要选择 parkNanos 了，自旋的性能反而更好\n        if (nanosTimeout >= spinForTimeoutThreshold)\n            LockSupport.parkNanos(this, nanosTimeout);\n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n            break;\n        // 得到剩余时间\n        nanosTimeout = deadline - System.nanoTime();\n    }\n    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n        interruptMode = REINTERRUPT;\n    if (node.nextWaiter != null)\n        unlinkCancelledWaiters();\n    if (interruptMode != 0)\n        reportInterruptAfterWait(interruptMode);\n    return !timedout;\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br"),e("span",{staticClass:"line-number"},[n._v("32")]),e("br"),e("span",{staticClass:"line-number"},[n._v("33")]),e("br"),e("span",{staticClass:"line-number"},[n._v("34")]),e("br"),e("span",{staticClass:"line-number"},[n._v("35")]),e("br"),e("span",{staticClass:"line-number"},[n._v("36")]),e("br"),e("span",{staticClass:"line-number"},[n._v("37")]),e("br"),e("span",{staticClass:"line-number"},[n._v("38")]),e("br"),e("span",{staticClass:"line-number"},[n._v("39")]),e("br")])]),e("p",[n._v("超时的思路还是很简单的，不带超时参数的 await 是 park，然后等待别人唤醒。而现在就是调用 parkNanos 方法来休眠指定的时间，醒来后判断是否 signal 调用了，调用了就是没有超时，否则就是超时了。超时的话，自己来进行转移到阻塞队列，然后抢锁。")]),n._v(" "),e("h3",{attrs:{id:"不抛出-interruptedexception-的-await"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不抛出-interruptedexception-的-await"}},[n._v("#")]),n._v(" * 不抛出 InterruptedException 的 await")]),n._v(" "),e("p",[n._v("关于 Condition 最后一小节了。")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("public final void awaitUninterruptibly() {\n    Node node = addConditionWaiter();\n    int savedState = fullyRelease(node);\n    boolean interrupted = false;\n    while (!isOnSyncQueue(node)) {\n        LockSupport.park(this);\n        if (Thread.interrupted())\n            interrupted = true;\n    }\n    if (acquireQueued(node, savedState) || interrupted)\n        selfInterrupt();\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br")])]),e("p",[n._v("很简单，贴一下代码大家就都懂了，我就不废话了。")]),n._v(" "),e("h2",{attrs:{id:"abstractqueuedsynchronizer-独占锁的取消排队"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#abstractqueuedsynchronizer-独占锁的取消排队"}},[n._v("#")]),n._v(" AbstractQueuedSynchronizer 独占锁的取消排队")]),n._v(" "),e("p",[n._v("这篇文章说的是 AbstractQueuedSynchronizer，只不过好像 Condition 说太多了，赶紧把思路拉回来。")]),n._v(" "),e("p",[n._v("接下来，我想说说怎么取消对锁的竞争？")]),n._v(" "),e("p",[n._v("上篇文章提到过，最重要的方法是这个，我们要在这里面找答案：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("final boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return interrupted;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br")])]),e("p",[n._v("首先，到这个方法的时候，节点一定是入队成功的。")]),n._v(" "),e("p",[n._v("我把 parkAndCheckInterrupt() 代码贴过来：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("private final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this);\n    return Thread.interrupted();\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br")])]),e("p",[n._v("这两段代码联系起来看，是不是就清楚了。")]),n._v(" "),e("p",[n._v("如果我们要取消一个线程的排队，我们需要在另外一个线程中对其进行中断。比如某线程调用 lock() 老久不返回，我想中断它。一旦对其进行中断，此线程会从 "),e("code",[n._v("LockSupport.park(this);")]),n._v(" 中唤醒，然后 "),e("code",[n._v("Thread.interrupted();")]),n._v(" 返回 true。")]),n._v(" "),e("p",[n._v("我们发现一个问题，即使是中断唤醒了这个线程，也就只是设置了 "),e("code",[n._v("interrupted = true")]),n._v(" 然后继续下一次循环。而且，由于 "),e("code",[n._v("Thread.interrupted();")]),n._v(" 会清除中断状态，第二次进 parkAndCheckInterrupt 的时候，返回会是 false。")]),n._v(" "),e("p",[n._v("所以，我们要看到，在这个方法中，interrupted 只是用来记录是否发生了中断，然后用于方法返回值，其他没有做任何相关事情。")]),n._v(" "),e("p",[n._v("所以，我们看外层方法怎么处理 acquireQueued 返回 false 的情况。")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("public final void acquire(int arg) {\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\nstatic void selfInterrupt() {\n    Thread.currentThread().interrupt();\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br")])]),e("p",[n._v("所以说，lock() 方法处理中断的方法就是，你中断归中断，我抢锁还是照样抢锁，几乎没关系，只是我抢到锁了以后，设置线程的中断状态而已，也不抛出任何异常出来。调用者获取锁后，可以去检查是否发生过中断，也可以不理会。")]),n._v(" "),e("hr"),n._v(" "),e("p",[n._v("来条分割线。有没有被骗的感觉，我说了一大堆，可是和取消没有任何关系啊。")]),n._v(" "),e("p",[n._v("我们来看 ReentrantLock 的另一个 lock 方法：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("public void lockInterruptibly() throws InterruptedException {\n    sync.acquireInterruptibly(1);\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br")])]),e("p",[n._v("方法上多了个 "),e("code",[n._v("throws InterruptedException")]),n._v(" ，经过前面那么多知识的铺垫，这里我就不再啰里啰嗦了。")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("public final void acquireInterruptibly(int arg)\n        throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (!tryAcquire(arg))\n        doAcquireInterruptibly(arg);\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br")])]),e("p",[n._v("继续往里：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("private void doAcquireInterruptibly(int arg) throws InterruptedException {\n    final Node node = addWaiter(Node.EXCLUSIVE);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                // 就是这里了，一旦异常，马上结束这个方法，抛出异常。\n                // 这里不再只是标记这个方法的返回值代表中断状态\n                // 而是直接抛出异常，而且外层也不捕获，一直往外抛到 lockInterruptibly\n                throw new InterruptedException();\n        }\n    } finally {\n        // 如果通过 InterruptedException 异常出去，那么 failed 就是 true 了\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br")])]),e("p",[n._v("既然到这里了，顺便说说 cancelAcquire 这个方法吧：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("private void cancelAcquire(Node node) {\n    // Ignore if node doesn't exist\n    if (node == null)\n        return;\n    node.thread = null;\n    // Skip cancelled predecessors\n    // 找一个合适的前驱。其实就是将它前面的队列中已经取消的节点都”请出去“\n    Node pred = node.prev;\n    while (pred.waitStatus > 0)\n        node.prev = pred = pred.prev;\n    // predNext is the apparent node to unsplice. CASes below will\n    // fail if not, in which case, we lost race vs another cancel\n    // or signal, so no further action is necessary.\n    Node predNext = pred.next;\n    // Can use unconditional write instead of CAS here.\n    // After this atomic step, other Nodes can skip past us.\n    // Before, we are free of interference from other threads.\n    node.waitStatus = Node.CANCELLED;\n    // If we are the tail, remove ourselves.\n    if (node == tail && compareAndSetTail(node, pred)) {\n        compareAndSetNext(pred, predNext, null);\n    } else {\n        // If successor needs signal, try to set pred's next-link\n        // so it will get one. Otherwise wake it up to propagate.\n        int ws;\n        if (pred != head &&\n            ((ws = pred.waitStatus) == Node.SIGNAL ||\n             (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &&\n            pred.thread != null) {\n            Node next = node.next;\n            if (next != null && next.waitStatus <= 0)\n                compareAndSetNext(pred, predNext, next);\n        } else {\n            unparkSuccessor(node);\n        }\n        node.next = node; // help GC\n    }\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br"),e("span",{staticClass:"line-number"},[n._v("32")]),e("br"),e("span",{staticClass:"line-number"},[n._v("33")]),e("br"),e("span",{staticClass:"line-number"},[n._v("34")]),e("br"),e("span",{staticClass:"line-number"},[n._v("35")]),e("br"),e("span",{staticClass:"line-number"},[n._v("36")]),e("br"),e("span",{staticClass:"line-number"},[n._v("37")]),e("br"),e("span",{staticClass:"line-number"},[n._v("38")]),e("br")])]),e("p",[n._v("其实这个方法没什么好说的，一行行看下去就是了，节点取消，只要把 waitStatus 设置为 Node.CANCELLED，会有非常多的情况被从阻塞队列中请出去，主动或被动。")]),n._v(" "),e("h2",{attrs:{id:"再说-java-线程中断和-interruptedexception-异常"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#再说-java-线程中断和-interruptedexception-异常"}},[n._v("#")]),n._v(" 再说 java 线程中断和 InterruptedException 异常")]),n._v(" "),e("p",[n._v("在之前的文章中，我们接触了大量的中断，这边算是个总结吧。如果你完全熟悉中断了，没有必要再看这节，本节为新手而写。")]),n._v(" "),e("h3",{attrs:{id:"线程中断"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线程中断"}},[n._v("#")]),n._v(" 线程中断")]),n._v(" "),e("p",[n._v("首先，我们要明白，中断不是类似 linux 里面的命令 kill -9 pid，不是说我们中断某个线程，这个线程就停止运行了。中断代表线程状态，每个线程都关联了一个中断状态，是一个 true 或 false 的 boolean 值，初始值为 false。")]),n._v(" "),e("blockquote",[e("p",[n._v("Java 中的中断和操作系统的中断还不一样，这里就按照"),e("strong",[n._v("状态")]),n._v("来理解吧，不要和操作系统的中断联系在一起")])]),n._v(" "),e("p",[n._v("关于中断状态，我们需要重点关注 Thread 类中的以下几个方法：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// Thread 类中的实例方法，持有线程实例引用即可检测线程中断状态\npublic boolean isInterrupted() {}\n\n// Thread 中的静态方法，检测调用这个方法的线程是否已经中断\n// 注意：这个方法返回中断状态的同时，会将此线程的中断状态重置为 false\n// 所以，如果我们连续调用两次这个方法的话，第二次的返回值肯定就是 false 了\npublic static boolean interrupted() {}\n\n// Thread 类中的实例方法，用于设置一个线程的中断状态为 true\npublic void interrupt() {}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br")])]),e("p",[n._v("我们说中断一个线程，其实就是设置了线程的 interrupted status 为 true，至于说被中断的线程怎么处理这个状态，那是那个线程自己的事。如以下代码：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('while (!Thread.interrupted()) {\n   doWork();\n   System.out.println("我做完一件事了，准备做下一件，如果没有其他线程中断我的话");\n}\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br")])]),e("blockquote",[e("p",[n._v("这种代码就是会响应中断的，它会在干活的时候先判断下中断状态，不过，除了 JDK 源码外，其他用中断的场景还是比较少的，毕竟 JDK 源码非常讲究。")])]),n._v(" "),e("p",[n._v("当然，中断除了是线程状态外，还有其他含义，否则也不需要专门搞一个这个概念出来了。")]),n._v(" "),e("p",[n._v("如果线程处于以下三种情况，那么当线程被中断的时候，能自动感知到：")]),n._v(" "),e("ol",[e("li",[e("p",[n._v("来自 Object 类的 wait()、wait(long)、wait(long, int)，")]),n._v(" "),e("p",[n._v("来自 Thread 类的 join()、join(long)、join(long, int)、sleep(long)、sleep(long, int)")]),n._v(" "),e("blockquote",[e("p",[n._v("这几个方法的相同之处是，方法上都有: throws InterruptedException")]),n._v(" "),e("p",[n._v("如果线程阻塞在这些方法上（我们知道，这些方法会让当前线程阻塞），这个时候如果其他线程对这个线程进行了中断，那么这个线程会从这些方法中立即返回，抛出 InterruptedException 异常，同时重置中断状态为 false。")])])]),n._v(" "),e("li",[e("p",[n._v("实现了 InterruptibleChannel 接口的类中的一些 I/O 阻塞操作，如 DatagramChannel 中的 connect 方法和 receive 方法等")]),n._v(" "),e("blockquote",[e("p",[n._v("如果线程阻塞在这里，中断线程会导致这些方法抛出 ClosedByInterruptException 并重置中断状态。")])])]),n._v(" "),e("li",[e("p",[n._v("Selector 中的 select 方法，参考下我写的 NIO 的文章")]),n._v(" "),e("blockquote",[e("p",[n._v("一旦中断，方法立即返回")])])])]),n._v(" "),e("p",[n._v("对于以上 3 种情况是最特殊的，因为他们能自动感知到中断（这里说自动，当然也是基于底层实现），"),e("strong",[n._v("并且在做出相应的操作后都会重置中断状态为 false")]),n._v("。")]),n._v(" "),e("p",[n._v("那是不是只有以上 3 种方法能自动感知到中断呢？不是的，如果线程阻塞在 LockSupport.park(Object obj) 方法，也叫挂起，这个时候的中断也会导致线程唤醒，但是唤醒后不会重置中断状态，所以唤醒后去检测中断状态将是 true。")]),n._v(" "),e("h3",{attrs:{id:"interruptedexception-概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#interruptedexception-概述"}},[n._v("#")]),n._v(" InterruptedException 概述")]),n._v(" "),e("p",[n._v("它是一个特殊的异常，不是说 JVM 对其有特殊的处理，而是它的使用场景比较特殊。通常，我们可以看到，像 Object 中的 wait() 方法，ReentrantLock 中的 lockInterruptibly() 方法，Thread 中的 sleep() 方法等等，这些方法都带有 "),e("code",[n._v("throws InterruptedException")]),n._v("，我们通常称这些方法为阻塞方法（blocking method）。")]),n._v(" "),e("p",[n._v("阻塞方法一个很明显的特征是，它们需要花费比较长的时间（不是绝对的，只是说明时间不可控），还有它们的方法结束返回往往依赖于外部条件，如 wait 方法依赖于其他线程的 notify，lock 方法依赖于其他线程的 unlock等等。")]),n._v(" "),e("p",[n._v("当我们看到方法上带有 "),e("code",[n._v("throws InterruptedException")]),n._v(" 时，我们就要知道，这个方法应该是阻塞方法，我们如果希望它能早点返回的话，我们往往可以通过中断来实现。")]),n._v(" "),e("p",[n._v("除了几个特殊类（如 Object，Thread等）外，感知中断并提前返回是通过轮询中断状态来实现的。我们自己需要写可中断的方法的时候，就是通过在合适的时机（通常在循环的开始处）去判断线程的中断状态，然后做相应的操作（通常是方法直接返回或者抛出异常）。当然，我们也要看到，如果我们一次循环花的时间比较长的话，那么就需要比较长的时间才能"),e("strong",[n._v("感知")]),n._v("到线程中断了。")]),n._v(" "),e("h3",{attrs:{id:"处理中断"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#处理中断"}},[n._v("#")]),n._v(" 处理中断")]),n._v(" "),e("p",[n._v("一旦中断发生，我们接收到了这个信息，然后怎么去处理中断呢？本小节将简单分析这个问题。")]),n._v(" "),e("p",[n._v("我们经常会这么写代码：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("try {\n    Thread.sleep(10000);\n} catch (InterruptedException e) {\n    // ignore\n}\n// go on \n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br")])]),e("p",[n._v("当 sleep 结束继续往下执行的时候，我们往往都不知道这块代码是真的 sleep 了 10 秒，还是只休眠了 1 秒就被中断了。这个代码的问题在于，我们将这个异常信息吞掉了。（对于 sleep 方法，我相信大部分情况下，我们都不在意是否是中断了，这里是举例）")]),n._v(" "),e("p",[n._v("AQS 的做法很值得我们借鉴，我们知道 ReentrantLock 有两种 lock 方法：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("public void lock() {\n    sync.lock();\n}\n\npublic void lockInterruptibly() throws InterruptedException {\n    sync.acquireInterruptibly(1);\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br")])]),e("p",[n._v("前面我们提到过，lock() 方法不响应中断。如果 thread1 调用了 lock() 方法，过了很久还没抢到锁，这个时候 thread2 对其进行了中断，thread1 是不响应这个请求的，它会继续抢锁，当然它不会把“被中断”这个信息扔掉。我们可以看以下代码：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("public final void acquire(int arg) {\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        // 我们看到，这里也没做任何特殊处理，就是记录下来中断状态。\n        // 这样，如果外层方法需要去检测的时候，至少我们没有把这个信息丢了\n        selfInterrupt();// Thread.currentThread().interrupt();\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br")])]),e("p",[n._v("而对于 lockInterruptibly() 方法，因为其方法上面有 "),e("code",[n._v("throws InterruptedException")]),n._v(" ，这个信号告诉我们，如果我们要取消线程抢锁，直接中断这个线程即可，它会立即返回，抛出 InterruptedException 异常。")]),n._v(" "),e("p",[n._v("在并发包中，有非常多的这种处理中断的例子，提供两个方法，分别为响应中断和不响应中断，对于不响应中断的方法，记录中断而不是丢失这个信息。如 Condition 中的两个方法就是这样的：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("void await() throws InterruptedException;\nvoid awaitUninterruptibly();\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br")])]),e("blockquote",[e("p",[n._v("通常，如果方法会抛出 InterruptedException 异常，往往方法体的第一句就是：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("public final void await() throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n     ...... \n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br")])])]),n._v(" "),e("p",[n._v("熟练使用中断，对于我们写出优雅的代码是有帮助的，也有助于我们分析别人的源码。")]),n._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[n._v("#")]),n._v(" 总结")]),n._v(" "),e("p",[n._v("这篇文章的信息量真的很大，如果你花了时间，还是没有看懂，那是我的错了。")]),n._v(" "),e("p",[n._v("欢迎大家向我提问，我不一定能每次都及时出现，我出现也不一定能解决大家的问题，欢迎探讨。")])])}),[],!1,null,null,null);s.default=t.exports}}]);