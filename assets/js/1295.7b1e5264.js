(window.webpackJsonp=window.webpackJsonp||[]).push([[1295],{1688:function(e,n,t){"use strict";t.r(n);var i=t(13),a=Object(i.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("本文转自https://www.xilidou.com/2018/03/12/redis-data/\n作者：犀利豆\n本文将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看")]),e._v(" "),t("blockquote",[t("p",[e._v("https://github.com/h2pl/Java-Tutorial")])]),e._v(" "),t("p",[e._v("喜欢的话麻烦点下Star哈")]),e._v(" "),t("p",[e._v("本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。")]),e._v(" "),t("p",[e._v("该系列博文会告诉你如何从入门到进阶，Redis基本的使用方法，Redis的基本数据结构，以及一些进阶的使用方法，同时也需要进一步了解Redis的底层数据结构，再接着，还会带来Redis主从复制、集群、分布式锁等方面的相关内容，以及作为缓存的一些使用方法和注意事项，以便让你更完整地了解整个Redis相关的技术体系，形成自己的知识框架。")]),e._v(" "),t("p",[e._v("如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。")]),e._v(" "),t("p",[e._v("原文地址：https://www.xilidou.com/2018/03/22/redis-event/")]),e._v(" "),t("p",[e._v("Redis 是一个事件驱动的内存数据库，服务器需要处理两种类型的事件。")]),e._v(" "),t("p",[e._v("文件事件\n时间事件\n下面就会介绍这两种事件的实现原理。")]),e._v(" "),t("p",[e._v("文件事件\nRedis 服务器通过 socket 实现与客户端（或其他redis服务器）的交互,文件事件就是服务器对 socket 操作的抽象。 Redis 服务器，通过监听这些 socket 产生的文件事件并处理这些事件，实现对客户端调用的响应。")]),e._v(" "),t("p",[e._v("Reactor\nRedis 基于 Reactor 模式开发了自己的事件处理器。")]),e._v(" "),t("p",[e._v("这里就先展开讲一讲 Reactor 模式。看下图：\n"),t("img",{attrs:{src:"https://img.xilidou.com/img/Reactor.jpg",alt:"image"}}),e._v("\nreactor")]),e._v(" "),t("p",[e._v("“I/O 多路复用模块”会监听多个 FD ，当这些FD产生，accept，read，write 或 close 的文件事件。会向“文件事件分发器（dispatcher）”传送事件。")]),e._v(" "),t("p",[e._v("文件事件分发器（dispatcher）在收到事件之后，会根据事件的类型将事件分发给对应的 handler。")]),e._v(" "),t("p",[e._v("我们顺着图，从上到下的逐一讲解 Redis 是怎么实现这个 Reactor 模型的。")]),e._v(" "),t("p",[e._v("I/O 多路复用模块\nRedis 的 I/O 多路复用模块，其实是封装了操作系统提供的 select，epoll，avport 和 kqueue 这些基础函数。向上层提供了一个统一的接口，屏蔽了底层实现的细节。")]),e._v(" "),t("p",[e._v("一般而言 Redis 都是部署到 Linux 系统上，所以我们就看看使用 Redis 是怎么利用 linux 提供的 epoll 实现I/O 多路复用。")]),e._v(" "),t("p",[e._v("首先看看 epoll 提供的三个方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("/*\n * 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大\n */\nint epoll_create(int size)；\n\n/*\n * 可以理解为，增删改 fd 需要监听的事件\n * epfd 是 epoll_create() 创建的句柄。\n * op 表示 增删改\n * epoll_event 表示需要监听的事件，Redis 只用到了可读，可写，错误，挂断 四个状态\n */\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；\n\n/*\n * 可以理解为查询符合条件的事件\n * epfd 是 epoll_create() 创建的句柄。\n * epoll_event 用来存放从内核得到事件的集合\n * maxevents 获取的最大事件数\n * timeout 等待超时时间\n */\nint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);\n再看 Redis 对文件事件，封装epoll向上提供的接口：\n\n\n/*\n * 事件状态\n */\ntypedef struct aeApiState {\n\n    // epoll_event 实例描述符\n    int epfd;\n\n    // 事件槽\n    struct epoll_event *events;\n\n} aeApiState;\n\n/*\n * 创建一个新的 epoll \n */\nstatic int  aeApiCreate(aeEventLoop *eventLoop)\n/*\n * 调整事件槽的大小\n */\nstatic int  aeApiResize(aeEventLoop *eventLoop, int setsize)\n/*\n * 释放 epoll 实例和事件槽\n */\nstatic void aeApiFree(aeEventLoop *eventLoop)\n/*\n * 关联给定事件到 fd\n */\nstatic int  aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask)\n/*\n * 从 fd 中删除给定事件\n */\nstatic void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask)\n/*\n * 获取可执行事件\n */\nstatic int  aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp)\n")])])]),t("p",[e._v("所以看看这个ae_peoll.c 如何对 epoll 进行封装的：")]),e._v(" "),t("p",[e._v("aeApiCreate() 是对 epoll.epoll_create() 的封装。\naeApiAddEvent()和aeApiDelEvent() 是对 epoll.epoll_ctl()的封装。\naeApiPoll() 是对 epoll_wait()的封装。\n这样 Redis 的利用 epoll 实现的 I/O 复用器就比较清晰了。")]),e._v(" "),t("p",[e._v("再往上一层次我们需要看看 ea.c 是怎么封装的？")]),e._v(" "),t("p",[e._v("首先需要关注的是事件处理器的数据结构：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("typedef struct aeFileEvent {\n\n    // 监听事件类型掩码，\n    // 值可以是 AE_READABLE 或 AE_WRITABLE ，\n    // 或者 AE_READABLE | AE_WRITABLE\n    int mask; /* one of AE_(READABLE|WRITABLE) */\n\n    // 读事件处理器\n    aeFileProc *rfileProc;\n\n    // 写事件处理器\n    aeFileProc *wfileProc;\n\n    // 多路复用库的私有数据\n    void *clientData;\n\n} aeFileEvent;\n")])])]),t("p",[e._v("mask 就是可以理解为事件的类型。")]),e._v(" "),t("p",[e._v("除了使用 ae_peoll.c 提供的方法外,ae.c 还增加 “增删查” 的几个 API。")]),e._v(" "),t("p",[e._v("增:aeCreateFileEvent\n删:aeDeleteFileEvent\n查: 查包括两个维度 aeGetFileEvents 获取某个 fd 的监听类型和aeWait等待某个fd 直到超时或者达到某个状态。\n事件分发器（dispatcher）\nRedis 的事件分发器 ae.c/aeProcessEvents 不但处理文件事件还处理时间事件，所以这里只贴与文件分发相关的出部分代码，dispather 根据 mask 调用不同的事件处理器。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("//从 epoll 中获关注的事件\nnumevents = aeApiPoll(eventLoop, tvp);\nfor (j = 0; j < numevents; j++) {\n    // 从已就绪数组中获取事件\n    aeFileEvent *fe = &eventLoop->events[eventLoop->fired[j].fd];\n\n    int mask = eventLoop->fired[j].mask;\n    int fd = eventLoop->fired[j].fd;\n    int rfired = 0;\n\n    // 读事件\n    if (fe->mask & mask & AE_READABLE) {\n        // rfired 确保读/写事件只能执行其中一个\n        rfired = 1;\n        fe->rfileProc(eventLoop,fd,fe->clientData,mask);\n    }\n    // 写事件\n    if (fe->mask & mask & AE_WRITABLE) {\n        if (!rfired || fe->wfileProc != fe->rfileProc)\n            fe->wfileProc(eventLoop,fd,fe->clientData,mask);\n    }\n\n    processed++;\n}\n")])])]),t("p",[e._v("可以看到这个分发器，根据 mask 的不同将事件分别分发给了读事件和写事件。")]),e._v(" "),t("p",[e._v("文件事件处理器的类型\nRedis 有大量的事件处理器类型，我们就讲解处理一个简单命令涉及到的三个处理器：")]),e._v(" "),t("p",[e._v("acceptTcpHandler 连接应答处理器，负责处理连接相关的事件，当有client 连接到Redis的时候们就会产生 AE_READABLE 事件。引发它执行。\nreadQueryFromClinet 命令请求处理器，负责读取通过 sokect 发送来的命令。\nsendReplyToClient 命令回复处理器，当Redis处理完命令，就会产生 AE_WRITEABLE 事件，将数据回复给 client。\n文件事件实现总结\n我们按照开始给出的 Reactor 模型，从上到下讲解了文件事件处理器的实现，下面将会介绍时间时间的实现。")]),e._v(" "),t("p",[e._v("时间事件\nReids 有很多操作需要在给定的时间点进行处理，时间事件就是对这类定时任务的抽象。")]),e._v(" "),t("p",[e._v("先看时间事件的数据结构：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("/* Time event structure\n *\n * 时间事件结构\n */\ntypedef struct aeTimeEvent {\n\n    // 时间事件的唯一标识符\n    long long id; /* time event identifier. */\n\n    // 事件的到达时间\n    long when_sec; /* seconds */\n    long when_ms; /* milliseconds */\n\n    // 事件处理函数\n    aeTimeProc *timeProc;\n\n    // 事件释放函数\n    aeEventFinalizerProc *finalizerProc;\n\n    // 多路复用库的私有数据\n    void *clientData;\n\n    // 指向下个时间事件结构，形成链表\n    struct aeTimeEvent *next;\n\n} aeTimeEvent;\n")])])]),t("p",[e._v("看见 next 我们就知道这个 aeTimeEvent 是一个链表结构。看图：\n"),t("img",{attrs:{src:"https://img.xilidou.com/img/timeEvent.jpg",alt:"image"}})]),e._v(" "),t("p",[e._v("timeEvent")]),e._v(" "),t("p",[e._v("注意这是一个按照id倒序排列的链表，并没有按照事件顺序排序。")]),e._v(" "),t("p",[e._v("processTimeEvent\nRedis 使用这个函数处理所有的时间事件，我们整理一下执行思路：")]),e._v(" "),t("p",[e._v("记录最新一次执行这个函数的时间，用于处理系统时间被修改产生的问题。\n遍历链表找出所有 when_sec 和 when_ms 小于现在时间的事件。\n执行事件对应的处理函数。\n检查事件类型，如果是周期事件则刷新该事件下一次的执行事件。\n否则从列表中删除事件。\n综合调度器（aeProcessEvents）\n综合调度器是 Redis 统一处理所有事件的地方。我们梳理一下这个函数的简单逻辑：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 1. 获取离当前时间最近的时间事件\nshortest = aeSearchNearestTimer(eventLoop);\n\n// 2. 获取间隔时间\ntimeval = shortest - nowTime;\n\n// 如果timeval 小于 0，说明已经有需要执行的时间事件了。\nif(timeval < 0){\n    timeval = 0\n}\n\n// 3. 在 timeval 时间内，取出文件事件。\nnumevents = aeApiPoll(eventLoop, timeval);\n\n// 4.根据文件事件的类型指定不同的文件处理器\nif (AE_READABLE) {\n    // 读事件\n    rfileProc(eventLoop,fd,fe->clientData,mask);\n}\n    // 写事件\nif (AE_WRITABLE) {\n    wfileProc(eventLoop,fd,fe->clientData,mask);\n}\n")])])]),t("p",[e._v("以上的伪代码就是整个 Redis 事件处理器的逻辑。")]),e._v(" "),t("p",[e._v("我们可以再看看谁执行了这个 aeProcessEvents:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("void aeMain(aeEventLoop *eventLoop) {\n\n    eventLoop->stop = 0;\n\n    while (!eventLoop->stop) {\n\n        // 如果有需要在事件处理前执行的函数，那么运行它\n        if (eventLoop->beforesleep != NULL)\n            eventLoop->beforesleep(eventLoop);\n\n        // 开始处理事件\n        aeProcessEvents(eventLoop, AE_ALL_EVENTS);\n    }\n}\n")])])]),t("p",[e._v("然后我们再看看是谁调用了 eaMain:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("int main(int argc, char **argv) {\n    //一些配置和准备\n    ...\n    aeMain(server.el);\n    \n    //结束后的回收工作\n    ...\n}\n")])])]),t("p",[e._v("我们在 Redis 的 main 方法中找个了它。")]),e._v(" "),t("p",[e._v("这个时候我们整理出的思路就是:")]),e._v(" "),t("p",[e._v("Redis 的 main() 方法执行了一些配置和准备以后就调用 eaMain() 方法。")]),e._v(" "),t("p",[e._v("eaMain() while(true) 的调用 aeProcessEvents()。")]),e._v(" "),t("p",[e._v("所以我们说 Redis 是一个事件驱动的程序，期间我们发现，Redis 没有 fork 过任何线程。所以也可以说 Redis 是一个基于事件驱动的单线程应用。")]),e._v(" "),t("p",[e._v("总结\n在后端的面试中 Redis 总是一个或多或少会问到的问题。")]),e._v(" "),t("p",[e._v("读完这篇文章你也许就能回答这几个问题：")]),e._v(" "),t("p",[e._v("为什么 Redis 是一个单线程应用？\n为什么 Redis 是一个单线程应用，却有如此高的性能？\n如果你用本文提供的知识点回答这两个问题，一定会在面试官心中留下一个高大的形象。")]),e._v(" "),t("p",[e._v("大家还可以阅读我的 Redis 相关的文章：")])])}),[],!1,null,null,null);n.default=a.exports}}]);