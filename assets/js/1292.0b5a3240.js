(window.webpackJsonp=window.webpackJsonp||[]).push([[1292],{1690:function(s,t,a){"use strict";a.r(t);var e=a(13),r=Object(e.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[s._v("(PS：扫描"),a("RouterLink",{attrs:{to:"/middleware/redis/"}},[s._v("首页里面的二维码")]),s._v("进群，分享我自己在看的技术资料给大家，希望和大家一起学习进步！)")],1),s._v(" "),a("p",[s._v("下面是主要是自己看完《Redis设计与实现》，《Redis深度历险：核心原理与应用实践》后，为了更好得掌握Redis，网上找了一些面试题，查阅书籍和资料后，写的解答。")]),s._v(" "),a("h4",{attrs:{id:"_1-redis主从同步是怎么实现的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-redis主从同步是怎么实现的"}},[s._v("#")]),s._v(" "),a("a",{attrs:{href:"#Redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"}},[s._v("1.Redis主从同步是怎么实现的？")])]),s._v(" "),a("h4",{attrs:{id:"_2-redis中哨兵是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-redis中哨兵是什么"}},[s._v("#")]),s._v(" "),a("a",{attrs:{href:"#Redis%E4%B8%AD%E5%93%A8%E5%85%B5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"}},[s._v("2.Redis中哨兵是什么？")])]),s._v(" "),a("h4",{attrs:{id:"_3-客户端是怎么接入哨兵系统的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-客户端是怎么接入哨兵系统的"}},[s._v("#")]),s._v(" "),a("a",{attrs:{href:"#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%98%AF%E6%80%8E%E4%B9%88%E6%8E%A5%E5%85%A5%E5%93%A8%E5%85%B5%E7%B3%BB%E7%BB%9F%E7%9A%84%EF%BC%9F"}},[s._v("3.客户端是怎么接入哨兵系统的？")])]),s._v(" "),a("h4",{attrs:{id:"_4-redis哨兵系统是怎么实现自动故障转移的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-redis哨兵系统是怎么实现自动故障转移的"}},[s._v("#")]),s._v(" "),a("a",{attrs:{href:"#Redis%E5%93%A8%E5%85%B5%E7%B3%BB%E7%BB%9F%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E7%9A%84%EF%BC%9F"}},[s._v("4.Redis哨兵系统是怎么实现自动故障转移的？")])]),s._v(" "),a("h4",{attrs:{id:"_5-谈一谈你对redis-cluster的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-谈一谈你对redis-cluster的理解"}},[s._v("#")]),s._v(" "),a("a",{attrs:{href:"#%E8%B0%88%E4%B8%80%E8%B0%88%E4%BD%A0%E5%AF%B9RedisCluster%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"}},[s._v("5.谈一谈你对Redis Cluster的理解？")])]),s._v(" "),a("h4",{attrs:{id:"_6-rediscluster是怎么实现数据分片的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-rediscluster是怎么实现数据分片的"}},[s._v("#")]),s._v(" "),a("a",{attrs:{href:"#RedisCluster%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87%E7%9A%84%EF%BC%9F"}},[s._v("6.RedisCluster是怎么实现数据分片的？")])]),s._v(" "),a("h4",{attrs:{id:"_7-rediscluster是怎么做故障转移和发现的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-rediscluster是怎么做故障转移和发现的"}},[s._v("#")]),s._v(" "),a("a",{attrs:{href:"#RedisCluster%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E5%92%8C%E5%8F%91%E7%8E%B0%E7%9A%84%EF%BC%9F"}},[s._v("7.RedisCluster是怎么做故障转移和发现的？")])]),s._v(" "),a("h3",{attrs:{id:"redis主从同步是怎么实现的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis主从同步是怎么实现的"}},[s._v("#")]),s._v(" Redis主从同步是怎么实现的？")]),s._v(" "),a("p",[s._v("主从节点建立连接后，从节点会进行判断：")]),s._v(" "),a("p",[s._v("1.如果这是从节点之前没有同步过数据")]),s._v(" "),a("p",[s._v("属于初次复制，会进行"),a("strong",[s._v("全量重同步")]),s._v("，那么从节点会向主节点发送PSYNC?-1 命令，请求主节点进行"),a("strong",[s._v("全量重同步")]),s._v("。")]),s._v(" "),a("p",[s._v("2.如果从节点不是初次复制（例如出现掉线后重连）\n这个时候从节点会将之前进行同步的Replication ID(一个随机字符串，标识主节点上的特定数据集)和offset（从服务器当前的复制偏移量）通过PSYNC id offset命令发送给主节点，主节点会进行判断，")]),s._v(" "),a("ul",[a("li",[s._v("如果Replication ID跟当前的Replication ID不一致(可能主节点进行了变化)，或者是当前buffer缓冲区中不存在对应的offset，那么会跟上面的初次复制一样，进行"),a("strong",[s._v("全量重同步")]),s._v("。")]),s._v(" "),a("li",[s._v("如果Replication ID跟当前的Replication ID一致并且当前buffer缓冲区中存在对应的offset，那么会进行"),a("strong",[s._v("部分重同步")]),s._v("。（部分重同步是Redis 2.8之后的版本支持的，主要基于性能考虑，为了断线期间的小部分数据修改进行全量重同步效率比较低）")])]),s._v(" "),a("h5",{attrs:{id:"全量重同步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全量重同步"}},[s._v("#")]),s._v(" 全量重同步")]),s._v(" "),a("p",[s._v("主节点会执行BGSAVE命令，fork出一个子进程，在后台生成一个RDB持久化文件，完成后，发送给从服务器，从节点接受并载入RDB文件，使得从节点的数据库状态更新至主节点执行BGSAVE命令时的状态。并且在生成RDB文件期间，主节点也会使用一个缓冲区来记录这个期间执行的所有写命令，将这些命令发送给从节点，从节点执行命令将自己数据库状态更新至与主节点完全一致。")]),s._v(" "),a("h5",{attrs:{id:"部分重同步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#部分重同步"}},[s._v("#")]),s._v(" 部分重同步")]),s._v(" "),a("p",[s._v("因为此时从节点只是落后主节点一小段时间的数据修改，并且偏移量在复制缓冲区buffer中可以找到，所以主节点把从节点落后的这部分数据修改命令发送给从节点，完成同步。")]),s._v(" "),a("h5",{attrs:{id:"命令传播"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命令传播"}},[s._v("#")]),s._v(" 命令传播")]),s._v(" "),a("p",[s._v("在执行全量重同步或者部分重同步以后，主从节点的数据库状态达到一致后，会进入到命令传播阶段。主节点执行修改命令后，会将修改命令添加到内存中的buffer缓冲区（是一个定长的环形数组，满了时就会覆盖前面的数据），然后异步地将buffer缓冲区的命令发送给从节点。")]),s._v(" "),a("h3",{attrs:{id:"redis中哨兵是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis中哨兵是什么"}},[s._v("#")]),s._v(" Redis中哨兵是什么？")]),s._v(" "),a("p",[s._v("Redis中的哨兵服务器是一个运行在哨兵模式下的Redis服务器，核心功能是监测主节点和从节点的运行情况，在主节点出现故障后，完成自动故障转移，让某个从节点升级为主节点。")]),s._v(" "),a("h3",{attrs:{id:"客户端是怎么接入哨兵系统的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#客户端是怎么接入哨兵系统的"}},[s._v("#")]),s._v(" 客户端是怎么接入哨兵系统的？")]),s._v(" "),a("p",[s._v("**配置提供者：**前者只负责存储当前最新的主从节点信息，供客户端获取。")]),s._v(" "),a("p",[a("strong",[s._v("代理")]),s._v("：客户端所有请求都会经过哨兵节点。")]),s._v(" "),a("p",[s._v("首先Redis中的哨兵节点是一个配置提供者，而不是代理。因为客户端只是在首次连接时从哨兵节点获取主节点信息，后续直接与主节点进行连接，发送请求，接收请求结果。")]),s._v(" "),a("p",[s._v("具体流程：")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),s._v(" masterName "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"mymaster"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Set")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" sentinels "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("HashSet")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n sentinels"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"192.168.92.128:26379"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n sentinels"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"192.168.92.128:26380"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("JedisSentinelPool")]),s._v(" pool "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("JedisSentinelPool")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("masterName"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" sentinels"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//初始化过程做了很多工作")]),s._v("\n "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Jedis")]),s._v(" jedis "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" pool"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("getResource")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n jedis"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("set")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"key1"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"value1"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n pool"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("close")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v('在实际开发中，通过在客户端配置哨兵节点的地址+主节点的名称(哨兵系统可能会监控多个主从节点，名称用于区分)就可以与哨兵节点建立连接，获取到主节点信息，然后与主节点建立连接，并且订阅哨兵节点的频道，以便在主节点变化后，接受到通知。\n上面的代码在底层实现是客户端向依次向哨兵节点发送"sentinel get-master-addr-by-name"命令，成功获得主节点信息就不向后面的哨兵节点发送命令。同时客户端会订阅哨兵节点的+switch-master频道，一旦主节点发送故障，哨兵服务器对主节点进行自动故障转移，会将从节点升级主节点，并且更新哨兵服务器中存储的主节点信息，会向+switch-master频道发送消息，客户端得到消息后重新从哨兵节点获取主节点信息，初始化连接池。')]),s._v(" "),a("h3",{attrs:{id:"redis哨兵系统是怎么实现自动故障转移的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis哨兵系统是怎么实现自动故障转移的"}},[s._v("#")]),s._v(" Redis哨兵系统是怎么实现自动故障转移的？")]),s._v(" "),a("h5",{attrs:{id:"_1-认定主节点主观下线"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-认定主节点主观下线"}},[s._v("#")]),s._v(" 1.认定主节点主观下线")]),s._v(" "),a("p",[s._v("因为每隔2s，哨兵节点会给主节点发送PING命令，如果在一定时间间隔内，都没有收到回复，那么哨兵节点就认为主节点主观下线。")]),s._v(" "),a("h5",{attrs:{id:"_2-认定主节点客观下线"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-认定主节点客观下线"}},[s._v("#")]),s._v(" 2.认定主节点客观下线")]),s._v(" "),a("p",[s._v("哨兵节点认定主节点主观下线后，会向其他哨兵节点发送sentinel is-master-down-by-addr命令，获取其他哨兵节点对该主节点的状态，当认定主节点下线的哨兵数量达到一定数值时(这个阀值是Sentinel配置中quorum参数的值，通常我们设置为哨兵总节点数的1/2)，就认定主节点客观下线。")]),s._v(" "),a("h5",{attrs:{id:"_3-进行领导者哨兵选举"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-进行领导者哨兵选举"}},[s._v("#")]),s._v(" 3.进行领导者哨兵选举")]),s._v(" "),a("p",[s._v("认定主节点客观下线后,各个哨兵之间相互通信，选举出一个领导者哨兵，由它来对主节点进行故障转移操作。")]),s._v(" "),a("p",[s._v("选举使用的是Raft算法，基本思路是所有哨兵节点A会先其他哨兵节点，发送命令，申请成为该哨兵节点B的领导者，如果B还没有同意过其他哨兵节点，那么就同意A成为领导者，最终得票超过半数以上的哨兵节点会赢得选举，如果本次投票，没有选举出领导者哨兵，那么就开始新一轮的选举，直到选举出哨兵节点（实际开发中，最先判定主节点客观下线的哨兵节点，一般就能成为领导者。）")]),s._v(" "),a("h5",{attrs:{id:"_4-领导者哨兵进行故障转移"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-领导者哨兵进行故障转移"}},[s._v("#")]),s._v(" 4.领导者哨兵进行故障转移")]),s._v(" "),a("p",[s._v("领导者哨兵节点首先会从从节点中选出一个节点作为新的主节点。选择的规则是：")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("1.首先排除一些不健康的节点。（下线的，断线的，最近5s没有回复哨兵节点的INFO命令的，与旧的主服务器断开连接时间较长的）")])]),s._v(" "),a("li",[a("p",[s._v("2.然后根据优先级，复制偏移量，runid最小，来选出一个从节点作为主节点。")])])]),s._v(" "),a("p",[s._v("向这个从节点发送slaveof no one命令，让其成为主节点，通过slaveof 命令让其他从节点成为它的从节点，将已下线的主节点更新为新的主节点的从节点，将其他从节点的复制目标改完新的主节点，将旧的主服务器改为从服务器。")]),s._v(" "),a("h3",{attrs:{id:"谈一谈你对rediscluster的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#谈一谈你对rediscluster的理解"}},[s._v("#")]),s._v(" 谈一谈你对RedisCluster的理解？")]),s._v(" "),a("p",[s._v("当需要存储的数据量特别大，单个Redis实例无法满足需求，所以需要分片，早期很多业务就是在业务中进行分片，通过自定义一些业务规则，将不同的数据存储在不同的Redis实例中。后来就有了官方推出的集群化方案Redis Cluster。")]),s._v(" "),a("h3",{attrs:{id:"rediscluster是怎么实现数据分片的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rediscluster是怎么实现数据分片的"}},[s._v("#")]),s._v(" RedisCluster是怎么实现数据分片的？")]),s._v(" "),a("p",[s._v("首先Redis Cluster设定了有16384个槽位，然后根据启动时集群的主节点数量进行均分，每个主节点得到一定数量的槽位，为了保证每个主节点挂掉之后，服务保持高可用，一般会为每个主节点配置几个从节点，从节点保存了主节点上同步过来的数据，一旦主节点挂掉，会有一个从节点会被选为主节点。客户端在与Redis Cluster建立连接时会获取到各槽位与主节点之间的映射关系，然后缓存到本地。")]),s._v(" "),a("p",[s._v("客户端执行命令的流程：")]),s._v(" "),a("p",[s._v("假设客户端需要发送一个查询请求时，首先会对key使用CRC16算法计算得到一个hash值，然后将hash值与16384(也就是2的14次方)进行取模(下面是网上找的图，应该是CRC16(key)%16384)，得到一个槽位slot，然后根据本地缓存的槽位映射关系表，找到这个槽位slot对应的主节点，发送查询命令。主节点在收到命令后会有以下几种情况：")]),s._v(" "),a("p",[a("strong",[s._v("1.这个主节点确实负责这个槽位，且不在迁移中。")])]),s._v(" "),a("p",[s._v("直接查询到这个键值对，返回给客户端。")]),s._v(" "),a("p",[a("strong",[s._v("2.这个主节点不负责这个槽位，或者已经确定转移到其他节点上去了(Moved指令)")])]),s._v(" "),a("p",[s._v("可能是这个槽位已经迁移了，或者是客户端将指令发送到了错误的节点，或者是客户端缓存的槽位映射关系以前过期。主节点就会给客户端返回Moved指令及正确的节点信息，Moved指令相当于是一个永久重定向指令，用于纠正客户端缓存的错误槽位信息。客户端收到后会更新本地的槽位关系表，然后向正确的节点发送查询指令。")]),s._v(" "),a("p",[a("strong",[s._v("3.这个槽位正在迁移中(ASKING指令)")])]),s._v(" "),a("p",[s._v("如果这个槽位之前是在这个主节点上，但是目前正在迁移(槽位状态为IMPORTING)，那么如果现在主节点上存在这个可以，就成功处理请求。否则就返回ASKING指令+槽位所在的新节点，ASKING指令相当于是一个临时重定向指令，客户端收到之后不会更新本地的槽位关系表，只是将本次请求发送到新节点。")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://txxs.github.io/pic/interviewGuide-storage/640-20210124192752928",alt:"图片"}})]),s._v(" "),a("h4",{attrs:{id:"redis-cluster的节点扩容和下线"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-cluster的节点扩容和下线"}},[s._v("#")]),s._v(" Redis Cluster的节点扩容和下线")]),s._v(" "),a("h5",{attrs:{id:"扩容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#扩容"}},[s._v("#")]),s._v(" 扩容")]),s._v(" "),a("p",[s._v("例如数据量太大了，原有的节点太少了，希望增加一些Redis实例，分担一些数据量。在Redis Cluster中，需要程序员手动执行命令，将节点添加到集群，并执行命令从其他的主节点上分配一些槽位到这个新节点上。")]),s._v(" "),a("p",[s._v("具体执行命令流程如下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("./redis-trib.rb add-node 127.0.0.1:7006 127.0.0.1:7000\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("可以看到.使用"),a("strong",[s._v("addnode")]),s._v("命令来添加节点，第一个参数是新节点的地址，第二个参数是任意一个已经存在的节点的IP和端口。")]),s._v(" "),a("p",[s._v("新节点现在已经连接上了集群， 成为集群的一份子， 并且可以对客户端的命令请求进行转向了， 但是和其他主节点相比， 新节点还有两点区别：")]),s._v(" "),a("ul",[a("li",[s._v("新节点没有包含任何数据， 因为它没有包含任何哈希槽位.")]),s._v(" "),a("li",[s._v("尽管新节点没有包含任何哈希槽位， 但它仍然是一个主节点， 所以在集群需要将某个从节点升级为新的主节点时， 这个新节点不会被选中。")])]),s._v(" "),a("p",[s._v("接下来， 只要使用 redis-trib 程序， 将集群中的某些哈希槽位移动到新节点里面， 新节点就会成为真正的主节点了。")]),s._v(" "),a("p",[s._v("槽位迁移需要执行的命令会比较的多，大家想了解的可以看看这篇文章：")]),s._v(" "),a("p",[s._v("https://www.cnblogs.com/youngchaolin/archive/2004/01/13/12034660.html")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://txxs.github.io/pic/interviewGuide-storage/640-20210124203435521",alt:"图片"}})]),s._v(" "),a("h5",{attrs:{id:"下线"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#下线"}},[s._v("#")]),s._v(" 下线")]),s._v(" "),a("p",[s._v("在节点上执行 redis-trib.rb del-node{host:port} {donwNodeId}  通知其他的节点，自己下线，如果本节点是主节点，会安排对应的从节点阶梯主节点的位置。")]),s._v(" "),a("h4",{attrs:{id:"rediscluster是怎么做故障转移和发现的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rediscluster是怎么做故障转移和发现的"}},[s._v("#")]),s._v(" RedisCluster是怎么做故障转移和发现的？")]),s._v(" "),a("h5",{attrs:{id:"_1-主观下线"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-主观下线"}},[s._v("#")]),s._v(" 1.主观下线")]),s._v(" "),a("p",[s._v("当节点 1 向节点 2 例行发送 Ping 消息的时候，如果节点 2 正常工作就会返回 Pong 消息，同时会记录节点 1的相关信息，更新与节点2的最近通讯时间。如果节点 1的定时任务检测到与节点 2 上次通讯的时间超过了 cluster-node-timeout 的时候，就会更新本地节点状态，把节点 2 更新为主观下线。")]),s._v(" "),a("h5",{attrs:{id:"_2-客观下线"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-客观下线"}},[s._v("#")]),s._v(" 2.客观下线：")]),s._v(" "),a("p",[s._v("由于 Redis Cluster 的节点不断地与集群内的节点进行通讯，下线信息也会通过 Gossip 消息传遍所有节点。")]),s._v(" "),a("p",[s._v("因此集群内的节点会不断收到下线报告，当半数以上持有槽的主节点标记了某个节点是主观下线时，便会认为节点2"),a("strong",[s._v("客观下线")]),s._v("，执行后面的流程。")]),s._v(" "),a("h5",{attrs:{id:"_3-资格检查"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-资格检查"}},[s._v("#")]),s._v(" 3.资格检查")]),s._v(" "),a("p",[s._v("每个从节点都会检查与主节点断开的时间。如果这个时间超过了 cluster-node-timeout*cluster-slave-validity-factor（从节点有效因子，默认为 10），那么就没有故障转移的资格。也就是说这个从节点和主节点断开的太久了，很久没有同步主节点的数据了，不适合成为新的主节点，因为成为新的主节点以后，其他的从节点回同步它的数据。")]),s._v(" "),a("h5",{attrs:{id:"_4-从节点触发选举"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-从节点触发选举"}},[s._v("#")]),s._v(" 4.从节点触发选举")]),s._v(" "),a("p",[s._v("通过资格的从节点都可以触发选举。但是触发选举是有先后顺序的，这里按照复制偏移量的大小来判断。")]),s._v(" "),a("p",[s._v("这个偏移量记录了执行命令的字节数。主服务器每次向从服务器传播 N 个字节时就会将自己的复制偏移量+N，从服务在接收到主服务器传送来的 N 个字节的命令时，就将自己的复制偏移量+N。")]),s._v(" "),a("p",[s._v("复制偏移量越大说明从节点延迟越低，也就是该从节点和主节点沟通更加频繁，该从节点上面的数据也会更新一些，因此复制偏移量大的从节点会率先发起选举。")]),s._v(" "),a("h5",{attrs:{id:"_5-从节点发起选举"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-从节点发起选举"}},[s._v("#")]),s._v(" 5.从节点发起选举")]),s._v(" "),a("p",[s._v("首先每个主节点会去更新配置纪元（clusterNode.configEpoch），这个值是不断增加的整数。")]),s._v(" "),a("p",[s._v("在节点进行 Ping/Pong 消息交互时也会更新这个值，它们都会将最大的值更新到自己的配置纪元中。")]),s._v(" "),a("p",[s._v("这个值记录了每个节点的版本和整个集群的版本。每当发生重要事情的时候，例如：出现新节点，从节点精选。都会增加全局的配置纪元并且赋给相关的主节点，用来记录这个事件。")]),s._v(" "),a("p",[s._v("说白了更新这个值目的是，保证所有主节点对这件“大事”保持一致。大家都统一成一个配置纪元（一个整数），表示大家都知道这个“大事”了。")]),s._v(" "),a("p",[s._v("更新完配置纪元以后，每个从节点会向集群内发起广播选举的消息。")]),s._v(" "),a("h5",{attrs:{id:"_6-主节点为选举投票"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-主节点为选举投票"}},[s._v("#")]),s._v(" 6.主节点为选举投票")]),s._v(" "),a("p",[s._v("参与投票的只有主节点，从节点没有投票权。每个主节点在收到从节点请求投票的信息后，如果它还没有为其他从节点投票，那么就会把票投给从节点。(也就是主节点的票只会投给第一个请求它选票的从节点。)")]),s._v(" "),a("p",[s._v("超过半数的主节点通过某一个节点成为新的主节点时投票完成。")]),s._v(" "),a("p",[s._v("如果在 cluster-node-timeout*2 的时间内从节点没有获得足够数量的票数，本次选举作废，进行第二轮选举。")]),s._v(" "),a("p",[s._v("这里每个候选的从节点会收到其他主节点投的票。在第2步领先的从节点通常此时会获得更多的票，因为它触发选举的时间更早一些。")]),s._v(" "),a("p",[s._v("获得票的机会更大，也是由于它和原主节点延迟少，理论上数据会更加新一点。")]),s._v(" "),a("h5",{attrs:{id:"_7-选举完成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-选举完成"}},[s._v("#")]),s._v(" 7.选举完成")]),s._v(" "),a("p",[s._v("当满足投票条件的从节点被选出来以后，会触发替换主节点的操作。新的主节点别选出以后，删除原主节点负责的槽数据，把这些槽数据添加到自己节点上。")]),s._v(" "),a("p",[s._v("并且广播让其他的节点都知道这件事情，新的主节点诞生了。")]),s._v(" "),a("h4",{attrs:{id:"redis-cluster的主从复制模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-cluster的主从复制模型"}},[s._v("#")]),s._v(" Redis Cluster的主从复制模型")]),s._v(" "),a("p",[s._v("Redis集群的架构就是多个主节点，每个主节点负责一部分槽位，每个主节点拥有几个从节点，一旦主节点挂掉，会挑选一个从节点成为新的主节点，负责这部分槽位。如果某个主节点和它的所有从节点都挂掉了，那么这部分槽位就不可用。")]),s._v(" "),a("h4",{attrs:{id:"redis-cluster一致性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-cluster一致性"}},[s._v("#")]),s._v(" Redis Cluster一致性")]),s._v(" "),a("p",[s._v("CAP理论认为C一致性，A可用性，P分区容错性，一般最多只能满足两个，也就是只能满足CA和CP，而Redis Cluster的主从复制的模式是异步复制的模式，也就是主节点执行修改命令后，返回结果给客户端后，有一个异步线程会一直从aof_buf缓冲区里面取命令发送给从节点，所以不是一种强一致性，只满足CAP理论中的CA。")]),s._v(" "),a("p",[s._v("参考链接：")]),s._v(" "),a("p",[s._v("http://www.redis.cn/topics/cluster-tutorial.html")]),s._v(" "),a("p",[s._v("https://blog.csdn.net/g6u8w7p06dco99fq3/article/details/105336857")])])}),[],!1,null,null,null);t.default=r.exports}}]);