(window.webpackJsonp=window.webpackJsonp||[]).push([[1279],{1671:function(v,_,t){"use strict";t.r(_);var a=t(13),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("涉及到数据更新：数据库和缓存更新，就容易出现缓存和数据库间的数据一致性问题：")]),v._v(" "),t("ol",[t("li",[v._v("如果先删了缓存，还没有来得及写MySQL，另一个线程就来读，发现缓存空，则去数据库读取数据写入缓存，此时缓存中为脏数据")]),v._v(" "),t("li",[v._v("如果先写库，在删除缓存前，写库线程挂掉，没有删掉缓存")])]),v._v(" "),t("p",[v._v("由于并发读写，没法保证顺序，就会出现缓存和数据库的数据不一致。")]),v._v(" "),t("p",[v._v("如何解决？这里给出两个解决方案，先易后难，结合业务和技术代价选择使用。")]),v._v(" "),t("h1",{attrs:{id:"延时双删策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#延时双删策略"}},[v._v("#")]),v._v(" 延时双删策略")]),v._v(" "),t("p",[v._v("写DB前后都执行"),t("code",[v._v("redis.del(key)")]),v._v("，并设定合理超时时间。")]),v._v(" "),t("h2",{attrs:{id:"执行流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行流程"}},[v._v("#")]),v._v(" 执行流程")]),v._v(" "),t("ol",[t("li",[v._v("先删除缓存")]),v._v(" "),t("li",[v._v("再写数据库")]),v._v(" "),t("li",[v._v("休眠xx毫秒（根据具体业务时间）")]),v._v(" "),t("li",[v._v("再次删除缓存")])]),v._v(" "),t("p",[v._v("xx毫秒怎么确定？")]),v._v(" "),t("p",[v._v("需要评估项目读数据业务逻辑耗时,以确保读请求结束，写请求可删除读请求造成的缓存脏数据。")]),v._v(" "),t("p",[v._v("该策略还要考虑 redis 和数据库主从同步的耗时。最后的写数据的休眠时间：则在读数据业务逻辑的耗时的基础上，加上几百ms即可。比如：休眠1秒。")]),v._v(" "),t("h1",{attrs:{id:"设置缓存过期时间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设置缓存过期时间"}},[v._v("#")]),v._v(" 设置缓存过期时间")]),v._v(" "),t("p",[v._v("理论上，设置缓存过期时间，是保证最终一致性的解决方案。\n所有的写操作以DB为准，只要到达缓存过期时间，则后面的读请求自然会从DB读取新值，然后回填缓存。")]),v._v(" "),t("p",[v._v("结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加写请求耗时。")]),v._v(" "),t("h1",{attrs:{id:"写完数据库后-再次删除缓存成功保证"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写完数据库后-再次删除缓存成功保证"}},[v._v("#")]),v._v(" 写完数据库后，再次删除缓存成功保证")]),v._v(" "),t("p",[v._v("上述的方案有一个缺点，那就是操作完数据库后，由于种种原因删除缓存失败，这时，可能就会出现数据不一致的情况。\n需提供保障重试方案。")]),v._v(" "),t("h2",{attrs:{id:"方案一"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方案一"}},[v._v("#")]),v._v(" 方案一")]),v._v(" "),t("h3",{attrs:{id:"具体流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#具体流程"}},[v._v("#")]),v._v(" 具体流程")]),v._v(" "),t("ol",[t("li",[v._v("更新数据库数据")]),v._v(" "),t("li",[v._v("缓存因为种种问题删除失败")]),v._v(" "),t("li",[v._v("将需要删除的key发送至消息队列")]),v._v(" "),t("li",[v._v("自己消费消息，获得需要删除的key")]),v._v(" "),t("li",[v._v("继续重试删除操作，直到成功")])]),v._v(" "),t("p",[v._v("然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二。\n在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。")]),v._v(" "),t("h2",{attrs:{id:"方案二"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方案二"}},[v._v("#")]),v._v(" 方案二")]),v._v(" "),t("h3",{attrs:{id:"具体流程-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#具体流程-2"}},[v._v("#")]),v._v(" 具体流程")]),v._v(" "),t("ol",[t("li",[v._v("更新数据库数据")]),v._v(" "),t("li",[v._v("数据库会将操作信息写入binlog日志当中")]),v._v(" "),t("li",[v._v("订阅程序提取出所需要的数据以及key")]),v._v(" "),t("li",[v._v("另起一段非业务代码，获得该信息")]),v._v(" "),t("li",[v._v("尝试删除缓存操作，发现删除失败")]),v._v(" "),t("li",[v._v("将这些信息发送至消息队列")]),v._v(" "),t("li",[v._v("重新从消息队列中获得该数据，重试操作。")])]),v._v(" "),t("p",[v._v("以上方案都是在业务中经常会碰到的场景，可以依据业务场景的复杂和对数据一致性的要求来选择具体的方案。")])])}),[],!1,null,null,null);_.default=s.exports}}]);