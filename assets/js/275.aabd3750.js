(window.webpackJsonp=window.webpackJsonp||[]).push([[275],{659:function(v,_,p){"use strict";p.r(_);var i=p(13),t=Object(i.a)({},(function(){var v=this,_=v.$createElement,p=v._self._c||_;return p("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[p("h1",{attrs:{id:"table-of-contents"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#table-of-contents"}},[v._v("#")]),v._v(" Table of Contents")]),v._v(" "),p("ul",[p("li",[p("a",{attrs:{href:"#%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E5%99%A8--%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF"}},[v._v("分布式ID生成器 | 架构师之路")])])]),v._v(" "),p("p",[v._v("本文内容参考网络，侵删")]),v._v(" "),p("p",[v._v("本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看")]),v._v(" "),p("blockquote",[p("p",[v._v("https://github.com/h2pl/Java-Tutorial")])]),v._v(" "),p("p",[v._v("喜欢的话麻烦点下Star哈")]),v._v(" "),p("p",[v._v("本文也将同步到我的个人博客：")]),v._v(" "),p("blockquote",[p("p",[v._v("www.how2playlife.com")])]),v._v(" "),p("p",[v._v("更多Java技术文章将陆续在微信公众号【Java技术江湖】更新，敬请关注。")]),v._v(" "),p("p",[v._v("该系列博文会告诉你什么是分布式系统，这对后端工程师来说是很重要的一门学问，我们会逐步了解常见的分布式技术、以及一些较为常见的分布式系统概念，同时也需要进一步了解zookeeper、分布式事务、分布式锁、负载均衡等技术，以便让你更完整地了解分布式技术的具体实战方法，为真正应用分布式技术做好准备。")]),v._v(" "),p("p",[v._v("如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。")]),v._v(" "),p("h2",{attrs:{id:"分布式id生成器-架构师之路"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#分布式id生成器-架构师之路"}},[v._v("#")]),v._v(" 分布式ID生成器 | 架构师之路")]),v._v(" "),p("p",[v._v("转自： 58沈剑 架构师之路 2017-06-25")]),v._v(" "),p("p",[p("strong",[v._v("一、需求缘起")])]),v._v(" "),p("p",[v._v("几乎所有的业务系统，都有生成一个唯一记录标识的需求，例如：")]),v._v(" "),p("ul",[p("li",[p("p",[v._v("消息标识：message-id")])]),v._v(" "),p("li",[p("p",[v._v("订单标识：order-id")])]),v._v(" "),p("li",[p("p",[v._v("帖子标识：tiezi-id")])])]),v._v(" "),p("p",[v._v("这个记录标识往往就是数据库中的"),p("strong",[v._v("主键")]),v._v("，数据库上会建立"),p("strong",[v._v("聚集索引")]),v._v("（cluster index），即在物理存储上以这个字段排序。")]),v._v(" "),p("p",[v._v("这个记录标识上的查询，往往又有分页或者排序的业务需求，例如：")]),v._v(" "),p("ul",[p("li",[p("p",[v._v("拉取最新的一页消息")]),v._v(" "),p("p",[v._v("select message-id/ order by time/ limit 100")])]),v._v(" "),p("li",[p("p",[v._v("拉取最新的一页订单")]),v._v(" "),p("p",[v._v("select order-id/ order by time/ limit 100")])]),v._v(" "),p("li",[p("p",[v._v("拉取最新的一页帖子")]),v._v(" "),p("p",[v._v("select tiezi-id/ order by time/ limit 100")])])]),v._v(" "),p("p",[v._v("所以往往要有一个time字段，并且在time字段上建立"),p("strong",[v._v("普通索引")]),v._v("（non-cluster index）。")]),v._v(" "),p("p",[v._v("普通索引存储的是实际记录的指针，其访问效率会比聚集索引慢，如果记录标识在生成时能够基本按照时间有序，则可以省去这个time字段的索引查询：")]),v._v(" "),p("p",[v._v("select message-id/ (order by message-id)/limit 100")]),v._v(" "),p("p",[v._v("强调，能这么做的前提是，message-id的生成基本是"),p("strong",[v._v("趋势时间递增的")]),v._v("。")]),v._v(" "),p("p",[v._v("这就引出了记录标识生成（也就是上文提到的三个XXX-id）的两大核心需求：")]),v._v(" "),p("ul",[p("li",[p("p",[v._v("全局唯一")])]),v._v(" "),p("li",[p("p",[v._v("趋势有序")])])]),v._v(" "),p("p",[v._v("这也是本文要讨论的核心问题："),p("strong",[v._v("如何高效生成趋势有序的全局唯一ID。")])]),v._v(" "),p("p",[p("strong",[v._v("二、常见方法、不足与优化")])]),v._v(" "),p("p",[p("strong",[v._v("方法一：使用数据库的 auto_increment 来生成全局唯一递增ID")])]),v._v(" "),p("p",[p("strong",[v._v("优点：")])]),v._v(" "),p("ul",[p("li",[p("p",[v._v("简单，使用数据库已有的功能")])]),v._v(" "),p("li",[p("p",[v._v("能够保证唯一性")])]),v._v(" "),p("li",[p("p",[v._v("能够保证递增性")])]),v._v(" "),p("li",[p("p",[v._v("步长固定")])])]),v._v(" "),p("p",[p("strong",[v._v("缺点：")])]),v._v(" "),p("ul",[p("li",[p("p",[v._v("可用性难以保证：数据库常见架构是一主多从+读写分离，生成自增ID是写请求，主库挂了就玩不转了")])]),v._v(" "),p("li",[p("p",[v._v("扩展性差，性能有上限：因为写入是单点，数据库主库的写性能决定ID的生成性能上限，并且难以扩展")])])]),v._v(" "),p("p",[p("strong",[v._v("改进方法：")])]),v._v(" "),p("ul",[p("li",[p("p",[v._v("冗余主库，避免写入单点")])]),v._v(" "),p("li",[p("p",[v._v("数据水平切分，保证各主库生成的ID不重复")])])]),v._v(" "),p("p",[p("img",{attrs:{src:"http://img.mp.itc.cn/upload/20170625/74f8cc978f9046e38e613d4d0d30698d.jpg",alt:""}})]),v._v(" "),p("p",[v._v("如上图所述，由1个写库变成3个写库，"),p("strong",[v._v("每个写库设置不同的auto_increment初始值，以及相同的增长步长")]),v._v("，以保证每个数据库生成的ID是不同的（上图中库0生成0,3,6,9…，库1生成1,4,7,10，库2生成2,5,8,11…）")]),v._v(" "),p("p",[v._v("改进后的架构保证了可用性，但"),p("strong",[v._v("缺点")]),v._v("是：")]),v._v(" "),p("ul",[p("li",[p("p",[v._v("丧失了ID生成的“绝对递增性”：先访问库0生成0,3，再访问库1生成1，可能导致在非常短的时间内，ID生成不是绝对递增的（这个问题不大，目标是趋势递增，不是绝对递增）")])]),v._v(" "),p("li",[p("p",[v._v("数据库的写压力依然很大，每次生成ID都要访问数据库")])])]),v._v(" "),p("p",[v._v("为了解决上述两个问题，引出了第二个常见的方案。")]),v._v(" "),p("p",[p("strong",[v._v("方法二：单点批量ID生成服务")])]),v._v(" "),p("p",[v._v("分布式系统之所以难，很重要的原因之一是“没有一个全局时钟，难以保证绝对的时序”，要想保证绝对的时序，还是只能使用单点服务，用本地时钟保证“绝对时序”。")]),v._v(" "),p("p",[v._v("数据库写压力大，是因为每次生成ID都访问了数据库，可以使用批量的方式降低数据库写压力。")]),v._v(" "),p("p",[p("img",{attrs:{src:"http://img.mp.itc.cn/upload/20170625/93ae092c4e8c4d3aa92a59afa81abb53.jpg",alt:""}})]),v._v(" "),p("p",[v._v("如上图所述，数据库使用双master保证可用性，数据库中只存储当前ID的最大值，例如0。")]),v._v(" "),p("p",[v._v("ID生成服务假设每次批量拉取6个ID，服务访问数据库，将当前ID的最大值修改为5，这样应用访问ID生成服务索要ID，ID生成服务不需要每次访问数据库，就能依次派发0,1,2,3,4,5这些ID了。")]),v._v(" "),p("p",[v._v("当ID发完后，再将ID的最大值修改为11，就能再次派发6,7,8,9,10,11这些ID了，于是数据库的压力就降低到原来的1/6。")]),v._v(" "),p("p",[p("strong",[v._v("优点")]),v._v("：")]),v._v(" "),p("ul",[p("li",[p("p",[v._v("保证了ID生成的绝对递增有序")])]),v._v(" "),p("li",[p("p",[v._v("大大的降低了数据库的压力，ID生成可以做到每秒生成几万几十万个")])])]),v._v(" "),p("p",[p("strong",[v._v("缺点")]),v._v("：")]),v._v(" "),p("ul",[p("li",[p("p",[v._v("服务仍然是单点")])]),v._v(" "),p("li",[p("p",[v._v("如果服务挂了，服务重启起来之后，继续生成ID可能会不连续，中间出现空洞（服务内存是保存着0,1,2,3,4,5，数据库中max-id是5，分配到3时，服务重启了，下次会从6开始分配，4和5就成了空洞，不过这个问题也不大）")])]),v._v(" "),p("li",[p("p",[v._v("虽然每秒可以生成几万几十万个ID，但毕竟还是有性能上限，无法进行水平扩展")])])]),v._v(" "),p("p",[p("strong",[v._v("改进方法")]),v._v("：")]),v._v(" "),p("p",[v._v("单点服务的常用高可用优化方案是“备用服务”，也叫“影子服务”，所以我们能用以下方法优化上述缺点（1）：")]),v._v(" "),p("p",[p("img",{attrs:{src:"http://img.mp.itc.cn/upload/20170625/449c222f7c344209af44df830479ddde.jpg",alt:""}})]),v._v(" "),p("p",[v._v("如上图，对外提供的服务是主服务，有一个影子服务时刻处于备用状态，当主服务挂了的时候影子服务顶上。")]),v._v(" "),p("p",[v._v("这个切换的过程对调用方是透明的，可以自动完成，常用的技术是vip+keepalived，具体就不在这里展开。")]),v._v(" "),p("p",[v._v("另外，ID-gen-service也可以实施水平扩展，以解决上述缺点（3），但会引发一致性问题，具体解决方案详见《》。")]),v._v(" "),p("p",[p("strong",[v._v("方法三：uuid/guid")])]),v._v(" "),p("p",[v._v("不管是通过数据库，还是通过服务来生成ID，业务方Application都需要进行一次远程调用，比较耗时。")]),v._v(" "),p("p",[v._v("有没有一种本地生成ID的方法，即高性能，又时延低呢？")]),v._v(" "),p("p",[v._v("uuid是一种常见的方案：")]),v._v(" "),p("p",[v._v("string ID =GenUUID();")]),v._v(" "),p("p",[p("strong",[v._v("优点")]),v._v("：")]),v._v(" "),p("ul",[p("li",[p("p",[v._v("本地生成ID，不需要进行远程调用，时延低")])]),v._v(" "),p("li",[p("p",[v._v("扩展性好，基本可以认为没有性能上限")])])]),v._v(" "),p("p",[p("strong",[v._v("缺点")]),v._v("：")]),v._v(" "),p("ul",[p("li",[p("p",[v._v("无法保证趋势递增")])]),v._v(" "),p("li",[p("p",[v._v("uuid过长，往往用字符串表示，作为主键建立索引查询效率低，常见优化方案为“转化为两个uint64整数存储”或者“折半存储”（折半后不能保证唯一性）")])])]),v._v(" "),p("p",[p("strong",[v._v("方法四：取当前毫秒数")])]),v._v(" "),p("p",[v._v("uuid是一个本地算法，生成性能高，但无法保证趋势递增，且作为字符串ID检索效率低，有没有一种能保证递增的本地算法呢？")]),v._v(" "),p("p",[v._v("取当前毫秒数是一种常见方案：")]),v._v(" "),p("p",[v._v("uint64 ID = GenTimeMS();")]),v._v(" "),p("p",[p("strong",[v._v("优点")]),v._v("：")]),v._v(" "),p("ul",[p("li",[p("p",[v._v("本地生成ID，不需要进行远程调用，时延低")])]),v._v(" "),p("li",[p("p",[v._v("生成的ID趋势递增")])]),v._v(" "),p("li",[p("p",[v._v("生成的ID是整数，建立索引后查询效率高")])])]),v._v(" "),p("p",[p("strong",[v._v("缺点")]),v._v("：")]),v._v(" "),p("ul",[p("li",[v._v("如果并发量超过1000，会生成重复的ID")])]),v._v(" "),p("p",[v._v("这个缺点要了命了，不能保证ID的唯一性。当然，使用微秒可以降低冲突概率，但每秒最多只能生成1000000个ID，再多的话就一定会冲突了，所以使用微秒并不从根本上解决问题。")]),v._v(" "),p("p",[p("strong",[v._v("方法五：类snowflake算法")])]),v._v(" "),p("p",[v._v("snowflake是twitter开源的分布式ID生成算法，其**核心思想为，**一个long型的ID：")]),v._v(" "),p("ul",[p("li",[p("p",[v._v("41bit作为毫秒数")])]),v._v(" "),p("li",[p("p",[v._v("10bit作为机器编号")])]),v._v(" "),p("li",[p("p",[v._v("12bit作为毫秒内序列号")])])]),v._v(" "),p("p",[v._v("算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。")]),v._v(" "),p("p",[v._v("借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现"),p("strong",[v._v("自己的分布式ID生成算法")]),v._v("。")]),v._v(" "),p("p",[v._v("举例，假设某公司ID生成器服务的需求如下：")]),v._v(" "),p("ul",[p("li",[p("p",[v._v("单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W")])]),v._v(" "),p("li",[p("p",[v._v("有2个机房，预计未来5年机房数量小于4个")])]),v._v(" "),p("li",[p("p",[v._v("每个机房机器数小于100台")])]),v._v(" "),p("li",[p("p",[v._v("目前有5个业务线有ID生成需求，预计未来业务线数量小于10个")])]),v._v(" "),p("li",[p("p",[v._v("…")])])]),v._v(" "),p("p",[v._v("分析过程如下：")]),v._v(" "),p("ul",[p("li",[p("p",[v._v("高位取从2017年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年"),p("em",[v._v("365天")]),v._v("24小时"),p("em",[v._v("3600秒")]),v._v("1000毫秒=320*10^9，差不多预留39bit给毫秒数")])]),v._v(" "),p("li",[p("p",[v._v("每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号")])]),v._v(" "),p("li",[p("p",[v._v("5年内机房数小于4个，预留2bit给机房标识")])]),v._v(" "),p("li",[p("p",[v._v("每个机房小于100台机器，预留7bit给每个机房内的服务器标识")])]),v._v(" "),p("li",[p("p",[v._v("业务线小于10个，预留4bit给业务线标识")])])]),v._v(" "),p("p",[v._v("这样设计的64bit标识，可以保证：")]),v._v(" "),p("ul",[p("li",[p("p",[v._v("每个业务线、每个机房、每个机器生成的ID都是不同的")])]),v._v(" "),p("li",[p("p",[v._v("同一个机器，每个毫秒内生成的ID都是不同的")])]),v._v(" "),p("li",[p("p",[v._v("同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的")])]),v._v(" "),p("li",[p("p",[v._v("将毫秒数放在最高位，保证生成的ID是趋势递增的")])])]),v._v(" "),p("p",[p("strong",[v._v("缺点")]),v._v("：")]),v._v(" "),p("ul",[p("li",[v._v("由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）")])])])}),[],!1,null,null,null);_.default=t.exports}}]);