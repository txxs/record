(window.webpackJsonp=window.webpackJsonp||[]).push([[1271],{1667:function(s,a,t){"use strict";t.r(a);var _=t(13),e=Object(_.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("blockquote",[t("p",[s._v("全是干货的技术号：\n本文已收录在github，欢迎 star/fork：\nhttps://github.com/Wasabi1234/Java-Interview-Tutorial")])]),s._v(" "),t("p",[s._v("Redis 对外提供数据访问服务时，使用的是常驻内存的数据。如果仅将数据存在内存，一旦宕机重启，数据全部丢失。")]),s._v(" "),t("h1",{attrs:{id:"_1-持久化概论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-持久化概论"}},[s._v("#")]),s._v(" 1 持久化概论")]),s._v(" "),t("h2",{attrs:{id:"_1-1-什么是持久化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-什么是持久化"}},[s._v("#")]),s._v(" 1.1 什么是持久化")]),s._v(" "),t("p",[s._v("redis所有数据保持在内存中，对数据的更新将异步地保存到磁盘上。持久化主要是做灾难恢复、数据恢复，可归类到高可用。")]),s._v(" "),t("p",[s._v("比如你的Redis宕机，你要做的事情是让Redis变得可用，尽快变得可用!")]),s._v(" "),t("p",[s._v("重启Redis，尽快让它对外提供服务，若你没做数据备份，即使Redis启动了，数据都没了!可用什么呢?")]),s._v(" "),t("p",[s._v("很可能说，大量的请求过来，缓存全部无法命中，在Redis里根本找不到数据，这个时候就造成缓存雪崩，就会去MySQL数据库去找，突然MySQL承接高并发，宕机!")]),s._v(" "),t("p",[s._v("MySQL宕机，你都没法去找数据恢复到Redis里面去，Redis的数据从哪儿来？就是从MySQL来的!")]),s._v(" "),t("p",[s._v("若你把Redis的持久化做好，备份和恢复方案也做到，那么即使你的Redis故障，也可通过备份数据，快速恢复，一旦恢复立即对外提供服务")]),s._v(" "),t("h2",{attrs:{id:"_1-2-持久化方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-持久化方式"}},[s._v("#")]),s._v(" 1.2 持久化方式")]),s._v(" "),t("p",[s._v("Redis提供了两种持久化方式：")]),s._v(" "),t("h3",{attrs:{id:"redis-rdb-快照"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-rdb-快照"}},[s._v("#")]),s._v(" Redis RDB - 快照")]),s._v(" "),t("p",[s._v("按指定时间间隔执行数据集的时间点快照，类似于MySQL Dump的 frm 文件。")]),s._v(" "),t("h3",{attrs:{id:"redis-aof-命令日志"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-aof-命令日志"}},[s._v("#")]),s._v(" Redis AOF - 命令日志")]),s._v(" "),t("p",[s._v("AOF 会记录服务器接收的每个写操作，这些操作将在服务器启动时再次执行，以重建原始数据集。使用与Redis协议本身相同的格式记录命令，并且仅采用"),t("code",[s._v("append-only")]),s._v("方式。当日志太大时，Redis可以在后台重写日志。类似于MySQL Binlog、Hbase HLog。在Redis重启时，通过回放日志中的写入指令来重构整个数据。")]),s._v(" "),t("blockquote",[t("p",[s._v("如果希望Redis仅作为纯内存的缓存来用，亦可禁用RDB和AOF。\n可以在同一实例中同时使用AOF和RDB。这种情况下，当Redis重新启动时，AOF文件将用于重建原始数据集，因为它可以保证是最完整的。")])]),s._v(" "),t("p",[s._v("最重要的是理解RDB与AOF持久性之间的不同权衡。如果同时使用RDB和AOF两种持久化机制，那么在Redis重启时，会使用AOF来重新构建数据，因为AOF中的数据更加完整!")]),s._v(" "),t("h1",{attrs:{id:"_2-rdb-全量写入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-rdb-全量写入"}},[s._v("#")]),s._v(" 2 RDB - 全量写入")]),s._v(" "),t("p",[s._v("Redis Server在有多db 中存储的K.V可理解为Redis的一个状态。当发生"),t("code",[s._v("写操作")]),s._v("时，Redis就会从一个状态切换到另外一个状态。\n基于全量的持久化就是在某个时刻，将Redis的所有数据持久化到硬盘中，形成一个快照。当Redis 重启时，通过加载最近一个快照数据，可以将 Redis 恢复至最近一次持久化状态上。")]),s._v(" "),t("h2",{attrs:{id:"_2-1-触发方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-触发方式"}},[s._v("#")]),s._v(" 2.1 触发方式")]),s._v(" "),t("h4",{attrs:{id:"save"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#save"}},[s._v("#")]),s._v(" save")]),s._v(" "),t("p",[s._v("save 可以由客户端显示触发，也可在redis shutdown 时触发。\nsave本身是"),t("code",[s._v("单线程串行")]),s._v("方式执行，因此当数据量大时，可能会发生Redis Server的长时间卡顿。但其备份期间不会有其他命令执行，因此备份时期 "),t("code",[s._v("数据的状态始终是一致性")]),s._v("的。")]),s._v(" "),t("p",[s._v("若存在老的RDB文件，则新的会替换老的，时间复杂度O(N)。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200903015740674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70#pic_center",alt:""}})]),s._v(" "),t("h4",{attrs:{id:"bgsave"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bgsave"}},[s._v("#")]),s._v(" bgsave")]),s._v(" "),t("p",[s._v("bgsave 也可由")]),s._v(" "),t("ul",[t("li",[s._v("客户端显式触发")]),s._v(" "),t("li",[s._v("配置定时任务触发")]),s._v(" "),t("li",[s._v("主从架构下由从节点触发")])]),s._v(" "),t("p",[s._v("bgsave命令在执行时，会"),t("code",[s._v("fork")]),s._v("一个子进程。子进程提交完成后，会立即给客户端返回响应，备份操作在后台异步执行，期间不会影响Redis的正常响应。")]),s._v(" "),t("p",[s._v("对于bgsave来说，当父进程Fork完子进程之后，异步任务会将"),t("code",[s._v("当前的内存状态作为一个版本进行复制")]),s._v("。在复制过程中产生的变更，不会反映在这次备份当中。")]),s._v(" "),t("h5",{attrs:{id:"不用命令-而使用配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不用命令-而使用配置"}},[s._v("#")]),s._v(" 不用命令，而使用配置")]),s._v(" "),t("p",[s._v("在Redis的默认配置中，当满足下面任一条件，会自动触发 bgsave 的执行：")]),s._v(" "),t("table",[t("thead",[t("tr",[t("th",[s._v("配置")]),s._v(" "),t("th",[s._v("seconds")]),s._v(" "),t("th",[s._v("changes")])])]),s._v(" "),t("tbody",[t("tr",[t("td",[s._v("save")]),s._v(" "),t("td",[s._v("900")]),s._v(" "),t("td",[s._v("1")])]),s._v(" "),t("tr",[t("td",[s._v("save")]),s._v(" "),t("td",[s._v("300")]),s._v(" "),t("td",[s._v("10")])]),s._v(" "),t("tr",[t("td",[s._v("save")]),s._v(" "),t("td",[s._v("60")]),s._v(" "),t("td",[s._v("10000")])])])]),s._v(" "),t("p",[s._v("​​​​​​bgsave相对于save的优势是"),t("code",[s._v("异步执行")]),s._v("，不影响后续命令执行。但Fork子进程，涉及父进程的内存复制，会增加服务器内存开销。"),t("code",[s._v("当内存开销高到使用虚拟内存时，bgsave的Fork子进程会阻塞运行")]),s._v("，可能会造成秒级不可用。因此使用bgsave需要保证服务器空闲内存足够。\n"),t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200903015209570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70#pic_center",alt:""}})]),s._v(" "),t("table",[t("thead",[t("tr",[t("th",[s._v("命令")]),s._v(" "),t("th",[s._v("save")]),s._v(" "),t("th",[s._v("bgsave")])])]),s._v(" "),t("tbody",[t("tr",[t("td",[s._v("IO类型")]),s._v(" "),t("td",[s._v("同步")]),s._v(" "),t("td",[s._v("异步")])]),s._v(" "),t("tr",[t("td",[s._v("是否阻塞")]),s._v(" "),t("td",[s._v("阻塞")]),s._v(" "),t("td",[s._v("非阻塞（在fork时阻塞）")])]),s._v(" "),t("tr",[t("td",[s._v("复杂度")]),s._v(" "),t("td",[s._v("O(N)")]),s._v(" "),t("td",[s._v("O(N)")])]),s._v(" "),t("tr",[t("td",[s._v("优点")]),s._v(" "),t("td",[s._v("不会消耗额外内存")]),s._v(" "),t("td",[s._v("不阻塞客户端命令")])]),s._v(" "),t("tr",[t("td",[s._v("缺点")]),s._v(" "),t("td",[s._v("阻塞客户端命令")]),s._v(" "),t("td",[s._v("需要fork子进程，内存开销大")])])])]),s._v(" "),t("h2",{attrs:{id:"rdb-最佳配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rdb-最佳配置"}},[s._v("#")]),s._v(" RDB 最佳配置")]),s._v(" "),t("p",[s._v("关闭自动RDB：")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("dbfilename dump-"),t("span",{pre:!0,attrs:{class:"token variable"}},[s._v("${port}")]),s._v(".rdb\n"),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("dir")]),s._v(" /redisDataPath\nstop-writes-on-bgsave-error "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\nrdbcompression "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\nrdbchecksum "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("h3",{attrs:{id:"需要注意的触发时机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#需要注意的触发时机"}},[s._v("#")]),s._v(" 需要注意的触发时机")]),s._v(" "),t("ul",[t("li",[s._v("主从复制时机的全量复制，master节点会执行bgsave")]),s._v(" "),t("li",[s._v("debug reload")]),s._v(" "),t("li",[s._v("shutdown")]),s._v(" "),t("li",[s._v("flushDB 、 flushAll")])]),s._v(" "),t("h2",{attrs:{id:"rdb性质"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rdb性质"}},[s._v("#")]),s._v(" RDB性质")]),s._v(" "),t("ol",[t("li",[s._v("RDB是Redis内存到硬盘的快照，用于持久化")]),s._v(" "),t("li",[s._v("save通常会阻塞Redis")]),s._v(" "),t("li",[s._v("bgsave不会阻塞Redis，但会fork新进程")]),s._v(" "),t("li",[s._v("save自动配置满足任一就会被执行")])]),s._v(" "),t("h2",{attrs:{id:"rdb-优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rdb-优点"}},[s._v("#")]),s._v(" RDB 优点")]),s._v(" "),t("ul",[t("li",[s._v("RDB会生成多个数据文件，每个文件都代表了某时刻Redis中的所有数据，这种方式非常适合做"),t("strong",[s._v("冷备")]),s._v("，可将这种完整数据文件发送到云服务器存储，比如ODPS分布式存储，以预定好的备份策略来定期备份Redis中的数据")]),s._v(" "),t("li",[s._v("RDB对Redis对外提供的读写服务，影响非常小，可让Redis保持高性能，因为Redis主进程只要fork一个子进程，让子进程执行RDB")]),s._v(" "),t("li",[s._v("相对于AOF，直接基于RDB文件重启和恢复Redis进程，更加快速")])]),s._v(" "),t("h3",{attrs:{id:"rdb缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rdb缺点"}},[s._v("#")]),s._v(" RDB缺点")]),s._v(" "),t("ul",[t("li",[s._v("耗时，O(n)")]),s._v(" "),t("li",[s._v("fork()：耗内存，copy-on-write策略\nRDB每次在fork子进程来执行RDB快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒")]),s._v(" "),t("li",[s._v("不可控，容易丢失数据\n一般RDB每隔5分钟，或者更长时间生成一次，若过程中Redis宕机，就会丢失最近未持久化的数据")])]),s._v(" "),t("h2",{attrs:{id:"_2-2-恢复流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-恢复流程"}},[s._v("#")]),s._v(" 2.2 恢复流程")]),s._v(" "),t("p",[s._v("当Redis重新启动时，会从本地磁盘加载之前持久化的文件。当恢复完成之后，再受理后续的请求操作。")]),s._v(" "),t("h1",{attrs:{id:"_3-aof-append-only-file-增量模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-aof-append-only-file-增量模式"}},[s._v("#")]),s._v(" 3 AOF（append only file）- 增量模式")]),s._v(" "),t("p",[s._v("RDB记录的是每个状态的全量数据，AOF记录的则是每条"),t("strong",[s._v("写命令的记录")]),s._v("，通过所有写命令的执行，最后恢复出最终的数据状态。\n"),t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190707123200343.png",alt:""}})]),s._v(" "),t("ul",[t("li",[s._v("其文件生成如下：\n"),t("img",{attrs:{src:"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80Njg1OTY4LTlmNDA3N2Y0YTAyMjk0NGIucG5n?x-oss-process=image/format,png",alt:""}})])]),s._v(" "),t("p",[s._v("但该模式默认是关闭的，需手动打开\n"),t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210206142749412.png",alt:""}})]),s._v(" "),t("h2",{attrs:{id:"_3-1-写入流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-写入流程"}},[s._v("#")]),s._v(" 3.1 写入流程")]),s._v(" "),t("h3",{attrs:{id:"aof的三种策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aof的三种策略"}},[s._v("#")]),s._v(" AOF的三种策略")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200903164454130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70#pic_center",alt:""}})]),s._v(" "),t("h4",{attrs:{id:"always"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#always"}},[s._v("#")]),s._v(" always")]),s._v(" "),t("ul",[t("li",[s._v("每次刷新缓冲区，都会同步触发同步操作。但因为每次写操作都会触发同步，所以该策略会大大降低Redis的吞吐量。当然了，该模式会拥有最高的容错性。\n"),t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200903212610656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70#pic_center",alt:""}})])]),s._v(" "),t("h4",{attrs:{id:"every-second"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#every-second"}},[s._v("#")]),s._v(" every second")]),s._v(" "),t("ul",[t("li",[s._v("每秒异步的触发同步操作。\n"),t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200903213251820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70#pic_center",alt:""}})])]),s._v(" "),t("h4",{attrs:{id:"no"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#no"}},[s._v("#")]),s._v(" no")]),s._v(" "),t("ul",[t("li",[s._v("由os决定何时同步，该方式下Redis无法决定何时落地，因此不可控。\n"),t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200903213521521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70#pic_center",alt:""}})])]),s._v(" "),t("h4",{attrs:{id:"对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对比"}},[s._v("#")]),s._v(" 对比")]),s._v(" "),t("table",[t("thead",[t("tr",[t("th",[s._v("命令")]),s._v(" "),t("th",[s._v("always")]),s._v(" "),t("th",[s._v("everysec")]),s._v(" "),t("th",[s._v("no")])])]),s._v(" "),t("tbody",[t("tr",[t("td",[s._v("优点")]),s._v(" "),t("td",[s._v("不丢数据")]),s._v(" "),t("td",[s._v("1 fsync/s，丢1s数据")]),s._v(" "),t("td",[s._v("默认，无需设置")])]),s._v(" "),t("tr",[t("td",[s._v("缺点")]),s._v(" "),t("td",[s._v("I/O开销大，一般的STAT盘只有几百TPS")]),s._v(" "),t("td",[s._v("丢1s数据")]),s._v(" "),t("td",[s._v("不可控")])])])]),s._v(" "),t("h2",{attrs:{id:"_3-2-回放流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-回放流程"}},[s._v("#")]),s._v(" 3.2 回放流程")]),s._v(" "),t("p",[s._v("AOF的回放时机也是在"),t("code",[s._v("机器启动时")]),s._v("，"),t("code",[s._v("一旦存在AOF，Redis就会选择增量回放")]),s._v("。")]),s._v(" "),t("p",[s._v("因为增量持久化是持续的写盘，相比于全量持久化，数据更加完整。回放过程就是将AOF中存放的命令，重新执行一遍。完成后再继续接收客户端新命令。")]),s._v(" "),t("h3",{attrs:{id:"aof模式的优化重写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aof模式的优化重写"}},[s._v("#")]),s._v(" AOF模式的优化重写")]),s._v(" "),t("p",[s._v("随着Redis 持续的运行，会有大量的增量数据append 到AOF 文件中。为了减小硬盘存储和加快恢复速度，Redis 通过rewrite 机制合并历史AOF 记录。如下所示：")]),s._v(" "),t("p",[s._v("原生 AOF")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" hello world\n"),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" hello java\n"),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" hello hehe\nincr counter\nincr counter\nrpush mylist a\nrpush mylist b\nrpush mylist c\n过期数据\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br")])]),t("p",[s._v("AOF 重写")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" hello hehe\n"),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" counter "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(" \nrpush mylist a b c\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("h3",{attrs:{id:"aof重写的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aof重写的作用"}},[s._v("#")]),s._v(" AOF重写的作用")]),s._v(" "),t("ul",[t("li",[s._v("减少硬盘占用量")]),s._v(" "),t("li",[s._v("加速恢复速度")])]),s._v(" "),t("h2",{attrs:{id:"_3-3-aof重写实现两种方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-aof重写实现两种方式"}},[s._v("#")]),s._v(" 3.3  AOF重写实现两种方式")]),s._v(" "),t("h3",{attrs:{id:"bgrewriteaof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bgrewriteaof"}},[s._v("#")]),s._v(" bgrewriteaof")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200903161134985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70#pic_center",alt:""}})]),s._v(" "),t("h3",{attrs:{id:"aof-重写配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aof-重写配置"}},[s._v("#")]),s._v(" AOF 重写配置")]),s._v(" "),t("h4",{attrs:{id:"配置项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#配置项"}},[s._v("#")]),s._v(" 配置项")]),s._v(" "),t("ul",[t("li",[s._v("AOF文件增长率 / AOF文件重写需要的大小\n"),t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200903153253226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70#pic_center",alt:""}})]),s._v(" "),t("li",[s._v("AOF当前尺寸（单位：字节）\n"),t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200903151629116.png#pic_center",alt:""}})]),s._v(" "),t("li",[t("code",[s._v("aof_base_size")]),s._v(" AOF 上次启动和重写的大小（单位：字节）")])]),s._v(" "),t("h4",{attrs:{id:"自动触发配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自动触发配置"}},[s._v("#")]),s._v(" 自动触发配置")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("aof_current_size "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" auto-aof-rewrite-min-size\naof_current_size - aof_base_size/aof_base_size "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" auto-aof-rewrite-percentage\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])]),t("h2",{attrs:{id:"_3-4-aof-重写流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-aof-重写流程"}},[s._v("#")]),s._v(" 3.4 AOF 重写流程")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200903150600480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmF2YUVkZ2U=,size_16,color_FFFFFF,t_70#pic_center",alt:""}})]),s._v(" "),t("h3",{attrs:{id:"aof-重写配置-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aof-重写配置-2"}},[s._v("#")]),s._v(" AOF 重写配置")]),s._v(" "),t("p",[s._v("修改配置文件")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("appendonly "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\nappendfilename "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"appendonly-'),t("span",{pre:!0,attrs:{class:"token variable"}},[t("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$(")]),s._v("port"),t("span",{pre:!0,attrs:{class:"token variable"}},[s._v(")")])]),s._v('.aof"')]),s._v("\nappendfsync everysec\n"),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("dir")]),s._v(" /opt/soft/redis/data\nauto-aof-rewrite-percentage "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("100")]),s._v("\nauto-aof-rewrite-min-size 64mb\nno-appendfsync-on-rewrite "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br")])]),t("h2",{attrs:{id:"aof的优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aof的优点"}},[s._v("#")]),s._v(" AOF的优点")]),s._v(" "),t("ul",[t("li",[s._v("更好避免数据丢失\n一般AOF每隔1s，通过子进程执行一次fsync，最多丢1s数据")]),s._v(" "),t("li",[t("code",[s._v("append-only")]),s._v("模式追加写\n所以没有任何磁盘寻址的开销，写入性能高，且文件不易破损，即使文件尾部破损，也易修复")]),s._v(" "),t("li",[s._v("日志文件即使过大，出现后台重写操作，也不会影响客户端的读写\n因为在rewrite log时，会压缩其中的指令，创建出一份需要恢复数据的最小日志。在创建新日志时，旧日志文件还是照常写入。当新的merge后的日志文件准备好时，再交换新旧日志文件即可!")]),s._v(" "),t("li",[s._v("命令通过非常可读的方式记录\n该特性非常适合做灾难性误删除操作的"),t("strong",[s._v("紧急恢复")]),s._v("。\n比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，可立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可通过恢复机制，自动恢复所有数据")])]),s._v(" "),t("h3",{attrs:{id:"_2-2-2-aof的缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-aof的缺点"}},[s._v("#")]),s._v(" 2.2.2 AOF的缺点")]),s._v(" "),t("ul",[t("li",[s._v("对于同一份数据，AOF日志一般比RDB快照更大")]),s._v(" "),t("li",[s._v("AOF开启后，写QPS会比RDB的低，因为AOF一般会配置成每s fsync一次日志文件，当然，每s一次fsync，性能也还是很高的")]),s._v(" "),t("li",[s._v("以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来\n类似AOF这种较为复杂的基于命令日志/merge/回放的方式，比基于RDB的每次持久化一份完整的数据快照方式相比更加脆弱一些，易产生bug\n不过AOF就是为了避免rewrite过程导致的bug，因此每次rewrite并不是基于旧的指令日志进行merge的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会更好")])]),s._v(" "),t("h1",{attrs:{id:"_4-选型及最佳实践"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-选型及最佳实践"}},[s._v("#")]),s._v(" 4 选型及最佳实践")]),s._v(" "),t("table",[t("thead",[t("tr",[t("th",[s._v("命令")]),s._v(" "),t("th",[s._v("RDB")]),s._v(" "),t("th",[s._v("AOF")])])]),s._v(" "),t("tbody",[t("tr",[t("td",[s._v("启动优先级")]),s._v(" "),t("td",[s._v("低")]),s._v(" "),t("td",[s._v("高")])]),s._v(" "),t("tr",[t("td",[s._v("体积")]),s._v(" "),t("td",[s._v("低")]),s._v(" "),t("td",[s._v("高")])]),s._v(" "),t("tr",[t("td",[s._v("恢复速度")]),s._v(" "),t("td",[s._v("快")]),s._v(" "),t("td",[s._v("慢")])]),s._v(" "),t("tr",[t("td",[s._v("数据安全性")]),s._v(" "),t("td",[s._v("丢数据")]),s._v(" "),t("td",[s._v("根据策略决定")])]),s._v(" "),t("tr",[t("td",[s._v("量级")]),s._v(" "),t("td",[s._v("重量级")]),s._v(" "),t("td",[s._v("轻量级")])])])]),s._v(" "),t("h2",{attrs:{id:"redis-4-0-对于持久化机制的优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-4-0-对于持久化机制的优化"}},[s._v("#")]),s._v(" Redis 4.0 对于持久化机制的优化")]),s._v(" "),t("p",[s._v("Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 "),t("code",[s._v("aof-use-rdb-preamble")]),s._v(" 开启）。")]),s._v(" "),t("p",[s._v("如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分就是压缩格式不再是 AOF 格式，可读性较差")]),s._v(" "),t("h2",{attrs:{id:"_4-1-rdb最佳策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-rdb最佳策略"}},[s._v("#")]),s._v(" 4.1 RDB最佳策略")]),s._v(" "),t("ul",[t("li",[s._v("关闭")]),s._v(" "),t("li",[s._v("集中手动管理RDB操作")]),s._v(" "),t("li",[s._v("在从节点打开自动执行配置，但是不宜频繁执行RDB")])]),s._v(" "),t("h2",{attrs:{id:"_4-2-aof最佳策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-aof最佳策略"}},[s._v("#")]),s._v(" 4.2 AOF最佳策略")]),s._v(" "),t("ul",[t("li",[s._v("建议打开，但是如果只是纯作为缓存使用可不开")]),s._v(" "),t("li",[s._v("AOF重写集中管理")]),s._v(" "),t("li",[s._v("everysec")])]),s._v(" "),t("h2",{attrs:{id:"_4-3-抉择rdb-aof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-抉择rdb-aof"}},[s._v("#")]),s._v(" 4.3 抉择RDB & AOF")]),s._v(" "),t("ol",[t("li",[s._v("不要仅使用RDB，因为那样会导致你丢失很多数据")]),s._v(" "),t("li",[s._v("也不要仅使用AOF，因为那样有两个问题\n"),t("ul",[t("li",[s._v("你通过AOF做冷备，没有RDB做冷备，来的恢复速度更快")]),s._v(" "),t("li",[s._v("RDB每次简单粗暴生成数据快照，更加健壮，可以避免AOF这种复杂的备份和恢复机制的bug")])])]),s._v(" "),t("li",[s._v("综合使用AOF和RDB\n"),t("ul",[t("li",[s._v("用AOF保证数据不丢失，作为数据恢复的第一选择")]),s._v(" "),t("li",[s._v("用RDB做不同程度的冷备，在AOF文件都丢失或损坏不可用时，还可使用RDB快速实现数据恢复")])])])]),s._v(" "),t("h2",{attrs:{id:"_4-4-一些最佳实践"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-一些最佳实践"}},[s._v("#")]),s._v(" 4.4 一些最佳实践")]),s._v(" "),t("ul",[t("li",[s._v("小分片\n例如设置maxmemory参数设置每个redis只存储4个G的空间，这样各种操作都不会太慢")]),s._v(" "),t("li",[s._v("监控(硬盘、内存、负载、网络)")]),s._v(" "),t("li",[s._v("足够的内存")])]),s._v(" "),t("p",[s._v("参考")]),s._v(" "),t("ul",[t("li",[s._v("https://redis.io/topics/persistence")]),s._v(" "),t("li",[s._v("《Redis设计与实现》")])])])}),[],!1,null,null,null);a.default=e.exports}}]);