(window.webpackJsonp=window.webpackJsonp||[]).push([[651],{1043:function(t,s,a){"use strict";a.r(s);var n=a(13),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"javadoc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javadoc"}},[t._v("#")]),t._v(" JavaDoc")]),t._v(" "),a("p",[t._v("Thrown to indicate that a thread has attempted to wait on an object's monitor or to notify other threads waiting on an object's monitor without owning the specified monitor.\n其实意思就是说,也就是当前的线程不是此对象监视器的所有者。也就是要在当前线程锁定对象，才能用锁定的对象此行这些方法，需要用到synchronized ，锁定什么对象就用什么对象来执行  notify(), notifyAll(),wait(), wait(long), wait(long, int)操作，否则就会报IllegalMonitorStateException")]),t._v(" "),a("p",[t._v("A thread becomes the owner of the object's monitor in one of three ways:\n1. By executing a synchronized instance method of that object.\n2. By executing the body of a synchronized statement that synchronizes on the object.\n3. For objects of type Class, by executing a synchronized static method of that class.\n通过以下三种方法之一，线程可以成为此对象监视器的所有者：")]),t._v(" "),a("ul",[a("li",[t._v("执行此对象的同步 (Sychronized) 实例方法")]),t._v(" "),a("li",[t._v("执行在此对象上进行同步的 synchronized 语句的正文")]),t._v(" "),a("li",[t._v("对于 Class 类型的对象，执行该类的同步静态方法")])]),t._v(" "),a("p",[t._v("也就是在说,就是需要在调用wait()或者notify()之前，必须使用synchronized语义绑定住被wait/notify的对象。")]),t._v(" "),a("h1",{attrs:{id:"解决方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方法"}},[t._v("#")]),t._v(" 解决方法:")]),t._v(" "),a("p",[t._v("通过实现加锁的方式实现线程同步时产生的并发问题")]),t._v(" "),a("h2",{attrs:{id:"_1-锁定方法所属的实例对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-锁定方法所属的实例对象"}},[t._v("#")]),t._v(" 1 锁定方法所属的实例对象")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public synchronized void method（）{\n    //然后就可以调用：this.notify()...\n    //或者直接调用notify()...\n}\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("h2",{attrs:{id:"_2-锁定方法所属的实例的class"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-锁定方法所属的实例的class"}},[t._v("#")]),t._v(" 2 锁定方法所属的实例的Class")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public Class Test{\n public static synchronized void method（）{\n    //然后调用：Test.class.notify()...\n }\n}\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("h2",{attrs:{id:"_3-锁定其他对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-锁定其他对象"}},[t._v("#")]),t._v(" 3 锁定其他对象")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public Class Test{\npublic Object lock = new Object();\n public static void method（）{\n    synchronized (lock) {\n     //需要调用 lock.notify();\n    } \n }\n}\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])]),a("h1",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("线程操作的wait()、notify()、notifyAll()只能在同步控制方法或同步控制块内调用\n如果在非同步控制方法或控制块里调用，程序能通过编译，但运行的时候，将得到  IllegalMonitorStateException 异常，并伴随着一些含糊信息，比如 ‘当前线程不是拥有者’。\n其实异常的含义是 调用wait()、notify()、notifyAll()的任务在调用这些方法前必须 ‘拥有’（获取）对象的锁。”")])])}),[],!1,null,null,null);s.default=e.exports}}]);