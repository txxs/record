(window.webpackJsonp=window.webpackJsonp||[]).push([[558],{947:function(a,s,t){"use strict";t.r(s);var e=t(13),n=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[a._v("#")]),a._v(" 目录")]),a._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%E8%81%8A%E8%81%8Aide%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"}},[a._v("聊聊IDE的实现原理")]),a._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%E6%BA%90%E4%BB%A3%E7%A0%81%E4%BF%9D%E5%AD%98"}},[a._v("源代码保存")])]),a._v(" "),t("li",[t("a",{attrs:{href:"#%E7%BC%96%E8%AF%91%E4%B8%BAclass%E6%96%87%E4%BB%B6"}},[a._v("编译为class文件")])]),a._v(" "),t("li",[t("a",{attrs:{href:"#%E6%9F%A5%E6%89%BEclass"}},[a._v("查找class")])]),a._v(" "),t("li",[t("a",{attrs:{href:"#%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B9%B6%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"}},[a._v("生成对象，并调用对象方法")])])])]),a._v(" "),t("li",[t("a",{attrs:{href:"#javac%E5%91%BD%E4%BB%A4%E5%88%9D%E7%AA%A5"}},[a._v("javac命令初窥")]),a._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#classpath%E6%98%AF%E4%BB%80%E4%B9%88"}},[a._v("classpath是什么")]),a._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#ide%E4%B8%AD%E7%9A%84classpath"}},[a._v("IDE中的classpath")])]),a._v(" "),t("li",[t("a",{attrs:{href:"#java%E9%A1%B9%E7%9B%AE%E5%92%8Cjava-web%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"}},[a._v("Java项目和Java web项目的本质区别")])])])]),a._v(" "),t("li",[t("a",{attrs:{href:"#javac%E5%91%BD%E4%BB%A4%E5%90%8E%E7%BC%80"}},[a._v("javac命令后缀")]),a._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#-g%E3%80%81-gnone%E3%80%81-g%7Blinesvarssource%7D"}},[a._v("-g、-g:none、-g:{lines,vars,source}")])]),a._v(" "),t("li",[t("a",{attrs:{href:"#-bootclasspath%E3%80%81-extdirs"}},[a._v("-bootclasspath、-extdirs")])]),a._v(" "),t("li",[t("a",{attrs:{href:"#-sourcepath%E5%92%8C-classpath%EF%BC%88-cp%EF%BC%89"}},[a._v("-sourcepath和-classpath（-cp）")])]),a._v(" "),t("li",[t("a",{attrs:{href:"#-d"}},[a._v("-d")])]),a._v(" "),t("li",[t("a",{attrs:{href:"#-implicit%7Bnoneclass%7D"}},[a._v("-implicit:{none,class}")])]),a._v(" "),t("li",[t("a",{attrs:{href:"#-source%E5%92%8C-target"}},[a._v("-source和-target")])]),a._v(" "),t("li",[t("a",{attrs:{href:"#-encoding"}},[a._v("-encoding")])]),a._v(" "),t("li",[t("a",{attrs:{href:"#-verbose"}},[a._v("-verbose")])]),a._v(" "),t("li",[t("a",{attrs:{href:"#%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4"}},[a._v("其他命令")])])])])])]),a._v(" "),t("li",[t("a",{attrs:{href:"#%E4%BD%BF%E7%94%A8javac%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE"}},[a._v("使用javac构建项目")]),a._v("\n* "),t("a",{attrs:{href:"#"}})]),a._v(" "),t("li",[t("a",{attrs:{href:"#java%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8%E7%9B%AE%E5%BD%95"}},[a._v("java文件列表目录")]),a._v("\n* "),t("a",{attrs:{href:"#%E6%94%BE%E5%85%A5%E5%88%97%E8%A1%A8%E6%96%87%E4%BB%B6%E4%B8%AD"}},[a._v("放入列表文件中")]),a._v("\n* "),t("a",{attrs:{href:"#%E7%94%9F%E6%88%90bin%E7%9B%AE%E5%BD%95"}},[a._v("生成bin目录")]),a._v("\n* "),t("a",{attrs:{href:"#%E5%88%97%E8%A1%A8"}},[a._v("列表")]),a._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%E9%80%9A%E8%BF%87-cp%E6%8C%87%E5%AE%9A%E6%89%80%E6%9C%89%E7%9A%84%E5%BC%95%E7%94%A8jar%E5%8C%85%EF%BC%8C%E5%B0%86src%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89java%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E7%BC%96%E8%AF%91"}},[a._v("通过-cp指定所有的引用jar包，将src下的所有java文件进行编译")])]),a._v(" "),t("li",[t("a",{attrs:{href:"#%E9%80%9A%E8%BF%87-cp%E6%8C%87%E5%AE%9A%E6%89%80%E6%9C%89%E7%9A%84%E5%BC%95%E7%94%A8jar%E5%8C%85%EF%BC%8C%E6%8C%87%E5%AE%9A%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C"}},[a._v("通过-cp指定所有的引用jar包，指定入口函数运行")])]),a._v(" "),t("li",[t("a",{attrs:{href:"#javap-%E7%9A%84%E4%BD%BF%E7%94%A8"}},[a._v("javap 的使用")])]),a._v(" "),t("li",[t("a",{attrs:{href:"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"}},[a._v("参考文章")])]),a._v(" "),t("li",[t("a",{attrs:{href:"#%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7"}},[a._v("微信公众号")]),a._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96"}},[a._v("Java技术江湖")])]),a._v(" "),t("li",[t("a",{attrs:{href:"#%E4%B8%AA%E4%BA%BA%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%BB%84%E5%B0%8F%E6%96%9C"}},[a._v("个人公众号：黄小斜")])])])])])])]),a._v(" "),t("hr"),a._v(" "),t("h2",{attrs:{id:"title-夯实java基础系列20-从ide的实现原理聊起-谈谈那些年我们用过的java命令date-2019-9-20-15-56-26-文章生成时间-一般不改categories-java技术江湖-java基础tags-java命令行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#title-夯实java基础系列20-从ide的实现原理聊起-谈谈那些年我们用过的java命令date-2019-9-20-15-56-26-文章生成时间-一般不改categories-java技术江湖-java基础tags-java命令行"}},[a._v("#")]),a._v(" title: 夯实Java基础系列20：从IDE的实现原理聊起，谈谈那些年我们用过的Java命令\ndate: 2019-9-20 15:56:26 # 文章生成时间，一般不改\ncategories:\n- Java技术江湖\n- Java基础\ntags:\n- Java命令行")]),a._v(" "),t("p",[a._v("本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看")]),a._v(" "),t("blockquote",[t("p",[a._v("https://github.com/h2pl/Java-Tutorial")])]),a._v(" "),t("p",[a._v("喜欢的话麻烦点下Star哈")]),a._v(" "),t("p",[a._v("文章首发于我的个人博客：")]),a._v(" "),t("blockquote",[t("p",[a._v("www.how2playlife.com")])]),a._v(" "),t("p",[a._v("本文是微信公众号【Java技术江湖】的《夯实Java基础系列博文》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。\n该系列博文会告诉你如何从入门到进阶，一步步地学习Java基础知识，并上手进行实战，接着了解每个Java知识点背后的实现原理，更完整地了解整个Java技术体系，形成自己的知识框架。为了更好地总结和检验你的学习成果，本系列文章也会提供每个知识点对应的面试题以及参考答案。")]),a._v(" "),t("p",[a._v("如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。")]),a._v(" "),t("h2",{attrs:{id:"聊聊ide的实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#聊聊ide的实现原理"}},[a._v("#")]),a._v(" 聊聊IDE的实现原理")]),a._v(" "),t("blockquote",[t("p",[a._v("IDE是把双刃剑，它可以什么都帮你做了，你只要敲几行代码，点几下鼠标，程序就跑起来了，用起来相当方便。")]),a._v(" "),t("p",[a._v("你不用去关心它后面做了些什么，执行了哪些命令，基于什么原理。然而也是这种过分的依赖往往让人散失了最基本的技能，当到了一个没有IDE的地方，你便觉得无从下手，给你个代码都不知道怎么去跑。好比给你瓶水，你不知道怎么打开去喝，然后活活给渴死。")]),a._v(" "),t("p",[a._v("之前用惯了idea，Java文件编译运行的命令基本忘得一干二净。")])]),a._v(" "),t("p",[a._v("那好，不如咱们先来了解一下IDE的实现原理，这样一来，即使离开IDE，我们还是知道如何运行Java程序了。")]),a._v(" "),t("p",[a._v("像Eclipse等java IDE是怎么编译和查找java源代码的呢？")]),a._v(" "),t("h3",{attrs:{id:"源代码保存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#源代码保存"}},[a._v("#")]),a._v(" 源代码保存")]),a._v(" "),t("p",[a._v("这个无需多说，在编译器写入代码，并保存到文件。这个利用流来实现。")]),a._v(" "),t("h3",{attrs:{id:"编译为class文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编译为class文件"}},[a._v("#")]),a._v(" 编译为class文件")]),a._v(" "),t("p",[a._v("java提供了JavaCompiler，我们可以通过它来编译java源文件为class文件。")]),a._v(" "),t("h3",{attrs:{id:"查找class"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查找class"}},[a._v("#")]),a._v(" 查找class")]),a._v(" "),t("p",[a._v("可以通过Class.forName(fullClassPath)或自定义类加载器来实现。")]),a._v(" "),t("h3",{attrs:{id:"生成对象-并调用对象方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#生成对象-并调用对象方法"}},[a._v("#")]),a._v(" 生成对象，并调用对象方法")]),a._v(" "),t("p",[a._v("通过上面一个查找class，得到Class对象后，可以通过newInstance()或构造器的newInstance()得到对象。然后得到Method，最后调用方法，传入相关参数即可。")]),a._v(" "),t("p",[a._v("示例代码：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('public class MyIDE {\n\n    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n        // 定义java代码，并保存到文件（Test.java）\n        StringBuilder sb = new StringBuilder();\n        sb.append("package com.tommy.core.test.reflect;\\n");\n        sb.append("public class Test {\\n");\n        sb.append("    private String name;\\n");\n        sb.append("    public Test(String name){\\n");\n        sb.append("        this.name = name;\\n");\n        sb.append("        System.out.println(\\"hello,my name is \\" + name);\\n");\n        sb.append("    }\\n");\n        sb.append("    public String sayHello(String name) {\\n");\n        sb.append("        return \\"hello,\\" + name;\\n");\n        sb.append("    }\\n");\n        sb.append("}\\n");\n\n        System.out.println(sb.toString());\n\n        String baseOutputDir = "F:\\\\output\\\\classes\\\\";\n        String baseDir = baseOutputDir + "com\\\\tommy\\\\core\\\\test\\\\reflect\\\\";\n        String targetJavaOutputPath = baseDir + "Test.java";\n        // 保存为java文件\n        FileWriter fileWriter = new FileWriter(targetJavaOutputPath);\n        fileWriter.write(sb.toString());\n        fileWriter.flush();\n        fileWriter.close();\n\n        // 编译为class文件\n        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n        StandardJavaFileManager manager = compiler.getStandardFileManager(null,null,null);\n        List<File> files = new ArrayList<>();\n        files.add(new File(targetJavaOutputPath));\n        Iterable compilationUnits = manager.getJavaFileObjectsFromFiles(files);\n\n        // 编译\n        // 设置编译选项，配置class文件输出路径\n        Iterable<String> options = Arrays.asList("-d",baseOutputDir);\n        JavaCompiler.CompilationTask task = compiler.getTask(null, manager, null, options, null, compilationUnits);\n        // 执行编译任务\n        task.call();\n')])])]),t("p",[a._v("​"),t("br"),a._v('\n​            // 通过反射得到对象\n​    //        Class clazz = Class.forName("com.tommy.core.test.reflect.Test");\n​            // 使用自定义的类加载器加载class\n​            Class clazz = new MyClassLoader(baseOutputDir).loadClass("com.tommy.core.test.reflect.Test");\n​            // 得到构造器\n​            Constructor constructor = clazz.getConstructor(String.class);\n​            // 通过构造器new一个对象\n​            Object test = constructor.newInstance("jack.tsing");\n​            // 得到sayHello方法\n​            Method method = clazz.getMethod("sayHello", String.class);\n​            // 调用sayHello方法\n​            String result = (String) method.invoke(test, "jack.ma");\n​            System.out.println(result);\n​        }\n​    }')]),a._v(" "),t("p",[a._v("自定义类加载器代码：")]),a._v(" "),t("p",[a._v("​"),t("br"),a._v('\n​    public class MyClassLoader extends ClassLoader {\n​        private String baseDir;\n​        public MyClassLoader(String baseDir) {\n​            this.baseDir = baseDir;\n​        }\n​        @Override\n​        protected Class<?> findClass(String name) throws ClassNotFoundException {\n​            String fullClassFilePath = this.baseDir + name.replace("\\.","/") + ".class";\n​            File classFilePath = new File(fullClassFilePath);\n​            if (classFilePath.exists()) {\n​                FileInputStream fileInputStream = null;\n​                ByteArrayOutputStream byteArrayOutputStream = null;\n​                try {\n​                    fileInputStream = new FileInputStream(classFilePath);\n​                    byte[] data = new byte[1024];\n​                    int len = -1;\n​                    byteArrayOutputStream = new ByteArrayOutputStream();\n​                    while ((len = fileInputStream.read(data)) != -1) {\n​                        byteArrayOutputStream.write(data,0,len);\n​                    }\n​'),t("br"),a._v("\nreturn defineClass(name,byteArrayOutputStream.toByteArray(),0,byteArrayOutputStream.size());\n} catch (FileNotFoundException e) {\ne.printStackTrace();\n} catch (IOException e) {\ne.printStackTrace();\n} finally {\nif (null != fileInputStream) {\ntry {\nfileInputStream.close();\n} catch (IOException e) {\ne.printStackTrace();\n}\n}")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("                if (null != byteArrayOutputStream) {\n                    try {\n                        byteArrayOutputStream.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n        return super.findClass(name);\n    }\n}    \n")])])]),t("h2",{attrs:{id:"javac命令初窥"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javac命令初窥"}},[a._v("#")]),a._v(" javac命令初窥")]),a._v(" "),t("p",[a._v("注：以下红色标记的参数在下文中有所讲解。")]),a._v(" "),t("p",[a._v("本部分参考https://www.cnblogs.com/xiazdong/p/3216220.html")]),a._v(" "),t("p",[a._v("用法: javac "),t("options",[t("source",{attrs:{files:""}})])],1),a._v(" "),t("p",[a._v("其中, 可能的选项包括:")]),a._v(" "),t("blockquote",[t("p",[a._v("-g                         生成所有调试信息")]),a._v(" "),t("p",[a._v("-g:none                    不生成任何调试信息")]),a._v(" "),t("p",[a._v("-g:{lines,vars,source}     只生成某些调试信息")]),a._v(" "),t("p",[a._v("-nowarn                    不生成任何警告")]),a._v(" "),t("p",[a._v("-verbose                   输出有关编译器正在执行的操作的消息")]),a._v(" "),t("p",[a._v("-deprecation               输出使用已过时的 API 的源位置")]),a._v(" "),t("p",[a._v("-classpath <路径>            指定查找用户类文件和注释处理程序的位置")]),a._v(" "),t("p",[a._v("-cp <路径>                   指定查找用户类文件和注释处理程序的位置")]),a._v(" "),t("p",[a._v("-sourcepath <路径>           指定查找输入源文件的位置")]),a._v(" "),t("p",[a._v("-bootclasspath <路径>        覆盖引导类文件的位置")]),a._v(" "),t("p",[a._v("-extdirs <目录>              覆盖所安装扩展的位置")]),a._v(" "),t("p",[a._v("-endorseddirs <目录>         覆盖签名的标准路径的位置")]),a._v(" "),t("p",[a._v("-proc:{none,only}          控制是否执行注释处理和/或编译。")]),a._v(" "),t("p",[a._v("-processor "),t("class1",[a._v("[,"),t("class2",[a._v(","),t("class3",[a._v("...] 要运行的注释处理程序的名称; 绕过默认的搜索进程")])],1)],1)],1),a._v(" "),t("p",[a._v("-processorpath <路径>        指定查找注释处理程序的位置")]),a._v(" "),t("p",[a._v("-d <目录>                    指定放置生成的类文件的位置")]),a._v(" "),t("p",[a._v("-s <目录>                    指定放置生成的源文件的位置")]),a._v(" "),t("p",[a._v("-implicit:{none,class}     指定是否为隐式引用文件生成类文件")]),a._v(" "),t("p",[a._v("-encoding <编码>             指定源文件使用的字符编码")]),a._v(" "),t("p",[a._v("-source <发行版>              提供与指定发行版的源兼容性")]),a._v(" "),t("p",[a._v("-target <发行版>              生成特定 VM 版本的类文件")]),a._v(" "),t("p",[a._v("-version                   版本信息")]),a._v(" "),t("p",[a._v("-help                      输出标准选项的提要")]),a._v(" "),t("p",[a._v("-A关键字[=值]                  传递给注释处理程序的选项")]),a._v(" "),t("p",[a._v("-X                         输出非标准选项的提要")]),a._v(" "),t("p",[a._v("-J<标记>                     直接将 <标记> 传递给运行时系统")]),a._v(" "),t("p",[a._v("-Werror                    出现警告时终止编译")]),a._v(" "),t("p",[a._v("@<文件名>                     从文件读取选项和文件名")])]),a._v(" "),t("p",[a._v("在详细介绍javac命令之前，先看看这个classpath是什么")]),a._v(" "),t("h3",{attrs:{id:"classpath是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#classpath是什么"}},[a._v("#")]),a._v(" classpath是什么")]),a._v(" "),t("p",[a._v("在dos下编译java程序，就要用到classpath这个概念，尤其是在没有设置环境变量的时候。classpath就是存放.class等编译后文件的路径。")]),a._v(" "),t("p",[a._v("javac：如果当前你要编译的java文件中引用了其它的类(比如说：继承)，但该引用类的.class文件不在当前目录下，这种情况下就需要在javac命令后面加上-classpath参数，通过使用以下三种类型的方法 来指导编译器在编译的时候去指定的路径下查找引用类。")]),a._v(" "),t("blockquote",[t("p",[a._v("(1).绝对路径：javac -classpath c:/junit3.8.1/junit.jar   Xxx.java")]),a._v(" "),t("p",[a._v("(2).相对路径：javac -classpath ../junit3.8.1/Junit.javr  Xxx.java")]),a._v(" "),t("p",[a._v("(3).系统变量：javac -classpath %CLASSPATH% Xxx.java (注意：%CLASSPATH%表示使用系统变量CLASSPATH的值进行查找，这里假设Junit.jar的路径就包含在CLASSPATH系统变量中)")])]),a._v(" "),t("h4",{attrs:{id:"ide中的classpath"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ide中的classpath"}},[a._v("#")]),a._v(" IDE中的classpath")]),a._v(" "),t("p",[a._v("对于一个普通的Javaweb项目，一般有这样的配置：")]),a._v(" "),t("blockquote",[t("p",[a._v("1 WEB-INF/classes,lib才是classpath，WEB-INF/ 是资源目录, 客户端不能直接访问。")]),a._v(" "),t("p",[a._v("2、WEB-INF/classes目录存放src目录java文件编译之后的class文件，xml、properties等资源配置文件，这是一个定位资源的入口。")]),a._v(" "),t("p",[a._v("3、引用classpath路径下的文件，只需在文件名前加classpath:")]),a._v(" "),t("param-value",[a._v("classpath:applicationContext-*.xml")]),a._v(" "),t("param-value",[a._v("classpath:context/conf/controller.xml")]),a._v(" "),t("p",[a._v("4、lib和classes同属classpath，两者的访问优先级为: lib>classes。")]),a._v(" "),t("p",[a._v("5、classpath 和 classpath* 区别：")]),a._v(" "),t("p",[a._v("classpath：只会到你的class路径中查找找文件;\nclasspath*：不仅包含class路径，还包括jar文件中(class路径)进行查找。")])],1),a._v(" "),t("p",[a._v("总结：")]),a._v(" "),t("p",[a._v("(1).何时需要使用-classpath：当你要编译或执行的类引用了其它的类，但被引用类的.class文件不在当前目录下时，就需要通过-classpath来引入类")]),a._v(" "),t("p",[a._v("(2).何时需要指定路径：当你要编译的类所在的目录和你执行javac命令的目录不是同一个目录时，就需要指定源文件的路径(CLASSPATH是用来指定.class路径的，不是用来指定.java文件的路径的)")]),a._v(" "),t("h4",{attrs:{id:"java项目和java-web项目的本质区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java项目和java-web项目的本质区别"}},[a._v("#")]),a._v(" Java项目和Java web项目的本质区别")]),a._v(" "),t("p",[a._v("（看清IDE及classpath本质）")]),a._v(" "),t("blockquote",[t("p",[a._v("现在只是说说Java Project和Web Project，那么二者有区别么？回答：没有！都是Java语言的应用，只是应用场合不同罢了，那么他们的本质到底是什么？")])]),a._v(" "),t("blockquote",[t("p",[a._v("回答：编译后路径！虚拟机执行的是class文件而不是java文件，那么我们不管是何种项目都是写的java文件，怎么就不一样了呢？分成java和web两种了呢？")])]),a._v(" "),t("blockquote",[t("p",[a._v("从.classpath文件入手来看，这个文件在每个项目目录下都是存在的，很少有人打开看吧，那么我们就来一起看吧。这是一个XML文件，使用文本编辑器打开即可。")]),a._v(" "),t("p",[a._v("这里展示一个web项目的.classpath")])]),a._v(" "),t("p",[a._v("Xml代码")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('<?xml version="1.0" encoding="UTF-8"?>\n<classpath>\n<classpathentry kind="src" path="src"/>\n<classpathentry kind="src" path="resources"/>\n<classpathentry kind="src" path="test"/>\n<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>\n<classpathentry kind="lib" path="lib/servlet-api.jar"/>\n<classpathentry kind="lib" path="webapp/WEB-INF/lib/struts2-core-2.1.8.1.jar"/>\n     ……\n<classpathentry kind="output" path="webapp/WEB-INF/classes"/>\n</classpath>\n')])])]),t("blockquote",[t("p",[a._v("XML文档包含一个根元素，就是classpath，类路径，那么这里面包含了什么信息呢？子元素是classpathentry，kind属性区别了种 类信息，src源码，con你看看后面的path就知道是JRE容器的信息。lib是项目依赖的第三方类库，output是src编译后的位置。")])]),a._v(" "),t("blockquote",[t("p",[a._v("既然是web项目，那么就是WEB-INF/classes目录，可能用MyEclipse的同学会说他们那里是WebRoot或者是WebContext而不是webapp，有区别么？回答：完全没有！")])]),a._v(" "),t("blockquote",[t("p",[a._v("既然看到了编译路径的本来面目后，还区分什么java项目和web项目么？回答:不区分！普通的java 项目你这样写就行了："),t("classpathentry",{attrs:{kind:"output",path:"bin"}}),a._v("，看看Eclipse是不是这样生成的？这个问题解决了吧。")],1)]),a._v(" "),t("blockquote",[t("p",[a._v("再说说webapp目录命名的问题，这个无所谓啊，web项目是要发布到服务器上的对吧，那么服务器读取的是类文件和页面文件吧，它不管源文件，它也无法去理解源文件。那么webapp目录的命名有何关系呢？只要让服务器找到不就行了。")])]),a._v(" "),t("h3",{attrs:{id:"javac命令后缀"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javac命令后缀"}},[a._v("#")]),a._v(" javac命令后缀")]),a._v(" "),t("h4",{attrs:{id:"g、-g-none、-g-lines-vars-source"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#g、-g-none、-g-lines-vars-source"}},[a._v("#")]),a._v(" -g、-g:none、-g:{lines,vars,source}")]),a._v(" "),t("blockquote",[t("p",[a._v("•-g：在生成的class文件中包含所有调试信息（行号、变量、源文件）\n•-g:none ：在生成的class文件中不包含任何调试信息。")]),a._v(" "),t("p",[a._v("这个参数在javac编译中是看不到什么作用的，因为调试信息都在class文件中，而我们看不懂这个class文件。")]),a._v(" "),t("p",[a._v("为了看出这个参数的作用，我们在eclipse中进行实验。在eclipse中，我们经常做的事就是“debug”，而在debug的时候，我们会\n•加入“断点”，这个是靠-g:lines起作用，如果不记录行号，则不能加断点。\n•在“variables”窗口中查看当前的变量，如下图所示，这是靠-g:vars起作用，否则不能查看变量信息。\n•在多个文件之间来回调用，比如 A.java的main()方法中调用了B.java的fun()函数，而我想看看程序进入fun()后的状态，这是靠-g:source，如果没有这个参数，则不能查看B.java的源代码。")])]),a._v(" "),t("h4",{attrs:{id:"bootclasspath、-extdirs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bootclasspath、-extdirs"}},[a._v("#")]),a._v(" -bootclasspath、-extdirs")]),a._v(" "),t("blockquote",[t("p",[a._v("-bootclasspath和-extdirs 几乎不需要用的，因为他是用来改变 “引导类”和“扩展类”。\n•引导类(组成Java平台的类)：Java\\jdk1.7.0_25\\jre\\lib\\rt.jar等，用-bootclasspath设置。\n•扩展类：Java\\jdk1.7.0_25\\jre\\lib\\ext目录中的文件，用-extdirs设置。\n•用户自定义类：用-classpath设置。")]),a._v(" "),t("p",[a._v("我们用-verbose编译后出现的“类文件的搜索路径”，就是由上面三个路径组成，如下：")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("[类文件的搜索路径: C:\\Java\\jdk1.7.0_25\\jre\\lib\\resources.jar,C:\\Java\\jdk1.7.0_25\n\n\\jre\\lib\\rt.jar,C:\\Java\\jdk1.7.0_25\\jre\\lib\\sunrsasign.jar,C:\\Java\\jdk1.7.0_25\\j\n\nre\\lib\\jsse.jar,C:\\Java\\jdk1.7.0_25\\jre\\lib\\jce.jar,C:\\Java\\jdk1.7.0_25\\jre\\lib\\\n\ncharsets.jar,C:\\Java\\jdk1.7.0_25\\jre\\lib\\jfr.jar,C:\\Java\\jdk1.7.0_25\\jre\\classes\n\n,C:\\Java\\jdk1.7.0_25\\jre\\lib\\ext\\access-bridge-32.jar,C:\\Java\\jdk1.7.0_25\\jre\\li\n\nb\\ext\\dnsns.jar,C:\\Java\\jdk1.7.0_25\\jre\\lib\\ext\\jaccess.jar,C:\\Java\\jdk1.7.0_25\\\n\njre\\lib\\ext\\localedata.jar,C:\\Java\\jdk1.7.0_25\\jre\\lib\\ext\\sunec.jar,C:\\Java\\jdk\n\n1.7.0_25\\jre\\lib\\ext\\sunjce_provider.jar,C:\\Java\\jdk1.7.0_25\\jre\\lib\\ext\\sunmsca\n\npi.jar,C:\\Java\\jdk1.7.0_25\\jre\\lib\\ext\\sunpkcs11.jar,C:\\Java\\jdk1.7.0_25\\jre\\lib\n\\ext\\zipfs.jar,..\\bin]             \n")])])]),t("p",[a._v("如果利用 -bootclasspath 重新定义： javac -bootclasspath src Xxx.java，则会出现下面错误：")]),a._v(" "),t("p",[a._v("致命错误: 在类路径或引导类路径中找不到程序包 java.lang")]),a._v(" "),t("h4",{attrs:{id:"sourcepath和-classpath-cp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sourcepath和-classpath-cp"}},[a._v("#")]),a._v(" -sourcepath和-classpath（-cp）")]),a._v(" "),t("p",[a._v("•-classpath(-cp)指定你依赖的类的class文件的查找位置。在Linux中，用“:”分隔classpath，而在windows中，用“;”分隔。\n•-sourcepath指定你依赖的类的java文件的查找位置。")]),a._v(" "),t("p",[a._v("举个例子，")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("public class A\n{\n    public static void main(String[] args) {\n        B b = new B();\n        b.print();\n    }\n}\n")])])]),t("p",[a._v("​"),t("br"),a._v("\n​"),t("br"),a._v('\n​    public class B\n​    {\n​        public void print()\n​        {\n​            System.out.println("old");\n​        }\n​    }')]),a._v(" "),t("p",[a._v("目录结构如下：")]),a._v(" "),t("p",[a._v("sourcepath          //此处为当前目录")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("|-src\n　　　　|-com\n　　　　　　|- B.java\n　　　　|- A.java\n　　|-bin\n　　　　|- B.class               //是 B.java\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br")])]),t("p",[a._v("编译后的类文件")]),a._v(" "),t("p",[a._v("如果要编译 A.java，则必须要让编译器找到类B的位置，你可以指定B.class的位置，也可以是B.java的位置，也可以同时都存在。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("javac -classpath bin src/A.java                            //查找到B.class\n\njavac -sourcepath src/com src/A.java                   //查找到B.java\n\njavac -sourcepath src/com -classpath bin src/A.java    //同时查找到B.class和B.java\n")])])]),t("p",[a._v("如果同时找到了B.class和B.java，则：\n•如果B.class和B.java内容一致，则遵循B.class。\n•如果B.class和B.java内容不一致，则遵循B.java，并编译B.java。")]),a._v(" "),t("p",[a._v("以上规则可以通过 -verbose选项看出。")]),a._v(" "),t("h4",{attrs:{id:"d"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#d"}},[a._v("#")]),a._v(" -d")]),a._v(" "),t("p",[a._v("•d就是 destination，用于指定.class文件的生成目录，在eclipse中，源文件都在src中，编译的class文件都是在bin目录中。")]),a._v(" "),t("p",[a._v("这里我用来实现一下这个功能，假设项目名称为project，此目录为当前目录，且在src/com目录中有一个Main.java文件。‘")]),a._v(" "),t("p",[a._v("​"),t("br"),a._v('\n​    package com;\n​    public class Main\n​    {\n​        public static void main(String[] args) {\n​            System.out.println("Hello");\n​        }\n​    }')]),a._v(" "),t("p",[a._v("​"),t("br"),a._v("\n​"),t("br"),a._v("\n​    javac -d bin src/com/Main.java")]),a._v(" "),t("p",[a._v("上面的语句将Main.class生成在bin/com目录下。")]),a._v(" "),t("h4",{attrs:{id:"implicit-none-class"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#implicit-none-class"}},[a._v("#")]),a._v(" -implicit:{none,class}")]),a._v(" "),t("p",[a._v("•如果有文件为A.java（其中有类A），且在类A中使用了类B，类B在B.java中，则编译A.java时，默认会自动编译B.java，且生成B.class。\n•implicit:none：不自动生成隐式引用的类文件。\n•implicit:class（默认）：自动生成隐式引用的类文件。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("public class A\n{\n    public static void main(String[] args) {\n        B b = new B();\n    }\n}\n\npublic class B\n{\n}\n\n如果使用：\n")])])]),t("p",[a._v("​"),t("br"),a._v("\n​     javac -implicit:none A.java")]),a._v(" "),t("p",[a._v("则不会生成 B.class。")]),a._v(" "),t("h4",{attrs:{id:"source和-target"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#source和-target"}},[a._v("#")]),a._v(" -source和-target")]),a._v(" "),t("p",[a._v("•-source：使用指定版本的JDK编译，比如：-source 1.4表示用JDK1.4的标准编译，如果在源文件中使用了泛型，则用JDK1.4是不能编译通过的。\n•-target：指定生成的class文件要运行在哪个JVM版本，以后实际运行的JVM版本必须要高于这个指定的版本。")]),a._v(" "),t("p",[a._v("javac -source 1.4 Xxx.java")]),a._v(" "),t("p",[a._v("javac -target 1.4 Xxx.java")]),a._v(" "),t("h4",{attrs:{id:"encoding"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#encoding"}},[a._v("#")]),a._v(" -encoding")]),a._v(" "),t("p",[a._v("默认会使用系统环境的编码，比如我们一般用的中文windows就是GBK编码，所以直接javac时会用GBK编码，而Java文件一般要使用utf-8，如果用GBK就会出现乱码。")]),a._v(" "),t("p",[a._v("•指定源文件的编码格式，如果源文件是UTF-8编码的，而-encoding GBK，则源文件就变成了乱码（特别是有中文时）。")]),a._v(" "),t("p",[a._v("javac -encoding UTF-8 Xxx.java")]),a._v(" "),t("h4",{attrs:{id:"verbose"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#verbose"}},[a._v("#")]),a._v(" -verbose")]),a._v(" "),t("p",[a._v("输出详细的编译信息，包括：classpath、加载的类文件信息。")]),a._v(" "),t("p",[a._v("比如，我写了一个最简单的HelloWorld程序，在命令行中输入：")]),a._v(" "),t("p",[a._v("D:\\Java>javac -verbose -encoding UTF-8 HelloWorld01.java")]),a._v(" "),t("p",[a._v("输出：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("[语法分析开始时间 RegularFileObject[HelloWorld01.java]]\n[语法分析已完成, 用时 21 毫秒]\n[源文件的搜索路径: .,D:\\大三下\\编译原理\\cup\\java-cup-11a.jar,E:\\java\\jflex\\lib\\J           //-sourcepath\nFlex.jar]\n[类文件的搜索路径: C:\\Java\\jdk1.7.0_25\\jre\\lib\\resources.jar,C:\\Java\\jdk1.7.0_25      //-classpath、-bootclasspath、-extdirs\n省略............................................\n[正在加载ZipFileIndexFileObject[C:\\Java\\jdk1.7.0_25\\lib\\ct.sym(META-INF/sym/rt.j\nar/java/lang/Object.class)]]\n[正在加载ZipFileIndexFileObject[C:\\Java\\jdk1.7.0_25\\lib\\ct.sym(META-INF/sym/rt.j\nar/java/lang/String.class)]]\n[正在检查Demo]\n省略............................................\n[已写入RegularFileObject[Demo.class]]\n[共 447 毫秒]\n")])])]),t("p",[a._v('编写一个程序时，比如写了一句：System.out.println("hello")，实际上还需要加载：Object、PrintStream、String等类文件，而上面就显示了加载的全部类文件。')]),a._v(" "),t("h4",{attrs:{id:"其他命令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其他命令"}},[a._v("#")]),a._v(" 其他命令")]),a._v(" "),t("p",[a._v("-J <标记>\n•传递一些信息给 Java Launcher.")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("javac -J-Xms48m   Xxx.java          //set the startup memory to 48M.\n")])])]),t("p",[a._v("-@<文件名>")]),a._v(" "),t("blockquote",[t("p",[a._v("如果同时需要编译数量较多的源文件(比如1000个)，一个一个编译是不现实的（当然你可以直接 javac *.java ），比较好的方法是：将你想要编译的源文件名都写在一个文件中（比如sourcefiles.txt），其中每行写一个文件名，如下所示：")]),a._v(" "),t("p",[a._v("HelloWorld01.java\nHelloWorld02.java\nHelloWorld03.java")])]),a._v(" "),t("p",[a._v("则使用下面的命令：")]),a._v(" "),t("p",[a._v("javac @sourcefiles.txt")]),a._v(" "),t("p",[a._v("编译这三个源文件。")]),a._v(" "),t("h2",{attrs:{id:"使用javac构建项目"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用javac构建项目"}},[a._v("#")]),a._v(" 使用javac构建项目")]),a._v(" "),t("p",[a._v("这部分参考：\nhttps://blog.csdn.net/mingover/article/details/57083176")]),a._v(" "),t("p",[a._v("一个简单的javac编译")]),a._v(" "),t("p",[a._v("新建两个文件夹,src和 build\nsrc/com/yp/test/HelloWorld.java\nbuild/")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("├─build\n└─src\n    └─com\n        └─yp\n            └─test\n                    HelloWorld.java\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br")])]),t("p",[a._v("java文件非常简单")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('package com.yp.test;\npublic class HelloWorld {\n\n    public static void main(String[] args) {\n        System.out.println("helloWorld");\n    }\n}\n')])])]),t("p",[a._v("编译:\njavac src/com/yp/test/HelloWorld.java -d build")]),a._v(" "),t("p",[a._v("-d 表示编译到 build文件夹下")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("查看build文件夹\n├─build\n│  └─com\n│      └─yp\n│          └─test\n│                  HelloWorld.class\n│\n└─src\n    └─com\n        └─yp\n            └─test\n                    HelloWorld.java\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br")])]),t("p",[a._v("运行文件")]),a._v(" "),t("blockquote",[t("p",[a._v("E:\\codeplace\\n_learn\\java\\javacmd> java com/yp/test/HelloWorld.class\n错误: 找不到或无法加载主类 build.com.yp.test.HelloWorld.class")]),a._v(" "),t("p",[a._v("运行时要指定main\nE:\\codeplace\\n_learn\\java\\javacmd\\build> java com.yp.test.HelloWorld\nhelloWorld")])]),a._v(" "),t("p",[a._v("如果引用到多个其他的类，应该怎么做呢 ？")]),a._v(" "),t("blockquote",[t("p",[a._v("编译")]),a._v(" "),t("p",[a._v("E:\\codeplace\\n_learn\\java\\javacmd>javac src/com/yp/test/HelloWorld.java -sourcepath src -d build -g\n1\n-sourcepath 表示 从指定的源文件目录中找到需要的.java文件并进行编译。\n也可以用-cp指定编译好的class的路径\n运行,注意:运行在build目录下")]),a._v(" "),t("p",[a._v("E:\\codeplace\\n_learn\\java\\javacmd\\build>java com.yp.test.HelloWorld")])]),a._v(" "),t("p",[a._v("怎么打成jar包?")]),a._v(" "),t("blockquote",[t("p",[a._v("生成:\nE:\\codeplace\\n_learn\\java\\javacmd\\build>jar cvf h.jar *\n运行:\nE:\\codeplace\\n_learn\\java\\javacmd\\build>java h.jar\n错误: 找不到或无法加载主类 h.jar")])]),a._v(" "),t("blockquote",[t("p",[a._v("这个错误是没有指定main类，所以类似这样来指定:\nE:\\codeplace\\n_learn\\java\\javacmd\\build>java -cp h.jar com.yp.test.HelloWorld")])]),a._v(" "),t("p",[a._v("生成可以运行的jar包")]),a._v(" "),t("p",[a._v("需要指定jar包的应用程序入口点，用-e选项：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("E:\\codeplace\\n_learn\\java\\javacmd\\build> jar cvfe h.jar com.yp.test.HelloWorld *\n已添加清单\n正在添加: com/(输入 = 0) (输出 = 0)(存储了 0%)\n正在添加: com/yp/(输入 = 0) (输出 = 0)(存储了 0%)\n正在添加: com/yp/test/(输入 = 0) (输出 = 0)(存储了 0%)\n正在添加: com/yp/test/entity/(输入 = 0) (输出 = 0)(存储了 0%)\n正在添加: com/yp/test/entity/Cat.class(输入 = 545) (输出 = 319)(压缩了 41%)\n正在添加: com/yp/test/HelloWorld.class(输入 = 844) (输出 = 487)(压缩了 42%)\n")])])]),t("p",[a._v("直接运行")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("java -jar h.jar\n\n额外发现 \n指定了Main类后，jar包里面的 META-INF/MANIFEST.MF 是这样的， 比原来多了一行Main-Class….\nManifest-Version: 1.0\nCreated-By: 1.8.0 (Oracle Corporation)\nMain-Class: com.yp.test.HelloWorld\n")])])]),t("p",[a._v("如果类里有引用jar包呢?")]),a._v(" "),t("p",[a._v("先下一个jar包 这里直接下 log4j")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('* main函数改成\n\nimport com.yp.test.entity.Cat;\nimport org.apache.log4j.Logger;\n\npublic class HelloWorld {\n\n    static Logger log = Logger.getLogger(HelloWorld.class);\n\n    public static void main(String[] args) {\n        Cat c = new Cat("keyboard");\n        log.info("这是log4j");\n        System.out.println("hello," + c.getName());\n    }\n\n}\n')])])]),t("p",[a._v("现的文件是这样的")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("├─build\n├─lib\n│      log4j-1.2.17.jar\n│\n└─src\n    └─com\n        └─yp\n            └─test\n                │  HelloWorld.java\n                │\n                └─entity\n                        Cat.java\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br")])]),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('这个时候 javac命令要接上 -cp ./lib/*.jar\nE:\\codeplace\\n_learn\\java\\javacmd>javac -encoding "utf8" src/com/yp/test/HelloWorld.java -sourcepath src -d build -g -cp ./lib/*.jar\n\n\n运行要加上-cp, -cp 选项貌似会把工作目录给换了， 所以要加上 ;../build\nE:\\codeplace\\n_learn\\java\\javacmd\\build>java -cp ../lib/log4j-1.2.17.jar;../build com.yp.test.HelloWorld\n')])])]),t("p",[a._v("结果:")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("log4j:WARN No appenders could be found for logger(com.yp.test.HelloWorld).\nlog4j:WARN Please initialize the log4j system properly.\nlog4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.\nhello,keyboard\n")])])]),t("p",[a._v("由于没有 log4j的配置文件，所以提示上面的问题,往 build 里面加上 log4j.xml")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">\n<log4j:configuration xmlns:log4j=\'http://jakarta.apache.org/log4j/\'>\n    <appender name="stdout" class="org.apache.log4j.ConsoleAppender">\n        <layout class="org.apache.log4j.PatternLayout">\n            <param name="ConversionPattern" value="%d{ABSOLUTE} %-5p [%c{1}] %m%n" />\n        </layout>\n    </appender>\n\n    <root>\n        <level value="info" />\n        <appender-ref ref="stdout" />\n    </root>\n</log4j:configuration>\n')])])]),t("p",[a._v("再运行")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("E:\\codeplace\\n_learn\\java\\javacmd>java -cp lib/log4j-1.2.17.jar;build com.yp.tes t.HelloWorld\n15:19:57,359 INFO  [HelloWorld] 这是log4j\nhello,keyboard\n")])])]),t("p",[a._v("说明:\n这个log4j配置文件，习惯的做法是放在src目录下, 在编译过程中 copy到build中的,但根据ant的做法，不是用javac的，而是用来处理,我猜测javac是不能copy的，如果想在命令行直接 使用，应该是用cp命令主动去执行 copy操作")]),a._v(" "),t("p",[a._v("ok 一个简单的java 工程就运行完了\n但是  貌似有些繁琐,  需要手动键入 java文件 以及相应的jar包 很是麻烦,\nso 可以用 shell 来脚本来简化相关操作\nshell 文件整理如下:")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('#!/bin/bash  \necho "build start"  \n  \nJAR_PATH=libs  \nBIN_PATH=bin  \nSRC_PATH=src  \n  \n# java文件列表目录  \nSRC_FILE_LIST_PATH=src/sources.list  \n  \n#生所有的java文件列表 放入列表文件中 \nrm -f $SRC_PATH/sources  \nfind $SRC_PATH/ -name *.java > $SRC_FILE_LIST_PATH  \n  \n#删除旧的编译文件 生成bin目录  \nrm -rf $BIN_PATH/  \nmkdir $BIN_PATH/  \n  \n#生成依赖jar包 列表  \nfor file in  ${JAR_PATH}/*.jar;  \ndo  \njarfile=${jarfile}:${file}  \ndone  \necho "jarfile = "$jarfile  \n  \n#编译 通过-cp指定所有的引用jar包，将src下的所有java文件进行编译\njavac -d $BIN_PATH/ -cp $jarfile @$SRC_FILE_LIST_PATH  \n  \n#运行 通过-cp指定所有的引用jar包，指定入口函数运行\njava -cp $BIN_PATH$jarfile com.zuiapps.danmaku.server.Main  \n')])])]),t("blockquote",[t("p",[a._v("有一点需要注意的是,  javac -d $BIN_PATH/ -cp $jarfile @$SRC_FILE_LIST_PATH\n在要编译的文件很多时候，一个个敲命令会显得很长，也不方便修改，")])]),a._v(" "),t("blockquote",[t("p",[a._v("可以把要编译的源文件列在文件中，在文件名前加@，这样就可以对多个文件进行编译，")])]),a._v(" "),t("blockquote",[t("p",[a._v("以上就是吧java文件放到 $SRC_FILE_LIST_PATH 中去了")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("编译 :\n     1. 需要编译所有的java文件\n     2. 依赖的java 包都需要加入到 classpath 中去\n     3. 最后设置 编译后的 class 文件存放目录  即 -d bin/\n     4. java文件过多是可以使用  @$SRC_FILE_LIST_PATH 把他们放到一个文件中去\n运行:\n   1.需要吧 编译时设置的bin目录和 所有jar包加入到 classpath 中去\n")])])]),t("p",[a._v("​")]),a._v(" "),t("h2",{attrs:{id:"javap-的使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javap-的使用"}},[a._v("#")]),a._v(" javap 的使用")]),a._v(" "),t("blockquote",[t("p",[a._v("javap是jdk自带的一个工具，可以对代码反编译，也可以查看java编译器生成的字节码。")]),a._v(" "),t("p",[a._v("情况下，很少有人使用javap对class文件进行反编译，因为有很多成熟的反编译工具可以使用，比如jad。但是，javap还可以查看java编译器为我们生成的字节码。通过它，可以对照源代码和字节码，从而了解很多编译器内部的工作。")]),a._v(" "),t("p",[a._v("javap命令分解一个class文件，它根据options来决定到底输出什么。如果没有使用options,那么javap将会输出包，类里的protected和public域以及类里的所有方法。javap将会把它们输出在标准输出上。来看这个例子，先编译(javac)下面这个类。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('import java.awt.*;\nimport java.applet.*;\n \npublic class DocFooter extends Applet {\n        String date;\n        String email;\n \n        public void init() {\n                resize(500,100);\n                date = getParameter("LAST_UPDATED");\n                email = getParameter("EMAIL");\n        }\n}\n')])])]),t("p",[a._v("在命令行上键入javap DocFooter后，输出结果如下")]),a._v(" "),t("p",[a._v('Compiled from "DocFooter.java"')]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("public class DocFooter extends java.applet.Applet {\n  java.lang.String date;\n  java.lang.String email;\n  public DocFooter();\n  public void init();\n}\n")])])]),t("p",[a._v("如果加入了-c，即javap -c DocFooter，那么输出结果如下")]),a._v(" "),t("p",[a._v('Compiled from "DocFooter.java"')]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('public class DocFooter extends java.applet.Applet {\n  java.lang.String date;\n \n  java.lang.String email;\n \n  public DocFooter();\n    Code:\n       0: aload_0       \n       1: invokespecial #1                  // Method java/applet/Applet."<init>":()V\n       4: return       \n \n  public void init();\n    Code:\n       0: aload_0       \n       1: sipush        500\n       4: bipush        100\n       6: invokevirtual #2                  // Method resize:(II)V\n       9: aload_0       \n      10: aload_0       \n      11: ldc           #3                  // String LAST_UPDATED\n      13: invokevirtual #4                  // Method getParameter:(Ljava/lang/String;)Ljava/lang/String;\n      16: putfield      #5                  // Field date:Ljava/lang/String;\n      19: aload_0       \n      20: aload_0       \n      21: ldc           #6                  // String EMAIL\n      23: invokevirtual #4                  // Method getParameter:(Ljava/lang/String;)Ljava/lang/String;\n      26: putfield      #7                  // Field email:Ljava/lang/String;\n      29: return       \n\n}\n')])])]),t("p",[a._v("上面输出的内容就是字节码。")]),a._v(" "),t("p",[a._v("用法摘要")]),a._v(" "),t("p",[a._v("-help 帮助\n-l 输出行和变量的表\n-public 只输出public方法和域\n-protected 只输出public和protected类和成员\n-package 只输出包，public和protected类和成员，这是默认的\n-p -private 输出所有类和成员\n-s 输出内部类型签名\n-c 输出分解后的代码，例如，类中每一个方法内，包含java字节码的指令，\n-verbose 输出栈大小，方法参数的个数\n-constants 输出静态final常量\n总结")]),a._v(" "),t("p",[a._v("javap可以用于反编译和查看编译器编译后的字节码。平时一般用javap -c比较多，该命令用于列出每个方法所执行的JVM指令，并显示每个方法的字节码的实际作用。可以通过字节码和源代码的对比，深入分析java的编译原理，了解和解决各种Java原理级别的问题。")]),a._v(" "),t("h2",{attrs:{id:"参考文章"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[a._v("#")]),a._v(" 参考文章")]),a._v(" "),t("p",[a._v("https://blog.csdn.net/Anbernet/article/details/81449390\nhttps://www.cnblogs.com/luobiao320/p/7975442.html\nhttps://www.jianshu.com/p/f7330dbdc051\nhttps://www.jianshu.com/p/6a8997560b05\nhttps://blog.csdn.net/w372426096/article/details/81664431\nhttps://blog.csdn.net/qincidong/article/details/82492140")]),a._v(" "),t("h2",{attrs:{id:"微信公众号"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#微信公众号"}},[a._v("#")]),a._v(" 微信公众号")]),a._v(" "),t("h3",{attrs:{id:"java技术江湖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java技术江湖"}},[a._v("#")]),a._v(" Java技术江湖")]),a._v(" "),t("p",[a._v("如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，作者黄小斜，专注 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！")]),a._v(" "),t("p",[t("strong",[a._v("Java工程师必备学习资源:")]),a._v(" 一些Java工程师常用学习资源，关注公众号后，后台回复关键字 "),t("strong",[a._v("“Java”")]),a._v(" 即可免费无套路获取。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190805090108984.jpg",alt:"我的公众号"}})]),a._v(" "),t("h3",{attrs:{id:"个人公众号-黄小斜"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#个人公众号-黄小斜"}},[a._v("#")]),a._v(" 个人公众号：黄小斜")]),a._v(" "),t("p",[a._v("作者是 985 硕士，蚂蚁金服 JAVA 工程师，专注于 JAVA 后端技术栈：SpringBoot、MySQL、分布式、中间件、微服务，同时也懂点投资理财，偶尔讲点算法和计算机理论基础，坚持学习和写作，相信终身学习的力量！")]),a._v(" "),t("p",[t("strong",[a._v("程序员3T技术学习资源：")]),a._v(" 一些程序员学习技术的资源大礼包，关注公众号后，后台回复关键字 "),t("strong",[a._v("“资料”")]),a._v(" 即可免费无套路获取。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190829222750556.jpg",alt:""}})])])}),[],!1,null,null,null);s.default=n.exports}}]);