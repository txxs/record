(window.webpackJsonp=window.webpackJsonp||[]).push([[562],{954:function(n,a,s){"use strict";s.r(a);var e=s(13),t=Object(e.a)({},(function(){var n=this,a=n.$createElement,s=n._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h1",{attrs:{id:"目录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[n._v("#")]),n._v(" 目录")]),n._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#java-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"}},[n._v("Java 基本数据类型")]),n._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#java-%E7%9A%84%E4%B8%A4%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"}},[n._v("Java 的两大数据类型:")]),n._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"}},[n._v("内置数据类型")])]),n._v(" "),s("li",[s("a",{attrs:{href:"#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"}},[n._v("引用类型")])]),n._v(" "),s("li",[s("a",{attrs:{href:"#java-%E5%B8%B8%E9%87%8F"}},[n._v("Java 常量")])])])]),n._v(" "),s("li",[s("a",{attrs:{href:"#%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1%EF%BC%88%E8%AF%A6%E8%A7%A3%EF%BC%89"}},[n._v("自动拆箱和装箱（详解）")]),n._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#%E5%AE%9E%E7%8E%B0"}},[n._v("实现")])]),n._v(" "),s("li",[s("a",{attrs:{href:"#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%E4%B8%AD%E7%9A%84%E5%9D%91"}},[n._v("自动装箱与拆箱中的“坑”")])]),n._v(" "),s("li",[s("a",{attrs:{href:"#%E4%BA%86%E8%A7%A3%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%BC%93%E5%AD%98%EF%BC%88%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%89%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"}},[n._v("了解基本类型缓存（常量池）的最佳实践")])]),n._v(" "),s("li",[s("a",{attrs:{href:"#%E6%80%BB%E7%BB%93%EF%BC%9A"}},[n._v("总结：")])])])]),n._v(" "),s("li",[s("a",{attrs:{href:"#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"}},[n._v("基本数据类型的存储方式")]),n._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#%E5%AD%98%E5%9C%A8%E6%A0%88%E4%B8%AD"}},[n._v("存在栈中")])]),n._v(" "),s("li",[s("a",{attrs:{href:"#%E5%AD%98%E5%9C%A8%E5%A0%86%E9%87%8C"}},[n._v("存在堆里")])])])]),n._v(" "),s("li",[s("a",{attrs:{href:"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"}},[n._v("参考文章")])]),n._v(" "),s("li",[s("a",{attrs:{href:"#%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7"}},[n._v("微信公众号")]),n._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96"}},[n._v("Java技术江湖")])]),n._v(" "),s("li",[s("a",{attrs:{href:"#%E4%B8%AA%E4%BA%BA%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%BB%84%E5%B0%8F%E6%96%9C"}},[n._v("个人公众号：黄小斜")])])])])])])]),n._v(" "),s("p",[n._v("本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看")]),n._v(" "),s("blockquote",[s("p",[n._v("https://github.com/h2pl/Java-Tutorial")])]),n._v(" "),s("p",[n._v("喜欢的话麻烦点下Star哈")]),n._v(" "),s("p",[n._v("文章首发于我的个人博客：")]),n._v(" "),s("blockquote",[s("p",[n._v("www.how2playlife.com")])]),n._v(" "),s("p",[n._v("本文是微信公众号【Java技术江湖】的《夯实Java基础系列博文》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。\n该系列博文会告诉你如何从入门到进阶，一步步地学习Java基础知识，并上手进行实战，接着了解每个Java知识点背后的实现原理，更完整地了解整个Java技术体系，形成自己的知识框架。为了更好地总结和检验你的学习成果，本系列文章也会提供每个知识点对应的面试题以及参考答案。")]),n._v(" "),s("p",[n._v("如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。")]),n._v(" "),s("h1",{attrs:{id:"java-基本数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-基本数据类型"}},[n._v("#")]),n._v(" Java 基本数据类型")]),n._v(" "),s("p",[n._v("变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。")]),n._v(" "),s("p",[n._v("内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。")]),n._v(" "),s("p",[s("img",{attrs:{src:"https://www.runoob.com/wp-content/uploads/2013/12/memorypic1.jpg",alt:""}})]),n._v(" "),s("p",[n._v("因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。")]),n._v(" "),s("h2",{attrs:{id:"java-的两大数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-的两大数据类型"}},[n._v("#")]),n._v(" Java 的两大数据类型:")]),n._v(" "),s("ul",[s("li",[n._v("内置数据类型")]),n._v(" "),s("li",[n._v("引用数据类型")]),n._v(" "),s("li",[s("ul",[s("li",[s("ul",[s("li")])])])])]),n._v(" "),s("h3",{attrs:{id:"内置数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内置数据类型"}},[n._v("#")]),n._v(" 内置数据类型")]),n._v(" "),s("p",[n._v("Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。")]),n._v(" "),s("p",[s("strong",[n._v("byte：")])]),n._v(" "),s("ul",[s("li",[n._v("byte 数据类型是8位、有符号的，以二进制补码表示的整数；")]),n._v(" "),s("li",[n._v("最小值是 -128（-2^7）；")]),n._v(" "),s("li",[n._v("最大值是 127（2^7-1）；")]),n._v(" "),s("li",[n._v("默认值是 0；")]),n._v(" "),s("li",[n._v("byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；")]),n._v(" "),s("li",[n._v("例子：byte a = 100，byte b = -50。")])]),n._v(" "),s("p",[s("strong",[n._v("short：")])]),n._v(" "),s("ul",[s("li",[n._v("short 数据类型是 16 位、有符号的以二进制补码表示的整数")]),n._v(" "),s("li",[n._v("最小值是 -32768（-2^15）；")]),n._v(" "),s("li",[n._v("最大值是 32767（2^15 - 1）；")]),n._v(" "),s("li",[n._v("Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；")]),n._v(" "),s("li",[n._v("默认值是 0；")]),n._v(" "),s("li",[n._v("例子：short s = 1000，short r = -20000。")])]),n._v(" "),s("p",[s("strong",[n._v("int：")])]),n._v(" "),s("ul",[s("li",[n._v("int 数据类型是32位、有符号的以二进制补码表示的整数；")]),n._v(" "),s("li",[n._v("最小值是 -2,147,483,648（-2^31）；")]),n._v(" "),s("li",[n._v("最大值是 2,147,483,647（2^31 - 1）；")]),n._v(" "),s("li",[n._v("一般地整型变量默认为 int 类型；")]),n._v(" "),s("li",[n._v("默认值是 0 ；")]),n._v(" "),s("li",[n._v("例子：int a = 100000, int b = -200000。")])]),n._v(" "),s("p",[s("strong",[n._v("long：")])]),n._v(" "),s("ul",[s("li",[n._v("long 数据类型是 64 位、有符号的以二进制补码表示的整数；")]),n._v(" "),s("li",[n._v("最小值是 -9,223,372,036,854,775,808（-2^63）；")]),n._v(" "),s("li",[n._v("最大值是 9,223,372,036,854,775,807（2^63 -1）；")]),n._v(" "),s("li",[n._v("这种类型主要使用在需要比较大整数的系统上；")]),n._v(" "),s("li",[n._v("默认值是 0L；")]),n._v(" "),s("li",[n._v('例子： long a = 100000L，Long b = -200000L。\n"L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写。')])]),n._v(" "),s("p",[s("strong",[n._v("float：")])]),n._v(" "),s("ul",[s("li",[n._v("float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；")]),n._v(" "),s("li",[n._v("float 在储存大型浮点数组的时候可节省内存空间；")]),n._v(" "),s("li",[n._v("默认值是 0.0f；")]),n._v(" "),s("li",[n._v("浮点数不能用来表示精确的值，如货币；")]),n._v(" "),s("li",[n._v("例子：float f1 = 234.5f。")])]),n._v(" "),s("p",[s("strong",[n._v("double：")])]),n._v(" "),s("ul",[s("li",[n._v("double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；")]),n._v(" "),s("li",[n._v("浮点数的默认类型为double类型；")]),n._v(" "),s("li",[n._v("double类型同样不能表示精确的值，如货币；")]),n._v(" "),s("li",[n._v("默认值是 0.0d；")]),n._v(" "),s("li",[n._v("例子：double d1 = 123.4。")])]),n._v(" "),s("p",[s("strong",[n._v("boolean：")])]),n._v(" "),s("ul",[s("li",[n._v("boolean数据类型表示一位的信息；")]),n._v(" "),s("li",[n._v("只有两个取值：true 和 false；")]),n._v(" "),s("li",[n._v("这种类型只作为一种标志来记录 true/false 情况；")]),n._v(" "),s("li",[n._v("默认值是 false；")]),n._v(" "),s("li",[n._v("例子：boolean one = true。")])]),n._v(" "),s("p",[s("strong",[n._v("char：")])]),n._v(" "),s("ul",[s("li",[n._v("char类型是一个单一的 16 位 Unicode 字符；")]),n._v(" "),s("li",[n._v("最小值是 \\u0000（即为0）；")]),n._v(" "),s("li",[n._v("最大值是 \\uffff（即为65,535）；")]),n._v(" "),s("li",[n._v("char 数据类型可以储存任何字符；")]),n._v(" "),s("li",[n._v("例子：char letter = 'A';。")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("//8位\nbyte bx = Byte.MAX_VALUE;\nbyte bn = Byte.MIN_VALUE;\n//16位\nshort sx = Short.MAX_VALUE;\nshort sn = Short.MIN_VALUE;\n//32位\nint ix = Integer.MAX_VALUE;\nint in = Integer.MIN_VALUE;\n//64位\nlong lx = Long.MAX_VALUE;\nlong ln = Long.MIN_VALUE;\n//32位\nfloat fx = Float.MAX_VALUE;\nfloat fn = Float.MIN_VALUE;\n//64位\ndouble dx = Double.MAX_VALUE;\ndouble dn = Double.MIN_VALUE;\n//16位\nchar cx = Character.MAX_VALUE;\nchar cn = Character.MIN_VALUE;\n//1位\nboolean bt = Boolean.TRUE;\nboolean bf = Boolean.FALSE;\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br")])]),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("`127`\n`-128`\n`32767`\n`-32768`\n`2147483647`\n`-2147483648`\n`9223372036854775807`\n`-9223372036854775808`\n`3.4028235E38`\n`1.4E-45`\n`1.7976931348623157E308`\n`4.9E-324`\n`￿`\n\n`true`\n`false`\n")])])]),s("h3",{attrs:{id:"引用类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#引用类型"}},[n._v("#")]),n._v(" 引用类型")]),n._v(" "),s("ul",[s("li",[n._v("在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。")]),n._v(" "),s("li",[n._v("对象、数组都是引用数据类型。")]),n._v(" "),s("li",[n._v("所有引用类型的默认值都是null。")]),n._v(" "),s("li",[n._v("一个引用变量可以用来引用任何与之兼容的类型。")]),n._v(" "),s("li",[n._v('例子：Site site = new Site("Runoob")。')])]),n._v(" "),s("h3",{attrs:{id:"java-常量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-常量"}},[n._v("#")]),n._v(" Java 常量")]),n._v(" "),s("p",[n._v("常量在程序运行时是不能被修改的。")]),n._v(" "),s("p",[n._v("在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("final double PI = 3.1415927;\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br")])]),s("p",[n._v("虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。")]),n._v(" "),s("p",[n._v("字面量可以赋给任何内置类型的变量。例如：")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("byte a = 68;\nchar a = 'A'\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br")])]),s("h2",{attrs:{id:"自动拆箱和装箱-详解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自动拆箱和装箱-详解"}},[n._v("#")]),n._v(" 自动拆箱和装箱（详解）")]),n._v(" "),s("p",[n._v("Java 5增加了自动装箱与自动拆箱机制，方便基本类型与包装类型的相互转换操作。在Java 5之前，如果要将一个int型的值转换成对应的包装器类型Integer，必须显式的使用new创建一个新的Integer对象，或者调用静态方法Integer.valueOf()。")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("//在Java 5之前，只能这样做\nInteger value = new Integer(10);\n//或者这样做\nInteger value = Integer.valueOf(10);\n//直接赋值是错误的\n//Integer value = 10;`\n")])])]),s("p",[n._v("在Java 5中，可以直接将整型赋给Integer对象，由编译器来完成从int型到Integer类型的转换，这就叫自动装箱。")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("`//在Java 5中，直接赋值是合法的，由编译器来完成转换`\n`Integer value = 10;`\n`与此对应的，自动拆箱就是可以将包装类型转换为基本类型，具体的转换工作由编译器来完成。`\n`//在Java 5 中可以直接这么做`\n`Integer value = new Integer(10);`\n`int i = value;`\n")])])]),s("p",[n._v("自动装箱与自动拆箱为程序员提供了很大的方便，而在实际的应用中，自动装箱与拆箱也是使用最广泛的特性之一。自动装箱和自动拆箱其实是Java编译器提供的一颗语法糖（语法糖是指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通过可提高开发效率，增加代码可读性，增加代码的安全性）。")]),n._v(" "),s("h3",{attrs:{id:"实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[n._v("#")]),n._v(" 实现")]),n._v(" "),s("p",[n._v("在八种包装类型中，每一种包装类型都提供了两个方法：")]),n._v(" "),s("p",[n._v("静态方法valueOf(基本类型)：将给定的基本类型转换成对应的包装类型；")]),n._v(" "),s("p",[n._v("实例方法xxxValue()：将具体的包装类型对象转换成基本类型；\n下面我们以int和Integer为例，说明Java中自动装箱与自动拆箱的实现机制。看如下代码：")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("class Auto //code1\n{\n\tpublic static void main(String[] args) \n\t{\n\t\t//自动装箱\n\t\tInteger inte = 10;\n\t\t//自动拆箱\n\t\tint i = inte;\n\n\t//再double和Double来验证一下\n\tDouble doub = 12.40;\n\tdouble d = doub;\n\t\n    }\n\n}\n")])])]),s("p",[n._v("上面的代码先将int型转为Integer对象，再讲Integer对象转换为int型，毫无疑问，这是可以正确运行的。可是，这种转换是怎么进行的呢？使用反编译工具，将生成的Class文件在反编译为Java文件，让我们看看发生了什么：")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("class Auto//code2\n{\n  public static void main(String[] paramArrayOfString)\n  {\n    Integer localInteger = Integer.valueOf(10);\n")])])]),s("p",[n._v("​"),s("br"),n._v("\n​    int i = localInteger.intValue();")]),n._v(" "),s("p",[n._v("​"),s("br"),n._v("\n​"),s("br"),n._v("\n​    Double localDouble = Double.valueOf(12.4D);\n​    double d = localDouble.doubleValue();\n​"),s("br"),n._v("\n​      }\n​    }")]),n._v(" "),s("p",[n._v("我们可以看到经过javac编译之后，code1的代码被转换成了code2，实际运行时，虚拟机运行的就是code2的代码。也就是说，虚拟机根本不知道有自动拆箱和自动装箱这回事；在将Java源文件编译为class文件的过程中，javac编译器在自动装箱的时候，调用了Integer.valueOf()方法，在自动拆箱时，又调用了intValue()方法。我们可以看到，double和Double也是如此。\n实现总结：其实自动装箱和自动封箱是编译器为我们提供的一颗语法糖。在自动装箱时，编译器调用包装类型的valueOf()方法；在自动拆箱时，编译器调用了相应的xxxValue()方法。")]),n._v(" "),s("h3",{attrs:{id:"自动装箱与拆箱中的-坑"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自动装箱与拆箱中的-坑"}},[n._v("#")]),n._v(" 自动装箱与拆箱中的“坑”")]),n._v(" "),s("p",[n._v("在使用自动装箱与自动拆箱时，要注意一些陷阱，为了避免这些陷阱，我们有必要去看一下各种包装类型的源码。")]),n._v(" "),s("p",[n._v("Integer源码")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('public final class Integer extends Number implements Comparable<Integer> {\n\tprivate final int value;\n\t\n\n/*Integer的构造方法，接受一个整型参数,Integer对象表示的int值，保存在value中*/\n public Integer(int value) {\n        this.value = value;\n }\n \n/*equals()方法判断的是:所代表的int型的值是否相等*/\n public boolean equals(Object obj) {\n        if (obj instanceof Integer) {\n            return value == ((Integer)obj).intValue();\n        }\n        return false;\n}\n \n/*返回这个Integer对象代表的int值，也就是保存在value中的值*/\n public int intValue() {\n        return value;\n }\n \n /**\n  * 首先会判断i是否在[IntegerCache.low,Integer.high]之间\n  * 如果是，直接返回Integer.cache中相应的元素\n  * 否则，调用构造方法，创建一个新的Integer对象\n  */\n public static Integer valueOf(int i) {\n    assert IntegerCache.high >= 127;\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n }\n\n/**\n  * 静态内部类，缓存了从[low,high]对应的Integer对象\n  * low -128这个值不会被改变\n  * high 默认是127，可以改变，最大不超过：Integer.MAX_VALUE - (-low) -1\n  * cache 保存从[low,high]对象的Integer对象\n */\n private static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static final Integer cache[];\n \n    static {\n        // high value may be configured by property\n        int h = 127;\n        String integerCacheHighPropValue =\n            sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");\n        if (integerCacheHighPropValue != null) {\n            int i = parseInt(integerCacheHighPropValue);\n            i = Math.max(i, 127);\n            // Maximum array size is Integer.MAX_VALUE\n            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n        }\n        high = h;\n \n        cache = new Integer[(high - low) + 1];\n        int j = low;\n        for(int k = 0; k < cache.length; k++)\n            cache[k] = new Integer(j++);\n    }\n \n    private IntegerCache() {}\n}\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br"),s("span",{staticClass:"line-number"},[n._v("39")]),s("br"),s("span",{staticClass:"line-number"},[n._v("40")]),s("br"),s("span",{staticClass:"line-number"},[n._v("41")]),s("br"),s("span",{staticClass:"line-number"},[n._v("42")]),s("br"),s("span",{staticClass:"line-number"},[n._v("43")]),s("br"),s("span",{staticClass:"line-number"},[n._v("44")]),s("br"),s("span",{staticClass:"line-number"},[n._v("45")]),s("br"),s("span",{staticClass:"line-number"},[n._v("46")]),s("br"),s("span",{staticClass:"line-number"},[n._v("47")]),s("br"),s("span",{staticClass:"line-number"},[n._v("48")]),s("br"),s("span",{staticClass:"line-number"},[n._v("49")]),s("br"),s("span",{staticClass:"line-number"},[n._v("50")]),s("br"),s("span",{staticClass:"line-number"},[n._v("51")]),s("br"),s("span",{staticClass:"line-number"},[n._v("52")]),s("br"),s("span",{staticClass:"line-number"},[n._v("53")]),s("br"),s("span",{staticClass:"line-number"},[n._v("54")]),s("br"),s("span",{staticClass:"line-number"},[n._v("55")]),s("br"),s("span",{staticClass:"line-number"},[n._v("56")]),s("br"),s("span",{staticClass:"line-number"},[n._v("57")]),s("br"),s("span",{staticClass:"line-number"},[n._v("58")]),s("br"),s("span",{staticClass:"line-number"},[n._v("59")]),s("br"),s("span",{staticClass:"line-number"},[n._v("60")]),s("br"),s("span",{staticClass:"line-number"},[n._v("61")]),s("br"),s("span",{staticClass:"line-number"},[n._v("62")]),s("br"),s("span",{staticClass:"line-number"},[n._v("63")]),s("br"),s("span",{staticClass:"line-number"},[n._v("64")]),s("br"),s("span",{staticClass:"line-number"},[n._v("65")]),s("br"),s("span",{staticClass:"line-number"},[n._v("66")]),s("br")])]),s("p",[n._v("以上是Oracle(Sun)公司JDK 1.7中Integer源码的一部分，通过分析上面的代码，得到：")]),n._v(" "),s("p",[n._v("1）Integer有一个实例域value，它保存了这个Integer所代表的int型的值，且它是final的，也就是说这个Integer对象一经构造完成，它所代表的值就不能再被改变。")]),n._v(" "),s("p",[n._v("2）Integer重写了equals()方法，它通过比较两个Integer对象的value，来判断是否相等。")]),n._v(" "),s("p",[n._v("3）重点是静态内部类IntegerCache，通过类名就可以发现：它是用来缓存数据的。它有一个数组，里面保存的是连续的Integer对象。\n(a) low：代表缓存数据中最小的值，固定是-128。")]),n._v(" "),s("p",[n._v("(b) high：代表缓存数据中最大的值，它可以被该改变，默认是127。high最小是127，最大是Integer.MAX_VALUE-(-low)-1，如果high超过了这个值，那么cache[ ]的长度就超过Integer.MAX_VALUE了，也就溢出了。")]),n._v(" "),s("p",[n._v("(c) cache[]：里面保存着从[low,high]所对应的Integer对象，长度是high-low+1(因为有元素0，所以要加1)。")]),n._v(" "),s("p",[n._v("4）调用valueOf(inti)方法时，首先判断i是否在[low,high]之间，如果是，则复用Integer.cache[i-low]。比如，如果Integer.valueOf(3)，直接返回Integer.cache[131]；如果i不在这个范围，则调用构造方法，构造出一个新的Integer对象。")]),n._v(" "),s("p",[n._v("5）调用intValue()，直接返回value的值。\n通过3）和4）可以发现，默认情况下，在使用自动装箱时，VM会复用[-128,127]之间的Integer对象。")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("Integer  a1 = 1;\nInteger  a2 = 1;\nInteger  a3 = new Integer(1);\n//会打印true，因为a1和a2是同一个对象,都是Integer.cache[129]\nSystem.out.println(a1 == a2);\n//false，a3构造了一个新的对象，不同于a1,a2\nSystem.out.println(a1 == a3);\n")])])]),s("h3",{attrs:{id:"了解基本类型缓存-常量池-的最佳实践"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#了解基本类型缓存-常量池-的最佳实践"}},[n._v("#")]),n._v(" 了解基本类型缓存（常量池）的最佳实践")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('//基本数据类型的常量池是-128到127之间。\n// 在这个范围中的基本数据类的包装类可以自动拆箱，比较时直接比较数值大小。\npublic static void main(String[] args) {\n    //int的自动拆箱和装箱只在-128到127范围中进行，超过该范围的两个integer的 == 判断是会返回false的。\n    Integer a1 = 128;\n    Integer a2 = -128;\n    Integer a3 = -128;\n    Integer a4 = 128;\n    System.out.println(a1 == a4);\n    System.out.println(a2 == a3);\n\n    Byte b1 = 127;\n    Byte b2 = 127;\n    Byte b3 = -128;\n    Byte b4 = -128;\n    //byte都是相等的，因为范围就在-128到127之间\n    System.out.println(b1 == b2);\n    System.out.println(b3 == b4);\n\n    //\n    Long c1 = 128L;\n    Long c2 = 128L;\n    Long c3 = -128L;\n    Long c4 = -128L;\n    System.out.println(c1 == c2);\n    System.out.println(c3 == c4);\n\n    //char没有负值\n    //发现char也是在0到127之间自动拆箱\n    Character d1 = 128;\n    Character d2 = 128;\n    Character d3 = 127;\n    Character d4 = 127;\n    System.out.println(d1 == d2);\n    System.out.println(d3 == d4);\n\n\n    `结果`\n    \n    `false`\n    `true`\n    `true`\n    `true`\n    `false`\n    `true`\n    `false`\n    `true`\n    \n    \n\n    Integer i = 10;\n    Byte b = 10;\n    //比较Byte和Integer.两个对象无法直接比较，报错\n    //System.out.println(i == b);\n    System.out.println("i == b " + i.equals(b));\n    //答案是false,因为包装类的比较时先比较是否是同一个类，不是的话直接返回false.\n    int ii = 128;\n    short ss = 128;\n    long ll = 128;\n    char cc = 128;\n    System.out.println("ii == bb " + (ii == ss));\n    System.out.println("ii == ll " + (ii == ll));\n    System.out.println("ii == cc " + (ii == cc));\n    \n    结果\n    i == b false\n    ii == bb true\n    ii == ll true\n    ii == cc true\n    \n    //这时候都是true，因为基本数据类型直接比较值，值一样就可以。\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br"),s("span",{staticClass:"line-number"},[n._v("39")]),s("br"),s("span",{staticClass:"line-number"},[n._v("40")]),s("br"),s("span",{staticClass:"line-number"},[n._v("41")]),s("br"),s("span",{staticClass:"line-number"},[n._v("42")]),s("br"),s("span",{staticClass:"line-number"},[n._v("43")]),s("br"),s("span",{staticClass:"line-number"},[n._v("44")]),s("br"),s("span",{staticClass:"line-number"},[n._v("45")]),s("br"),s("span",{staticClass:"line-number"},[n._v("46")]),s("br"),s("span",{staticClass:"line-number"},[n._v("47")]),s("br"),s("span",{staticClass:"line-number"},[n._v("48")]),s("br"),s("span",{staticClass:"line-number"},[n._v("49")]),s("br"),s("span",{staticClass:"line-number"},[n._v("50")]),s("br"),s("span",{staticClass:"line-number"},[n._v("51")]),s("br"),s("span",{staticClass:"line-number"},[n._v("52")]),s("br"),s("span",{staticClass:"line-number"},[n._v("53")]),s("br"),s("span",{staticClass:"line-number"},[n._v("54")]),s("br"),s("span",{staticClass:"line-number"},[n._v("55")]),s("br"),s("span",{staticClass:"line-number"},[n._v("56")]),s("br"),s("span",{staticClass:"line-number"},[n._v("57")]),s("br"),s("span",{staticClass:"line-number"},[n._v("58")]),s("br"),s("span",{staticClass:"line-number"},[n._v("59")]),s("br"),s("span",{staticClass:"line-number"},[n._v("60")]),s("br"),s("span",{staticClass:"line-number"},[n._v("61")]),s("br"),s("span",{staticClass:"line-number"},[n._v("62")]),s("br"),s("span",{staticClass:"line-number"},[n._v("63")]),s("br"),s("span",{staticClass:"line-number"},[n._v("64")]),s("br"),s("span",{staticClass:"line-number"},[n._v("65")]),s("br"),s("span",{staticClass:"line-number"},[n._v("66")]),s("br"),s("span",{staticClass:"line-number"},[n._v("67")]),s("br"),s("span",{staticClass:"line-number"},[n._v("68")]),s("br"),s("span",{staticClass:"line-number"},[n._v("69")]),s("br"),s("span",{staticClass:"line-number"},[n._v("70")]),s("br"),s("span",{staticClass:"line-number"},[n._v("71")]),s("br")])]),s("h3",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[n._v("#")]),n._v(" 总结：")]),n._v(" "),s("p",[n._v("通过上面的代码，我们分析一下自动装箱与拆箱发生的时机：")]),n._v(" "),s("p",[n._v("（1）当需要一个对象的时候会自动装箱，比如Integer a = 10;equals(Object o)方法的参数是Object对象，所以需要装箱。")]),n._v(" "),s("p",[n._v("（2）当需要一个基本类型时会自动拆箱，比如int a = new Integer(10);算术运算是在基本类型间进行的，所以当遇到算术运算时会自动拆箱，比如代码中的 c == (a + b);")]),n._v(" "),s("p",[n._v("（3） 包装类型 == 基本类型时，包装类型自动拆箱；")]),n._v(" "),s("p",[n._v("需要注意的是：“==”在没遇到算术运算时，不会自动拆箱；基本类型只会自动装箱为对应的包装类型，代码中最后一条说明的内容。")]),n._v(" "),s("p",[n._v("在JDK 1.5中提供了自动装箱与自动拆箱，这其实是Java 编译器的语法糖，编译器通过调用包装类型的valueOf()方法实现自动装箱，调用xxxValue()方法自动拆箱。自动装箱和拆箱会有一些陷阱，那就是包装类型复用了某些对象。")]),n._v(" "),s("p",[n._v("（1）Integer默认复用了[-128,127]这些对象，其中高位置可以修改；")]),n._v(" "),s("p",[n._v("（2）Byte复用了全部256个对象[-128,127]；")]),n._v(" "),s("p",[n._v("（3）Short复用了[-128,127]这些对象；")]),n._v(" "),s("p",[n._v("（4）Long复用了[-128,127];")]),n._v(" "),s("p",[n._v("（5）Character复用了[0,127],Charater不能表示负数;")]),n._v(" "),s("p",[n._v("Double和Float是连续不可数的，所以没法复用对象，也就不存在自动装箱复用陷阱。")]),n._v(" "),s("p",[n._v("Boolean没有自动装箱与拆箱，它也复用了Boolean.TRUE和Boolean.FALSE，通过Boolean.valueOf(boolean b)返回的Blooean对象要么是TRUE，要么是FALSE，这点也要注意。")]),n._v(" "),s("p",[n._v("本文介绍了“真实的”自动装箱与拆箱，为了避免写出错误的代码，又从包装类型的源码入手，指出了各种包装类型在自动装箱和拆箱时存在的陷阱，同时指出了自动装箱与拆箱发生的时机。")]),n._v(" "),s("h2",{attrs:{id:"基本数据类型的存储方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基本数据类型的存储方式"}},[n._v("#")]),n._v(" 基本数据类型的存储方式")]),n._v(" "),s("p",[n._v("上面自动拆箱和装箱的原理其实与常量池有关。")]),n._v(" "),s("h3",{attrs:{id:"存在栈中"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#存在栈中"}},[n._v("#")]),n._v(" 存在栈中")]),n._v(" "),s("p",[n._v("public void(int a)\n{\nint i = 1;\nint j = 1;\n}\n方法中的i 存在虚拟机栈的局部变量表里，i是一个引用，j也是一个引用，它们都指向局部变量表里的整型值 1.\nint a是传值引用，所以a也会存在局部变量表。")]),n._v(" "),s("h3",{attrs:{id:"存在堆里"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#存在堆里"}},[n._v("#")]),n._v(" 存在堆里")]),n._v(" "),s("p",[n._v("class A{\nint i = 1;\nA a = new A();\n}\ni是类的成员变量。类实例化的对象存在堆中，所以成员变量也存在堆中，引用a存的是对象的地址，引用i存的是值，这个值1也会存在堆中。可以理解为引用i指向了这个值1。也可以理解为i就是1.")]),n._v(" "),s("p",[n._v('3 包装类对象怎么存\n其实我们说的常量池也可以叫对象池。\n比如String a= new String("a").intern()时会先在常量池找是否有“a"对象如果有的话直接返回“a"对象在常量池的地址，即让引用a指向常量”a"对象的内存地址。\npublic native String intern();\nInteger也是同理。')]),n._v(" "),s("p",[n._v("下图是Integer类型在常量池中查找同值对象的方法。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('public static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\nprivate static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static final Integer cache[];\n\n    static {\n        // high value may be configured by property\n        int h = 127;\n        String integerCacheHighPropValue =\n            sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");\n        if (integerCacheHighPropValue != null) {\n            try {\n                int i = parseInt(integerCacheHighPropValue);\n                i = Math.max(i, 127);\n                // Maximum array size is Integer.MAX_VALUE\n                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n            } catch( NumberFormatException nfe) {\n                // If the property cannot be parsed into an int, ignore it.\n            }\n        }\n        high = h;\n\n        cache = new Integer[(high - low) + 1];\n        int j = low;\n        for(int k = 0; k < cache.length; k++)\n            cache[k] = new Integer(j++);\n\n        // range [-128, 127] must be interned (JLS7 5.1.7)\n        assert IntegerCache.high >= 127;\n    }\n\n    private IntegerCache() {}\n}\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br")])]),s("p",[n._v("所以基本数据类型的包装类型可以在常量池查找对应值的对象，找不到就会自动在常量池创建该值的对象。")]),n._v(" "),s("p",[n._v("而String类型可以通过intern来完成这个操作。")]),n._v(" "),s("p",[n._v("JDK1.7后，常量池被放入到堆空间中，这导致intern()函数的功能不同，具体怎么个不同法，且看看下面代码，这个例子是网上流传较广的一个例子，分析图也是直接粘贴过来的，这里我会用自己的理解去解释这个例子：")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('[java] view plain copy\nString s = new String("1");  \ns.intern();  \nString s2 = "1";  \nSystem.out.println(s == s2);  \n  \nString s3 = new String("1") + new String("1");  \ns3.intern();  \nString s4 = "11";  \nSystem.out.println(s3 == s4);  \n输出结果为：\n\n[java] view plain copy\nJDK1.6以及以下：false false  \nJDK1.7以及以上：false true\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br")])]),s("p",[s("img",{attrs:{src:"https://img-blog.csdn.net/20180422231916788?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3MjQ4ODg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70",alt:"image"}})]),n._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdn.net/20180422231929413?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3MjQ4ODg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70",alt:"image"}}),n._v("\nJDK1.6查找到常量池存在相同值的对象时会直接返回该对象的地址。")]),n._v(" "),s("p",[n._v("JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。")]),n._v(" "),s("p",[n._v("那么其他字符串在常量池找值时就会返回另一个堆中对象的地址。")]),n._v(" "),s("p",[n._v("下一节详细介绍String以及相关包装类。")]),n._v(" "),s("p",[n._v("具体请见：https://blog.csdn.net/a724888/article/details/80042298")]),n._v(" "),s("p",[n._v("关于Java面向对象三大特性，请参考：")]),n._v(" "),s("p",[n._v("https://blog.csdn.net/a724888/article/details/80033043")]),n._v(" "),s("h2",{attrs:{id:"参考文章"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[n._v("#")]),n._v(" 参考文章")]),n._v(" "),s("p",[s("a",{attrs:{href:"https://www.runoob.com/java/java-basic-datatypes.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://www.runoob.com/java/java-basic-datatypes.html"),s("OutboundLink")],1)]),n._v(" "),s("p",[s("a",{attrs:{href:"https://www.cnblogs.com/zch1126/p/5335139.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://www.cnblogs.com/zch1126/p/5335139.html"),s("OutboundLink")],1)]),n._v(" "),s("p",[s("a",{attrs:{href:"https://blog.csdn.net/jreffchen/article/details/81015884",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://blog.csdn.net/jreffchen/article/details/81015884"),s("OutboundLink")],1)]),n._v(" "),s("p",[s("a",{attrs:{href:"https://blog.csdn.net/yuhongye111/article/details/31850779",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://blog.csdn.net/yuhongye111/article/details/31850779"),s("OutboundLink")],1)]),n._v(" "),s("h2",{attrs:{id:"微信公众号"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#微信公众号"}},[n._v("#")]),n._v(" 微信公众号")]),n._v(" "),s("h3",{attrs:{id:"java技术江湖"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java技术江湖"}},[n._v("#")]),n._v(" Java技术江湖")]),n._v(" "),s("p",[n._v("如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，作者黄小斜，专注 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！")]),n._v(" "),s("p",[s("strong",[n._v("Java工程师必备学习资源:")]),n._v(" 一些Java工程师常用学习资源，关注公众号后，后台回复关键字 "),s("strong",[n._v("“Java”")]),n._v(" 即可免费无套路获取。")]),n._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190805090108984.jpg",alt:"我的公众号"}})]),n._v(" "),s("h3",{attrs:{id:"个人公众号-黄小斜"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#个人公众号-黄小斜"}},[n._v("#")]),n._v(" 个人公众号：黄小斜")]),n._v(" "),s("p",[n._v("作者是 985 硕士，蚂蚁金服 JAVA 工程师，专注于 JAVA 后端技术栈：SpringBoot、MySQL、分布式、中间件、微服务，同时也懂点投资理财，偶尔讲点算法和计算机理论基础，坚持学习和写作，相信终身学习的力量！")]),n._v(" "),s("p",[s("strong",[n._v("程序员3T技术学习资源：")]),n._v(" 一些程序员学习技术的资源大礼包，关注公众号后，后台回复关键字 "),s("strong",[n._v("“资料”")]),n._v(" 即可免费无套路获取。")]),n._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190829222750556.jpg",alt:""}})])])}),[],!1,null,null,null);a.default=t.exports}}]);