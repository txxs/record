(window.webpackJsonp=window.webpackJsonp||[]).push([[1312],{1708:function(t,e,a){"use strict";a.r(e);var s=a(13),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[t._v("#")]),t._v(" 数据类型")]),t._v(" "),a("p",[t._v("来源：https://redisbook.readthedocs.io/en/latest/internal/db.html#id4")]),t._v(" "),a("p",[t._v("Redis是一个键值对数据库，数据库中的键值对由字典保存。每个数据库都有一个对应的字典，这个字典被称之为键空间。当用户添加一个键值对到数据库时（不论键值对是什么类型）， 程序就将该键值对添加到键空间")]),t._v(" "),a("p",[t._v("字典的键是一个字符串对象。字典的值则可以是包括【字符串、列表、哈希表、集合或有序集】在内的任意一种 Redis 类型对象。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://txxs.github.io/pic/javainterview/redis%E9%94%AE%E7%A9%BA%E9%97%B4.png",alt:""}})]),t._v(" "),a("p",[t._v("上图展示了一个包含 number 、 book 、 message 三个键的数据库 —— 其中 number 键是一个列表，列表中包含三个整数值； book 键是一个哈希表，表中包含三个键值对； 而 message 键则指向另一个字符串：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://txxs.github.io/pic/javainterview/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png",alt:""}})]),t._v(" "),a("p",[t._v("不同的数据类型的具体实现（压缩列表、跳表必看）请看： https://redisbook.readthedocs.io/en/latest/index.html#id3")]),t._v(" "),a("h2",{attrs:{id:"集群模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集群模式"}},[t._v("#")]),t._v(" 集群模式")]),t._v(" "),a("p",[t._v("来源："),a("br"),t._v("\nhttps://my.oschina.net/zhangxufeng/blog/905611"),a("br"),t._v("\nhttps://www.cnblogs.com/leeSmall/p/8398401.html"),a("br"),t._v("\nhttps://docs.aws.amazon.com/zh_cn/AmazonElastiCache/latest/red-ug/CacheNodes.NodeGroups.html")]),t._v(" "),a("h3",{attrs:{id:"主从"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主从"}},[t._v("#")]),t._v(" 主从")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://txxs.github.io/pic/javainterview/redis%E4%B8%BB%E4%BB%8E.png",alt:""}})]),t._v(" "),a("p",[t._v("用一个redis实例作为主机，其余的实例作为从机。主机和从机的数据完全一致，主机支持数据的写入和读取等各项操作，而从机则只支持与主机数据的同步和读取。因而可以将写入数据的命令发送给主机执行，而读取数据的命令发送给不同的从机执行，从而达到读写分离的目的。")]),t._v(" "),a("p",[t._v("问题是主从模式如果所连接的redis实例因为故障下线了，没有提供一定的手段通知客户端另外可连接的客户端地址，因而需要手动更改客户端配置重新连接。如果主节点由于故障下线了，那么从节点因为没有主节点而同步中断，因而需要人工进行故障转移工作。为了解决这两个问题，在2.8版本之后redis正式提供了sentinel（哨兵）架构。")]),t._v(" "),a("h3",{attrs:{id:"哨兵"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#哨兵"}},[t._v("#")]),t._v(" 哨兵")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://txxs.github.io/pic/javainterview/redis%E5%93%A8%E5%85%B5.png",alt:""}})]),t._v(" "),a("p",[t._v("由Sentinel节点定期监控发现主节点是否出现了故障，当主节点出现故障时，由Redis Sentinel自动完成故障发现和转移，并通知应用方，实现高可用性。")]),t._v(" "),a("h3",{attrs:{id:"集群"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集群"}},[t._v("#")]),t._v(" 集群")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://txxs.github.io/pic/javainterview/redis%E9%9B%86%E7%BE%A4.png",alt:""}})]),t._v(" "),a("p",[t._v("redis主从或哨兵模式的每个实例都是全量存储所有数据，浪费内存且有木桶效应。为了最大化利用内存，可以采用集群，就是分布式存储。集群将数据分片存储，每组节点存储一部分数据，从而达到分布式集群的目的。")]),t._v(" "),a("p",[t._v("上图是主从模式与集群模式的区别，redis集群中数据是和槽（slot）挂钩的，其总共定义了16384个槽，所有的数据根据一致哈希算法会被映射到这16384个槽中的某个槽中；另一方面，这16384个槽是按照设置被分配到不同的redis节点上。")]),t._v(" "),a("p",[t._v("但集群模式会直接导致访问数据方式的改变，比如客户端向A节点发送GET命令但该数据在B节点，redis会返回重定向错误给客户端让客户端再次发送请求，这也直接导致了必须在相同节点才能执行的一些高级功能（如Lua、事务、Pipeline）无法使用。另外还会引发数据分配的一致性hash问题可以参看"),a("a",{attrs:{href:"https://github.com/crossoverJie/JCSprout/blob/master/MD/Consistent-Hash.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"如何选择"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何选择"}},[t._v("#")]),t._v(" 如何选择")]),t._v(" "),a("ol",[a("li",[t._v("集群的优势在于高可用，将写操作分开到不同的节点，如果写的操作较多且数据量巨大，且不需要高级功能则可能考虑集群")]),t._v(" "),a("li",[t._v("哨兵的优势在于高可用，支持高级功能，且能在读的操作较多的场景下工作，所以在绝大多数场景中是适合的")]),t._v(" "),a("li",[t._v("主从的优势在于支持高级功能，且能在读的操作较多的场景下工作，但无法保证高可用，不建议在数据要求严格的场景下使用")])]),t._v(" "),a("h2",{attrs:{id:"使用策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用策略"}},[t._v("#")]),t._v(" 使用策略")]),t._v(" "),a("h3",{attrs:{id:"延迟加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#延迟加载"}},[t._v("#")]),t._v(" 延迟加载")]),t._v(" "),a("p",[t._v("读：当读请求到来时，先从缓存读，如果读不到就从数据库读，读完之后同步到缓存且添加过期时间"),a("br"),t._v("\n写：当写请求到来时，只写数据库")]),t._v(" "),a("p",[t._v("优点：仅对请求的数据进行一段时间的缓存，没有请求过的数据就不会被缓存，节省缓存空间；节点出现故障并不是致命的，因为可以从数据库中得到"),a("br"),t._v("\n缺点：缓存数据不是最新的；【缓存击穿】；【缓存失效】")]),t._v(" "),a("h3",{attrs:{id:"直写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#直写"}},[t._v("#")]),t._v(" 直写")]),t._v(" "),a("p",[t._v("读：当读请求到来时，先从缓存读，如果读不到就从数据库读，读完之后同步到缓存且设置为永不过期"),a("br"),t._v("\n写：当写请求到来时，先写数据库然后同步到缓存，设置为永不过期")]),t._v(" "),a("p",[t._v("优点：缓存数据是最新的，无需担心缓存击穿、失效问题，编码方便"),a("br"),t._v("\n缺点：大量数据可能没有被读取的资源浪费；节点故障或重启会导致缓存数据的丢失直到有写操作同步到缓存；每次写入都需要写缓存导致的性能损失")]),t._v(" "),a("p",[t._v("永不过期的缓存会大量占用空间，可以设置过期时间来改进，但是会引进【缓存失效】问题，需要注意解决")]),t._v(" "),a("h3",{attrs:{id:"如何选择-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何选择-2"}},[t._v("#")]),t._v(" 如何选择")]),t._v(" "),a("p",[t._v("如果需要缓存与数据库数据保持实时一致，则需要选择直写方式"),a("br"),t._v("\n如果缓存服务很稳定、缓存的可用空间大、写缓存的性能丢失能够接受，选择直写方式比较方便实现"),a("br"),t._v("\n否则选择延迟加载，同时注意解决引进的问题")]),t._v(" "),a("h2",{attrs:{id:"缓存问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存问题"}},[t._v("#")]),t._v(" 缓存问题")]),t._v(" "),a("h3",{attrs:{id:"缓存击穿"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[t._v("#")]),t._v(" 缓存击穿")]),t._v(" "),a("p",[t._v("查询一个数据库中不存在的数据，比如商品详情，查询一个不存在的ID，每次都会访问DB，如果有人恶意破坏，很可能直接对DB造成过大地压力。")]),t._v(" "),a("p",[t._v("当通过某一个key去查询数据的时候，如果对应在数据库中的数据都不存在，我们将此key对应的value设置为一个默认的值。")]),t._v(" "),a("h3",{attrs:{id:"缓存失效"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存失效"}},[t._v("#")]),t._v(" 缓存失效")]),t._v(" "),a("p",[t._v("在高并发的环境下，如果此时key对应的缓存失效，此时有多个进程就会去同时去查询DB，然后再去同时设置缓存。这个时候如果这个key是系统中的热点key或者同时失效的数量比较多时，DB访问量会瞬间增大，造成过大的压力。")]),t._v(" "),a("p",[t._v("将系统中key的缓存失效时间均匀地错开")]),t._v(" "),a("h3",{attrs:{id:"热点key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#热点key"}},[t._v("#")]),t._v(" 热点key")]),t._v(" "),a("p",[t._v("缓存中的某些Key(可能对应用与某个促销商品)对应的value存储在集群中一台机器，使得所有流量涌向同一机器，成为系统的瓶颈，该问题的挑战在于它无法通过增加机器容量来解决。")]),t._v(" "),a("ol",[a("li",[t._v("客户端热点key缓存：将热点key对应value并缓存在客户端本地，并且设置一个失效时间。")]),t._v(" "),a("li",[t._v("将热点key分散为多个子key，然后存储到缓存集群的不同机器上，这些子key对应的value都和热点key是一样的。")])]),t._v(" "),a("h2",{attrs:{id:"持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#持久化"}},[t._v("#")]),t._v(" 持久化")]),t._v(" "),a("p",[t._v("RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。"),a("br"),t._v("\nAOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。"),a("br"),t._v("\nRedis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。"),a("br"),t._v("\n但实际上持久化会对Redis的性能造成非常严重的影响，如果一定需要保存数据，那么数据就不应该依靠缓存来保存，建议使用其他方式如数据库。所以Redis的持久化意义不大。")]),t._v(" "),a("p",[t._v("欢迎光临"),a("a",{attrs:{href:"http://www.wangtianyi.top/?utm_source=github&utm_medium=github",target:"_blank",rel:"noopener noreferrer"}},[t._v("我的博客"),a("OutboundLink")],1),t._v("，发现更多技术资源~")])])}),[],!1,null,null,null);e.default=r.exports}}]);