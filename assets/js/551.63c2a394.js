(window.webpackJsonp=window.webpackJsonp||[]).push([[551],{957:function(a,n,s){"use strict";s.r(n);var e=s(13),t=Object(e.a)({},(function(){var a=this,n=a.$createElement,s=a._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"目录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[a._v("#")]),a._v(" 目录")]),a._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#%E5%88%9D%E6%8E%A2%E6%9E%9A%E4%B8%BE%E7%B1%BB"}},[a._v("初探枚举类")]),a._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#%E6%9E%9A%E4%B8%BE%E7%B1%BB-%E8%AF%AD%E6%B3%95"}},[a._v("枚举类-语法")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8"}},[a._v("枚举类的具体使用")]),a._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#%E5%B8%B8%E9%87%8F"}},[a._v("常量")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#switch"}},[a._v("switch")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E5%90%91%E6%9E%9A%E4%B8%BE%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%96%B9%E6%B3%95"}},[a._v("向枚举中添加新方法")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E8%A6%86%E7%9B%96%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%96%B9%E6%B3%95"}},[a._v("覆盖枚举的方法")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"}},[a._v("实现接口")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%BB%84%E7%BB%87%E6%9E%9A%E4%B8%BE"}},[a._v("使用接口组织枚举")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E9%9B%86%E5%90%88"}},[a._v("枚举类集合")])])])])])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"}},[a._v("使用枚举类的注意事项")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"}},[a._v("枚举类的实现原理")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%AE%9E%E6%88%98"}},[a._v("枚举类实战")]),a._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#%E5%AE%9E%E6%88%98%E4%B8%80%E6%97%A0%E5%8F%82"}},[a._v("实战一无参")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E5%AE%9E%E6%88%98%E4%BA%8C%E6%9C%89%E4%B8%80%E5%8F%82"}},[a._v("实战二有一参")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E5%AE%9E%E6%88%98%E4%B8%89%E6%9C%89%E4%B8%A4%E5%8F%82"}},[a._v("实战三有两参")])])])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E6%80%BB%E7%BB%93"}},[a._v("枚举类总结")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E6%9E%9A%E4%B8%BE-api"}},[a._v("枚举 API")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E6%80%BB%E7%BB%93"}},[a._v("总结")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"}},[a._v("参考文章")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7"}},[a._v("微信公众号")]),a._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96"}},[a._v("Java技术江湖")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E4%B8%AA%E4%BA%BA%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%BB%84%E5%B0%8F%E6%96%9C"}},[a._v("个人公众号：黄小斜")])])])])]),a._v(" "),s("hr"),a._v(" "),s("p",[a._v("本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看")]),a._v(" "),s("blockquote",[s("p",[a._v("https://github.com/h2pl/Java-Tutorial")])]),a._v(" "),s("p",[a._v("喜欢的话麻烦点下Star哈")]),a._v(" "),s("p",[a._v("文章首发于我的个人博客：")]),a._v(" "),s("blockquote",[s("p",[a._v("www.how2playlife.com")])]),a._v(" "),s("p",[a._v("本文是微信公众号【Java技术江湖】的《夯实Java基础系列博文》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。\n该系列博文会告诉你如何从入门到进阶，一步步地学习Java基础知识，并上手进行实战，接着了解每个Java知识点背后的实现原理，更完整地了解整个Java技术体系，形成自己的知识框架。为了更好地总结和检验你的学习成果，本系列文章也会提供每个知识点对应的面试题以及参考答案。")]),a._v(" "),s("p",[a._v("如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。")]),a._v(" "),s("p",[a._v("枚举（enum）类型是Java 5新增的特性，它是一种新的类型，允许用常量来表示特定的数据片断，而且全部都以类型安全的形式来表示。")]),a._v(" "),s("h2",{attrs:{id:"初探枚举类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#初探枚举类"}},[a._v("#")]),a._v(" 初探枚举类")]),a._v(" "),s("blockquote",[s("p",[a._v("在程序设计中，有时会用到由若干个有限数据元素组成的集合，如一周内的星期一到星期日七个数据元素组成的集合，由三种颜色红、黄、绿组成的集合，一个工作班组内十个职工组成的集合等等，程序中某个变量取值仅限于集合中的元素。此时，可将这些数据集合定义为枚举类型。")])]),a._v(" "),s("blockquote",[s("p",[a._v("因此，枚举类型是某类数据可能取值的集合，如一周内星期可能取值的集合为：\n　　{ Sun,Mon,Tue,Wed,Thu,Fri,Sat}\n　　该集合可定义为描述星期的枚举类型，该枚举类型共有七个元素，因而用枚举类型定义的枚举变量只能取集合中的某一元素值。由于枚举类型是导出数据类型，因此，必须先定义枚举类型，然后再用枚举类型定义枚举型变量。")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("enum <枚举类型名> \n　　{ <枚举元素表> };\n　　\n　　其中：关键词enum表示定义的是枚举类型，枚举类型名由标识符组成，而枚举元素表由枚举元素或枚举常量组成。例如： \n　　\nenum weekdays \n　　{ Sun,Mon,Tue,Wed,Thu,Fri,Sat };\n　　定义了一个名为 weekdays的枚举类型，它包含七个元素：Sun、Mon、Tue、Wed、Thu、Fri、Sat。\n")])])]),s("blockquote",[s("p",[a._v("在编译器编译程序时，给枚举类型中的每一个元素指定一个整型常量值(也称为序号值)。若枚举类型定义中没有指定元素的整型常量值，则整型常量值从0开始依次递增，因此，weekdays枚举类型的七个元素Sun、Mon、Tue、Wed、Thu、Fri、Sat对应的整型常量值分别为0、1、2、3、4、5、6。\n　　注意：在定义枚举类型时，也可指定元素对应的整型常量值。")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("例如，描述逻辑值集合{TRUE、FALSE}的枚举类型boolean可定义如下：\nenum boolean \n　　{ TRUE=1 ,FALSE=0 };\n该定义规定：TRUE的值为1，而FALSE的值为0。\n　　\n而描述颜色集合{red,blue,green,black,white,yellow}的枚举类型colors可定义如下：\nenum colors \n　　{red=5,blue=1,green,black,white,yellow};\n　　该定义规定red为5 ，blue为1，其后元素值从2 开始递增加1。green、black、white、yellow的值依次为2、3、4、5。\n")])])]),s("p",[a._v("此时，整数5将用于表示二种颜色red与yellow。通常两个不同元素取相同的整数值是没有意义的。枚举类型的定义只是定义了一个新的数据类型，只有用枚举类型定义枚举变量才能使用这种数据类型。")]),a._v(" "),s("h3",{attrs:{id:"枚举类-语法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#枚举类-语法"}},[a._v("#")]),a._v(" 枚举类-语法")]),a._v(" "),s("blockquote",[s("p",[a._v("enum 与 class、interface 具有相同地位；\n可以继承多个接口；\n可以拥有构造器、成员方法、成员变量；\n1.2 枚举类与普通类不同之处")]),a._v(" "),s("p",[a._v("默认继承 java.lang.Enum 类，所以不能继承其他父类；其中 java.lang.Enum 类实现了 java.lang.Serializable 和 java.lang.Comparable 接口；")])]),a._v(" "),s("blockquote",[s("p",[a._v("使用 enum 定义，默认使用 final 修饰，因此不能派生子类；")])]),a._v(" "),s("blockquote",[s("p",[a._v("构造器默认使用 private 修饰，且只能使用 private 修饰；")])]),a._v(" "),s("blockquote",[s("p",[a._v("枚举类所有实例必须在第一行给出，默认添加 public static final 修饰，否则无法产生实例；")])]),a._v(" "),s("h3",{attrs:{id:"枚举类的具体使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#枚举类的具体使用"}},[a._v("#")]),a._v(" 枚举类的具体使用")]),a._v(" "),s("p",[a._v("这部分内容参考https://blog.csdn.net/qq_27093465/article/details/52180865")]),a._v(" "),s("h4",{attrs:{id:"常量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常量"}},[a._v("#")]),a._v(" 常量")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("public class 常量 {\n}\nenum Color {\n    Red, Green, Blue, Yellow\n}\n")])])]),s("h4",{attrs:{id:"switch"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#switch"}},[a._v("#")]),a._v(" switch")]),a._v(" "),s("p",[a._v("JDK1.6之前的switch语句只支持int,char,enum类型，使用枚举，能让我们的代码可读性更强。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("public static void showColor(Color color) {\n        switch (color) {\n            case Red:\n                System.out.println(color);\n                break;\n            case Blue:\n                System.out.println(color);\n                break;\n            case Yellow:\n                System.out.println(color);\n                break;\n            case Green:\n                System.out.println(color);\n                break;\n        }\n    }\n")])])]),s("h4",{attrs:{id:"向枚举中添加新方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#向枚举中添加新方法"}},[a._v("#")]),a._v(" 向枚举中添加新方法")]),a._v(" "),s("p",[a._v("如果打算自定义自己的方法，那么必须在enum实例序列的最后添加一个分号。而且 Java 要求必须先定义 enum 实例。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('enum Color {\n    //每个颜色都是枚举类的一个实例，并且构造方法要和枚举类的格式相符合。\n    //如果实例后面有其他内容，实例序列结束时要加分号。\n    Red("红色", 1), Green("绿色", 2), Blue("蓝色", 3), Yellow("黄色", 4);\n    String name;\n    int index;\n    Color(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n    public void showAllColors() {\n        //values是Color实例的数组，在通过index和name可以获取对应的值。\n        for (Color color : Color.values()) {\n            System.out.println(color.index + ":" + color.name);\n        }\n    }\n}\n')])])]),s("h4",{attrs:{id:"覆盖枚举的方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#覆盖枚举的方法"}},[a._v("#")]),a._v(" 覆盖枚举的方法")]),a._v(" "),s("p",[a._v("所有枚举类都继承自Enum类，所以可以重写该类的方法\n下面给出一个toString()方法覆盖的例子。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('@Override\npublic String toString() {\n    return this.index + ":" + this.name;\n}\n')])])]),s("h4",{attrs:{id:"实现接口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实现接口"}},[a._v("#")]),a._v(" 实现接口")]),a._v(" "),s("p",[a._v("所有的枚举都继承自java.lang.Enum类。由于Java 不支持多继承，所以枚举对象不能再继承其他类。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("enum Color implements Print{\n    @Override\n    public void print() {\n        System.out.println(this.name);\n    }\n}\n")])])]),s("h4",{attrs:{id:"使用接口组织枚举"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用接口组织枚举"}},[a._v("#")]),a._v(" 使用接口组织枚举")]),a._v(" "),s("p",[a._v("搞个实现接口，来组织枚举，简单讲，就是分类吧。如果大量使用枚举的话，这么干，在写代码的时候，就很方便调用啦。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("public class 用接口组织枚举 {\n    public static void main(String[] args) {\n        Food cf = chineseFood.dumpling;\n        Food jf = Food.JapaneseFood.fishpiece;\n        for (Food food : chineseFood.values()) {\n            System.out.println(food);\n        }\n        for (Food food : Food.JapaneseFood.values()) {\n            System.out.println(food);\n        }\n    }\n}\ninterface Food {\n    enum JapaneseFood implements Food {\n        suse, fishpiece\n    }\n}\nenum chineseFood implements Food {\n    dumpling, tofu\n}\n")])])]),s("h4",{attrs:{id:"枚举类集合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#枚举类集合"}},[a._v("#")]),a._v(" 枚举类集合")]),a._v(" "),s("p",[a._v("java.util.EnumSet和java.util.EnumMap是两个枚举集合。EnumSet保证集合中的元素不重复；EnumMap中的 key是enum类型，而value则可以是任意类型。")]),a._v(" "),s("p",[a._v("EnumSet在JDK中没有找到实现类，这里写一个EnumMap的例子")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('public class 枚举类集合 {\n    public static void main(String[] args) {\n        EnumMap<Color, String> map = new EnumMap<Color, String>(Color.class);\n        map.put(Color.Blue, "Blue");\n        map.put(Color.Yellow, "Yellow");\n        map.put(Color.Red, "Red");\n        System.out.println(map.get(Color.Red));\n    }\n}\n')])])]),s("h2",{attrs:{id:"使用枚举类的注意事项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用枚举类的注意事项"}},[a._v("#")]),a._v(" 使用枚举类的注意事项")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdn.net/20170112172420090",alt:"image"}})]),a._v(" "),s("p",[a._v("枚举类型对象之间的值比较，是可以使用==，直接来比较值，是否相等的，不是必须使用equals方法的哟。")]),a._v(" "),s("p",[a._v("因为枚举类Enum已经重写了equals方法")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("/**\n * Returns true if the specified object is equal to this\n * enum constant.\n *\n * @param other the object to be compared for equality with this object.\n * @return  true if the specified object is equal to this\n *          enum constant.\n */\npublic final boolean equals(Object other) {\n    return this==other;\n}\n")])])]),s("h2",{attrs:{id:"枚举类的实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#枚举类的实现原理"}},[a._v("#")]),a._v(" 枚举类的实现原理")]),a._v(" "),s("p",[a._v("这部分参考https://blog.csdn.net/mhmyqn/article/details/48087247")]),a._v(" "),s("blockquote",[s("p",[a._v("Java从JDK1.5开始支持枚举，也就是说，Java一开始是不支持枚举的，就像泛型一样，都是JDK1.5才加入的新特性。通常一个特性如果在一开始没有提供，在语言发展后期才添加，会遇到一个问题，就是向后兼容性的问题。")]),a._v(" "),s("p",[a._v("像Java在1.5中引入的很多特性，为了向后兼容，编译器会帮我们写的源代码做很多事情，比如泛型为什么会擦除类型，为什么会生成桥接方法，foreach迭代，自动装箱/拆箱等，这有个术语叫“语法糖”，而编译器的特殊处理叫“解语法糖”。那么像枚举也是在JDK1.5中才引入的，又是怎么实现的呢？")])]),a._v(" "),s("blockquote",[s("p",[a._v("Java在1.5中添加了java.lang.Enum抽象类，它是所有枚举类型基类。提供了一些基础属性和基础方法。同时，对把枚举用作Set和Map也提供了支持，即java.util.EnumSet和java.util.EnumMap。")])]),a._v(" "),s("p",[a._v("接下来定义一个简单的枚举类")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('public enum Day {\n    MONDAY {\n        @Override\n        void say() {\n            System.out.println("MONDAY");\n        }\n    }\n    , TUESDAY {\n        @Override\n        void say() {\n            System.out.println("TUESDAY");\n        }\n    }, FRIDAY("work"){\n        @Override\n        void say() {\n            System.out.println("FRIDAY");\n        }\n    }, SUNDAY("free"){\n        @Override\n        void say() {\n            System.out.println("SUNDAY");\n        }\n    };\n    String work;\n    //没有构造参数时，每个实例可以看做常量。\n    //使用构造参数时，每个实例都会变得不一样，可以看做不同的类型，所以编译后会生成实例个数对应的class。\n    private Day(String work) {\n        this.work = work;\n    }\n    private Day() {\n\n    }\n    //枚举实例必须实现枚举类中的抽象方法\n    abstract void say ();\n\n}\n')])])]),s("p",[a._v("反编译结果")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('D:\\MyTech\\out\\production\\MyTech\\com\\javase\\枚举类>javap Day.class\nCompiled from "Day.java"\n\npublic abstract class com.javase.枚举类.Day extends java.lang.Enum<com.javase.枚举类.Day> {\n  public static final com.javase.枚举类.Day MONDAY;\n  public static final com.javase.枚举类.Day TUESDAY;\n  public static final com.javase.枚举类.Day FRIDAY;\n  public static final com.javase.枚举类.Day SUNDAY;\n  java.lang.String work;\n  public static com.javase.枚举类.Day[] values();\n  public static com.javase.枚举类.Day valueOf(java.lang.String);\n  abstract void say();\n  com.javase.枚举类.Day(java.lang.String, int, com.javase.枚举类.Day$1);\n  com.javase.枚举类.Day(java.lang.String, int, java.lang.String, com.javase.枚举类.Day$1);\n  static {};\n}\n')])])]),s("blockquote",[s("p",[a._v("可以看到，一个枚举在经过编译器编译过后，变成了一个抽象类，它继承了java.lang.Enum；而枚举中定义的枚举常量，变成了相应的public static final属性，而且其类型就抽象类的类型，名字就是枚举常量的名字.")]),a._v(" "),s("p",[a._v("同时我们可以在Operator.class的相同路径下看到四个内部类的.class文件com/mikan/Day$1.class、com/mikan/Day$2.class、com/mikan/Day$3.class、com/mikan/Day$4.class，也就是说这四个命名字段分别使用了内部类来实现的；同时添加了两个方法values()和valueOf(String)；我们定义的构造方法本来只有一个参数，但却变成了三个参数；同时还生成了一个静态代码块。这些具体的内容接下来仔细看看。")])]),a._v(" "),s("p",[a._v("下面分析一下字节码中的各部分，其中：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("InnerClasses:\n     static #23; //class com/javase/枚举类/Day$4\n     static #18; //class com/javase/枚举类/Day$3\n     static #14; //class com/javase/枚举类/Day$2\n     static #10; //class com/javase/枚举类/Day$1\n")])])]),s("p",[a._v("从中可以看到它有4个内部类，这四个内部类的详细信息后面会分析。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('static {};\n    descriptor: ()V\n    flags: ACC_STATIC\n    Code:\n      stack=5, locals=0, args_size=0\n         0: new           #10                 // class com/javase/枚举类/Day$1\n         3: dup\n         4: ldc           #11                 // String MONDAY\n         6: iconst_0\n         7: invokespecial #12                 // Method com/javase/枚举类/Day$1."<init>":(Ljava/lang/String;I)V\n        10: putstatic     #13                 // Field MONDAY:Lcom/javase/枚举类/Day;\n        13: new           #14                 // class com/javase/枚举类/Day$2\n        16: dup\n        17: ldc           #15                 // String TUESDAY\n        19: iconst_1\n        20: invokespecial #16                 // Method com/javase/枚举类/Day$2."<init>":(Ljava/lang/String;I)V\n        //后面类似，这里省略\n}\n')])])]),s("p",[a._v("其实编译器生成的这个静态代码块做了如下工作：分别设置生成的四个公共静态常量字段的值，同时编译器还生成了一个静态字段$VALUES，保存的是枚举类型定义的所有枚举常量\n编译器添加的values方法：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('public static com.javase.Day[] values();  \n  flags: ACC_PUBLIC, ACC_STATIC  \n  Code:  \n    stack=1, locals=0, args_size=0  \n       0: getstatic     #2                  // Field $VALUES:[Lcom/javase/Day;  \n       3: invokevirtual #3                  // Method "[Lcom/mikan/Day;".clone:()Ljava/lang/Object;  \n       6: checkcast     #4                  // class "[Lcom/javase/Day;"  \n       9: areturn  \n这个方法是一个公共的静态方法，所以我们可以直接调用该方法（Day.values()）,返回这个枚举值的数组，另外，这个方法的实现是，克隆在静态代码块中初始化的$VALUES字段的值，并把类型强转成Day[]类型返回。\n')])])]),s("p",[a._v("造方法为什么增加了两个参数？")]),a._v(" "),s("p",[a._v("有一个问题，构造方法我们明明只定义了一个参数，为什么生成的构造方法是三个参数呢？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("从Enum类中我们可以看到，为每个枚举都定义了两个属性，name和ordinal，name表示我们定义的枚举常量的名称，如FRIDAY、TUESDAY，而ordinal是一个顺序号，根据定义的顺序分别赋予一个整形值，从0开始。在枚举常量初始化时，会自动为初始化这两个字段，设置相应的值，所以才在构造方法中添加了两个参数。即：\n\n另外三个枚举常量生成的内部类基本上差不多，这里就不重复说明了。\n")])])]),s("blockquote",[s("p",[a._v("我们可以从Enum类的代码中看到，定义的name和ordinal属性都是final的，而且大部分方法也都是final的，特别是clone、readObject、writeObject这三个方法，这三个方法和枚举通过静态代码块来进行初始化一起。")])]),a._v(" "),s("blockquote",[s("p",[a._v("它保证了枚举类型的不可变性，不能通过克隆，不能通过序列化和反序列化来复制枚举，这能保证一个枚举常量只是一个实例，即是单例的，所以在effective java中推荐使用枚举来实现单例。")])]),a._v(" "),s("h2",{attrs:{id:"枚举类实战"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#枚举类实战"}},[a._v("#")]),a._v(" 枚举类实战")]),a._v(" "),s("h3",{attrs:{id:"实战一无参"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实战一无参"}},[a._v("#")]),a._v(" 实战一无参")]),a._v(" "),s("p",[a._v("（1）定义一个无参枚举类")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("enum SeasonType {\n    SPRING, SUMMER, AUTUMN, WINTER\n}\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br")])]),s("p",[a._v("（2）实战中的使用")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("// 根据实际情况选择下面的用法即可\nSeasonType springType = SeasonType.SPRING;    // 输出 SPRING \nString springString = SeasonType.SPRING.toString();    // 输出 SPRING\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br")])]),s("h3",{attrs:{id:"实战二有一参"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实战二有一参"}},[a._v("#")]),a._v(" 实战二有一参")]),a._v(" "),s("p",[a._v("（1）定义只有一个参数的枚举类")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('enum SeasonType {\n    // 通过构造函数传递参数并创建实例\n    SPRING("spring"),\n    SUMMER("summer"),\n    AUTUMN("autumn"),\n    WINTER("winter");\n\n    // 定义实例对应的参数\n    private String msg;\n\n    // 必写：通过此构造器给枚举值创建实例\n    SeasonType(String msg) {\n        this.msg = msg;\n    }\n\n    // 通过此方法可以获取到对应实例的参数值\n    public String getMsg() {\n        return msg;\n    }\n}\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br")])]),s("p",[a._v("（2）实战中的使用")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("// 当我们为某个实例类赋值的时候可使用如下方式\nString msg = SeasonType.SPRING.getMsg();    // 输出 spring\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("h3",{attrs:{id:"实战三有两参"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实战三有两参"}},[a._v("#")]),a._v(" 实战三有两参")]),a._v(" "),s("p",[a._v("（1）定义有两个参数的枚举类")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('public enum Season {\n    // 通过构造函数传递参数并创建实例\n    SPRING(1, "spring"),\n    SUMMER(2, "summer"),\n    AUTUMN(3, "autumn"),\n    WINTER(4, "winter");\n\n    // 定义实例对应的参数\n    private Integer key;\n    private String msg;\n\n    // 必写：通过此构造器给枚举值创建实例\n    Season(Integer key, String msg) {\n        this.key = key;\n        this.msg = msg;\n    }\n\n    // 很多情况，我们可能从前端拿到的值是枚举类的 key ，然后就可以通过以下静态方法获取到对应枚举值\n    public static Season valueofKey(Integer key) {\n        for (Season season : Season.values()) {\n            if (season.key.equals(key)) {\n                return season;\n            }\n        }\n        throw new IllegalArgumentException("No element matches " + key);\n    }\n\n    // 通过此方法可以获取到对应实例的 key 值\n    public Integer getKey() {\n        return key;\n    }\n\n    // 通过此方法可以获取到对应实例的 msg 值\n    public String getMsg() {\n        return msg;\n    }\n}\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br"),s("span",{staticClass:"line-number"},[a._v("21")]),s("br"),s("span",{staticClass:"line-number"},[a._v("22")]),s("br"),s("span",{staticClass:"line-number"},[a._v("23")]),s("br"),s("span",{staticClass:"line-number"},[a._v("24")]),s("br"),s("span",{staticClass:"line-number"},[a._v("25")]),s("br"),s("span",{staticClass:"line-number"},[a._v("26")]),s("br"),s("span",{staticClass:"line-number"},[a._v("27")]),s("br"),s("span",{staticClass:"line-number"},[a._v("28")]),s("br"),s("span",{staticClass:"line-number"},[a._v("29")]),s("br"),s("span",{staticClass:"line-number"},[a._v("30")]),s("br"),s("span",{staticClass:"line-number"},[a._v("31")]),s("br"),s("span",{staticClass:"line-number"},[a._v("32")]),s("br"),s("span",{staticClass:"line-number"},[a._v("33")]),s("br"),s("span",{staticClass:"line-number"},[a._v("34")]),s("br"),s("span",{staticClass:"line-number"},[a._v("35")]),s("br"),s("span",{staticClass:"line-number"},[a._v("36")]),s("br"),s("span",{staticClass:"line-number"},[a._v("37")]),s("br")])]),s("p",[a._v("（2）实战中的使用")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("// 输出 key 为 1 的枚举值实例\nSeason season = Season.valueofKey(1);\n// 输出 SPRING 实例对应的 key\nInteger key = Season.SPRING.getKey();\n// 输出 SPRING 实例对应的 msg\nString msg = Season.SPRING.getMsg();\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br")])]),s("h2",{attrs:{id:"枚举类总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#枚举类总结"}},[a._v("#")]),a._v(" 枚举类总结")]),a._v(" "),s("p",[a._v("其实枚举类懂了其概念后，枚举就变得相当简单了，随手就可以写一个枚举类出来。所以如上几个实战小例子一定要先搞清楚概念，然后在练习几遍就 ok 了。")]),a._v(" "),s("p",[a._v("重要的概念，我在这里在赘述一遍，帮助老铁们快速掌握这块知识，首先记住，枚举类中的枚举值可以没有参数，也可以有多个参数，每一个枚举值都是一个实例；")]),a._v(" "),s("p",[a._v("并且还有一点很重要，就是如果枚举值有 n 个参数，那么构造函数中的参数值肯定有 n 个，因为声明的每一个枚举值都会调用构造函数去创建实例，所以参数一定是一一对应的；既然明白了这一点，那么我们只需要在枚举类中把这 n 个参数定义为 n 个成员变量，然后提供对应的 get() 方法，之后通过实例就可以随意的获取实例中的任意参数值了。")]),a._v(" "),s("p",[a._v("如果想让枚举类更加的好用，就可以模仿我在实战三中的写法那样，通过某一个参数值，比如 key 参数值，就能获取到其对应的枚举值，然后想要什么值，就 get 什么值就好了。")]),a._v(" "),s("h2",{attrs:{id:"枚举-api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#枚举-api"}},[a._v("#")]),a._v(" 枚举 API")]),a._v(" "),s("p",[a._v("我们使用 enum 定义的枚举类都是继承 java.lang.Enum 类的，那么就会继承其 API ，常用的 API 如下：")]),a._v(" "),s("ul",[s("li",[a._v("String name()")])]),a._v(" "),s("p",[a._v("获取枚举名称")]),a._v(" "),s("ul",[s("li",[a._v("int ordinal()")])]),a._v(" "),s("p",[a._v("获取枚举的位置（下标，初始值为 0 ）")]),a._v(" "),s("ul",[s("li",[a._v("valueof(String msg)")])]),a._v(" "),s("p",[a._v("通过 msg 获取其对应的枚举类型。（比如实战二中的枚举类或其它枚举类都行，只要使用得当都可以使用此方法）")]),a._v(" "),s("ul",[s("li",[a._v("values()")])]),a._v(" "),s("p",[a._v("获取枚举类中的所有枚举值（比如在实战三中就使用到了）")]),a._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),s("p",[a._v("枚举本质上是通过普通的类来实现的，只是编译器为我们进行了处理。"),s("strong",[a._v("每个枚举类型都继承自java.lang.Enum，并自动添加了values和valueOf方法。")])]),a._v(" "),s("p",[a._v("而每个枚举常量是一个静态常量字段，"),s("strong",[a._v("使用内部类实现")]),a._v("，该内部类继承了枚举类。"),s("strong",[a._v("所有枚举常量都通过静态代码块来进行初始化，即在类加载期间就初始化")]),a._v("。")]),a._v(" "),s("p",[a._v("另外通过把clone、readObject、writeObject这三个方法定义为final的，同时实现是抛出相应的异常。这样保证了每个枚举类型及枚举常量都是不可变的。"),s("strong",[a._v("可以利用枚举的这两个特性来实现线程安全的单例。")])]),a._v(" "),s("h2",{attrs:{id:"参考文章"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[a._v("#")]),a._v(" 参考文章")]),a._v(" "),s("p",[a._v("https://blog.csdn.net/qq_34988624/article/details/86592229\nhttps://www.meiwen.com.cn/subject/slhvhqtx.html\nhttps://blog.csdn.net/qq_34988624/article/details/86592229\nhttps://segmentfault.com/a/1190000012220863\nhttps://my.oschina.net/wuxinshui/blog/1511484\nhttps://blog.csdn.net/hukailee/article/details/81107412")]),a._v(" "),s("h2",{attrs:{id:"微信公众号"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#微信公众号"}},[a._v("#")]),a._v(" 微信公众号")]),a._v(" "),s("h3",{attrs:{id:"java技术江湖"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java技术江湖"}},[a._v("#")]),a._v(" Java技术江湖")]),a._v(" "),s("p",[a._v("如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，作者黄小斜，专注 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！")]),a._v(" "),s("p",[s("strong",[a._v("Java工程师必备学习资源:")]),a._v(" 一些Java工程师常用学习资源，关注公众号后，后台回复关键字 "),s("strong",[a._v("“Java”")]),a._v(" 即可免费无套路获取。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190805090108984.jpg",alt:"我的公众号"}})]),a._v(" "),s("h3",{attrs:{id:"个人公众号-黄小斜"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#个人公众号-黄小斜"}},[a._v("#")]),a._v(" 个人公众号：黄小斜")]),a._v(" "),s("p",[a._v("作者是 985 硕士，蚂蚁金服 JAVA 工程师，专注于 JAVA 后端技术栈：SpringBoot、MySQL、分布式、中间件、微服务，同时也懂点投资理财，偶尔讲点算法和计算机理论基础，坚持学习和写作，相信终身学习的力量！")]),a._v(" "),s("p",[s("strong",[a._v("程序员3T技术学习资源：")]),a._v(" 一些程序员学习技术的资源大礼包，关注公众号后，后台回复关键字 "),s("strong",[a._v("“资料”")]),a._v(" 即可免费无套路获取。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190829222750556.jpg",alt:""}})])])}),[],!1,null,null,null);n.default=t.exports}}]);