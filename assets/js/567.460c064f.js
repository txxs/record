(window.webpackJsonp=window.webpackJsonp||[]).push([[567],{961:function(n,a,t){"use strict";t.r(a);var v=t(13),s=Object(v.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[n._v("#")]),n._v(" 目录")]),n._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#java%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"}},[n._v("Java中的构造方法")]),n._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B"}},[n._v("构造方法简介")])]),n._v(" "),t("li",[t("a",{attrs:{href:"#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B"}},[n._v("构造方法实例")]),n._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%E4%BE%8B-1"}},[n._v("例 1")])]),n._v(" "),t("li",[t("a",{attrs:{href:"#%E4%BE%8B-2"}},[n._v("例 2")])])])])])]),n._v(" "),t("li",[t("a",{attrs:{href:"#java%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"}},[n._v("Java中的几种构造方法详解")]),n._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%E6%99%AE%E9%80%9A%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"}},[n._v("普通构造方法")])]),n._v(" "),t("li",[t("a",{attrs:{href:"#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"}},[n._v("默认构造方法")])]),n._v(" "),t("li",[t("a",{attrs:{href:"#%E9%87%8D%E8%BD%BD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"}},[n._v("重载构造方法")])]),n._v(" "),t("li",[t("a",{attrs:{href:"#java%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"}},[n._v("java子类构造方法调用父类构造方法")])])])]),n._v(" "),t("li",[t("a",{attrs:{href:"#java%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97%E7%AE%80%E4%BB%8B"}},[n._v("Java中的代码块简介")])]),n._v(" "),t("li",[t("a",{attrs:{href:"#java%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BD%BF%E7%94%A8"}},[n._v("Java代码块使用")]),n._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%E5%B1%80%E9%83%A8%E4%BB%A3%E7%A0%81%E5%9D%97"}},[n._v("局部代码块")])]),n._v(" "),t("li",[t("a",{attrs:{href:"#%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97"}},[n._v("构造代码块")])]),n._v(" "),t("li",[t("a",{attrs:{href:"#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"}},[n._v("静态代码块")])])])]),n._v(" "),t("li",[t("a",{attrs:{href:"#java%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%88%E5%8C%85%E5%90%AB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%89%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"}},[n._v("Java代码块、构造方法（包含继承关系）的执行顺序")])]),n._v(" "),t("li",[t("a",{attrs:{href:"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"}},[n._v("参考文章")])]),n._v(" "),t("li",[t("a",{attrs:{href:"#%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7"}},[n._v("微信公众号")]),n._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96"}},[n._v("Java技术江湖")])]),n._v(" "),t("li",[t("a",{attrs:{href:"#%E4%B8%AA%E4%BA%BA%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%BB%84%E5%B0%8F%E6%96%9C"}},[n._v("个人公众号：黄小斜")])])])])]),n._v(" "),t("p",[n._v("本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看")]),n._v(" "),t("blockquote",[t("p",[n._v("https://github.com/h2pl/Java-Tutorial")])]),n._v(" "),t("p",[n._v("喜欢的话麻烦点下Star哈")]),n._v(" "),t("p",[n._v("文章首发于我的个人博客：")]),n._v(" "),t("blockquote",[t("p",[n._v("www.how2playlife.com")])]),n._v(" "),t("p",[n._v("本文是微信公众号【Java技术江湖】的《夯实Java基础系列博文》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。\n该系列博文会告诉你如何从入门到进阶，一步步地学习Java基础知识，并上手进行实战，接着了解每个Java知识点背后的实现原理，更完整地了解整个Java技术体系，形成自己的知识框架。为了更好地总结和检验你的学习成果，本系列文章也会提供每个知识点对应的面试题以及参考答案。")]),n._v(" "),t("p",[n._v("如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。")]),n._v(" "),t("h2",{attrs:{id:"java中的构造方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java中的构造方法"}},[n._v("#")]),n._v(" Java中的构造方法")]),n._v(" "),t("h3",{attrs:{id:"构造方法简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造方法简介"}},[n._v("#")]),n._v(" 构造方法简介")]),n._v(" "),t("p",[n._v("构造方法是类的一种特殊方法，用来初始化类的一个新的对象。"),t("a",{attrs:{href:"http://c.biancheng.net/java/",target:"_blank",rel:"noopener noreferrer"}},[n._v("Java"),t("OutboundLink")],1),n._v(" 中的每个类都有一个默认的构造方法，它必须具有和类名相同的名称，而且没有返回类型。构造方法的默认返回类型就是对象类型本身，并且构造方法不能被 static、final、synchronized、abstract 和 native 修饰。")]),n._v(" "),t("p",[n._v("提示：构造方法用于初始化一个新对象，所以用 static 修饰没有意义；构造方法不能被子类继承，所以用 final 和 abstract 修饰没有意义；多个线程不会同时创建内存地址相同的同一个对象，所以用 synchronized 修饰没有必要。")]),n._v(" "),t("p",[n._v("构造方法的语法格式如下：")]),n._v(" "),t("pre",[n._v("class class_name\n{\n    public class_name(){}    //默认无参构造方法\n    public ciass_name([paramList]){}    //定义构造方法\n    …\n    //类主体\n}")]),n._v(" "),t("p",[n._v("在一个类中，与类名相同的方法就是构造方法。每个类可以具有多个构造方法，但要求它们各自包含不同的方法参数。")]),n._v(" "),t("h3",{attrs:{id:"构造方法实例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造方法实例"}},[n._v("#")]),n._v(" 构造方法实例")]),n._v(" "),t("h4",{attrs:{id:"例-1"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#例-1"}},[n._v("#")]),n._v(" 例 1")]),n._v(" "),t("p",[n._v("构造方法主要有无参构造方法和有参构造方法两种，示例如下：")]),n._v(" "),t("pre",[n._v("public class MyClass\n{\n    private int m;    //定义私有变量\n    MyClass()\n    {\n        //定义无参的构造方法\n        m=0;\n    }\n    MyCiass(int m)\n    {\n        //定义有参的构造方法\n        this.m=m;\n    }\n}")]),n._v(" "),t("p",[n._v("该示例定义了两个构造方法，分别是无参构造方法和有参构造方法。在一个类中定义多个具有不同参数的同名方法，这就是方法的重载。这两个构造方法的名称都与类名相同，均为 MyClass。在实例化该类时可以调用不同的构造方法进行初始化。")]),n._v(" "),t("p",[n._v("注意：类的构造方法不是要求必须定义的。如果在类中没有定义任何一个构造方法，则 Java 会自动为该类生成一个默认的构造方法。默认的构造方法不包含任何参数，并且方法体为空。如果类中显式地定义了一个或多个构造方法，则 Java 不再提供默认构造方法。")]),n._v(" "),t("h4",{attrs:{id:"例-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#例-2"}},[n._v("#")]),n._v(" 例 2")]),n._v(" "),t("p",[n._v("要在不同的条件下使用不同的初始化行为创建类的对象，这时候就需要在一个类中创建多个构造方法。下面通过一个示例来演示构造方法的使用。")]),n._v(" "),t("p",[n._v("(1) 首先在员工类 Worker 中定义两个构造方法，代码如下：")]),n._v(" "),t("pre",[n._v('public class Worker\n{\n    public String name;    //姓名\n    private int age;    //年龄\n    //定义带有一个参数的构造方法\n    public Worker(String name)\n    {\n        this.name=name;\n    }\n    //定义带有两个参数的构造方法\n    public Worker(String name,int age)\n    {\n        this.name=name;\n        this.age=age;\n    }\n    public String toString()\n    {\n        return"大家好！我是新来的员工，我叫"+name+"，今年"+age+"岁。";\n    }\n}')]),n._v(" "),t("p",[n._v("在 Worker 类中定义了两个属性，其中 name 属性不可改变。分别定义了带有一个参数和带有两个参数的构造方法，并对其属性进行初始化。最后定义了该类的 toString() 方法，返回一条新进员工的介绍语句。")]),n._v(" "),t("p",[n._v("提示：Object 类具有一个 toString() 方法，该方法是个特殊的方法，创建的每个类都会继承该方法，它返回一个 String 类型的字符串。如果一个类中定义了该方法，则在调用该类对象时，将会自动调用该类对象的 toString() 方法返回一个字符串，然后使用“System.out.println(对象名)”就可以将返回的字符串内容打印出来。")]),n._v(" "),t("p",[n._v("(2) 在 TestWorker 类中创建 main() 方法作为程序的入口处，在 main() 方法中调用不同的构造方法实例化 Worker 对象，并对该对象中的属性进行初始化，代码如下：")]),n._v(" "),t("pre",[n._v('public class TestWorker\n{\n    public static void main(String[] args)\n    {\n        System.out.println("-----------带有一个参数的构造方法-----------");\n        //调用带有一个参数的构造方法，Staff类中的sex和age属性值不变\n        Worker worker1=new Worker("张强");\n        System.out.println(worker1);\n        System.out.println("-----------带有两个参数的构造方法------------");\n        //调用带有两个参数的构造方法，Staff类中的sex属性值不变\n        Worker worker2=new Worker("李丽",25);\n        System.out.println(worker2);\n    }\n}')]),n._v(" "),t("p",[n._v("在上述代码中，创建了两个不同的 Worker 对象：一个是姓名为张强的员工对象，一个是姓名为李丽、年龄为 25 的员工对象。对于第一个 Worker 对象 Worker1，并未指定 age 属性值，因此程序会将其值采用默认值 0。对于第二个 Worker 对象 Worker2，分别对其指定了 name 属性值和 age 属性值，因此程序会将传递的参数值重新赋值给 Worker 类中的属性值。")]),n._v(" "),t("p",[n._v("运行 TestWorker 类，输出的结果如下：")]),n._v(" "),t("pre",[n._v("-----------带有一个参数的构造方法-----------\n大家好！我是新来的员工，我叫张强，今年0岁。\n-----------带有两个参数的构造方法------------\n大家好！我是新来的员工，我叫李丽，今年25岁。")]),n._v(" "),t("p",[n._v("通过调用带参数的构造方法，在创建对象时，一并完成了对象成员的初始化工作，简化了对象初始化的代码。")]),n._v(" "),t("h2",{attrs:{id:"java中的几种构造方法详解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java中的几种构造方法详解"}},[n._v("#")]),n._v(" Java中的几种构造方法详解")]),n._v(" "),t("h3",{attrs:{id:"普通构造方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#普通构造方法"}},[n._v("#")]),n._v(" 普通构造方法")]),n._v(" "),t("p",[n._v("方法名与类名相同")]),n._v(" "),t("p",[n._v("无返回类型")]),n._v(" "),t("p",[n._v("子类不能继承父类的构造方法")]),n._v(" "),t("p",[n._v("不能被static、final、abstract修饰（有final和static修饰的是不能被子类继承的，abstract修饰的是抽象类，抽象类是不能实例化的，也就是不能new）")]),n._v(" "),t("p",[n._v("可以被private修饰，可以在本类里面实例化，但是外部不能实例化对象（注意！！！）")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("public class A{\n    int i=0;\n    public A(){\n        i=2;\n    }\n    public A(int i){\n        this.i=i;\n    }\n}\n")])])]),t("h3",{attrs:{id:"默认构造方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#默认构造方法"}},[n._v("#")]),n._v(" 默认构造方法")]),n._v(" "),t("p",[n._v("如果没有任何的构造方法，编译时系统会自动添加一个默认无参构造方法")]),n._v(" "),t("p",[n._v("隐含的默认构造方法")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("    public A(){}\n")])])]),t("p",[n._v("显示的默认构造方法")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('    public A(){\n    System.out.print("显示的默认构造方法")\n    }\n')])])]),t("h3",{attrs:{id:"重载构造方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重载构造方法"}},[n._v("#")]),n._v(" 重载构造方法")]),n._v(" "),t("p",[n._v("比如原本的类里的构造方法是一个参数的，现在新建的对象是有三个参数，此时就要重载构造方法")]),n._v(" "),t("p",[n._v("当一个类中有多个构造方法，有可能会出现重复性操作，这时可以用this语句调用其他的构造方法。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('public class A{\n    private int age;\n    private String name;\n    public A(int age,String name){\n        this.age=age;\n        this.name=name;\n    }\n    public A(int age){\n        this(age,"无名氏");//调用 A(int age,String name)构造方法\n    }\n    public A(){\n        this(1);//调用 A(int age)构造方法\n    }\n    public void setName(String name) {this.name=name;}\n    public String getName() {return name;}\n    public void setAge(int age) {this.age=age;}\n    public int getAge() {return age;}\n}\n\nA a=new A(20,"周一");\nA b=new A(20);\nA c=new A();\nString name = a.getName();\nString name1 = b.getName();\nint age = c.getAge();\nSystem.out.println(name);\nSystem.out.println(name1);\nSystem.out.println(age);\n')])])]),t("h3",{attrs:{id:"java子类构造方法调用父类构造方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java子类构造方法调用父类构造方法"}},[n._v("#")]),n._v(" java子类构造方法调用父类构造方法")]),n._v(" "),t("p",[n._v("首先父类构造方法是绝对不能被子类继承的。")]),n._v(" "),t("p",[n._v("子类构造方法调用父类的构造方法重点是：子类构造方法无论如何都要调用父类的构造方法。")]),n._v(" "),t("p",[n._v("子类构造方法要么调用父类无参构造方法（包括当父类没有构造方法时。系统默认给的无参构造方法），要么调用父类有参构造方法。当子类构造方法调用父类无参构造方法，一般都是默认不写的，要写的话就是super（），且要放在构造方法的第一句。当子类构造方法要调用父类有参数的构造方法，那么子类的构造方法中必须要用super（参数）调用父类构造方法，且要放在构造方法的第一句。")]),n._v(" "),t("p",[n._v("当子类的构造方法是无参构造方法时，必须调用父类无参构造方法。因为系统会自动找父类有没有无参构造方法，如果没有的话系统会报错：说父类没有定义无参构造方法。")]),n._v(" "),t("p",[n._v("当子类构造方法是有参构造方法时，这时就会有两种情况。\n第一种：子类构造方法没有写super，也就是说你默认调用父类无参构造方法，这样的话就和子类是无参构造方法一样。")]),n._v(" "),t("p",[n._v("第二种：子类构造方法有super（参数）时，就是调用父类有参构造方法，系统会找父类有没有参数一致（参数数量，且类型顺序要相同）的有参构造方法，如果没有的话，同样也会报错。")]),n._v(" "),t("p",[n._v("但是这里会遇到和重载构造方法this一样问题，一个参数的构造方法可以调用多个参数构造方法，没有的参数给一个自己定义值也是可以的。")]),n._v(" "),t("h2",{attrs:{id:"java中的代码块简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java中的代码块简介"}},[n._v("#")]),n._v(" Java中的代码块简介")]),n._v(" "),t("p",[n._v("在java中用{}括起来的称为代码块，代码块可分为以下四种：")]),n._v(" "),t("p",[t("strong",[n._v("一.简介")])]),n._v(" "),t("p",[t("strong",[n._v("1.普通代码块：")])]),n._v(" "),t("p",[n._v("类中方法的方法体")]),n._v(" "),t("p",[t("strong",[n._v("2.构造代码块")]),n._v("：")]),n._v(" "),t("p",[n._v("构造块会在创建对象时被调用，每次创建时都会被调用，优先于类构造函数执行。")]),n._v(" "),t("p",[t("strong",[n._v("3.静态代码块：")])]),n._v(" "),t("p",[n._v("用static{}包裹起来的代码片段，只会执行一次。静态代码块优先于构造块执行。")]),n._v(" "),t("p",[t("strong",[n._v("4.同步代码块：")])]),n._v(" "),t("p",[n._v("使用synchronized（）{}包裹起来的代码块，在多线程环境下，对共享数据的读写操作是需要互斥进行的，否则会导致数据的不一致性。同步代码块需要写在方法中。")]),n._v(" "),t("p",[t("strong",[n._v("二.静态代码块和构造代码块的异同点")])]),n._v(" "),t("p",[n._v("相同点：都是JVM加载类后且在构造函数执行之前执行，在类中可定义多个，一般在代码块中对一些static变量进行赋值。")]),n._v(" "),t("p",[n._v("不同点：静态代码块在非静态代码块之前执行。静态代码块只在第一次new时执行一次，之后不在执行。而非静态代码块每new一次就执行一次。")]),n._v(" "),t("h2",{attrs:{id:"java代码块使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java代码块使用"}},[n._v("#")]),n._v(" Java代码块使用")]),n._v(" "),t("h3",{attrs:{id:"局部代码块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#局部代码块"}},[n._v("#")]),n._v(" 局部代码块")]),n._v(" "),t("blockquote",[t("p",[n._v("位置：局部位置（方法内部）")])]),n._v(" "),t("blockquote",[t("p",[n._v("作用：限定变量的生命周期，尽早释放，节约内存")])]),n._v(" "),t("blockquote",[t("p",[n._v("调用：调用其所在的方法时执行")])]),n._v(" "),t("p",[n._v("​")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v(' public class 局部代码块 {\n@Test\npublic void test (){\n    B b = new B();\n    b.go();\n}\n}\nclass B {\n    B(){}\n    public void go() {\n        //方法中的局部代码块，一般进行一次性地调用，调用完立刻释放空间，避免在接下来的调用过程中占用栈空间\n        //因为栈空间内存是有限的，方法调用可能会会生成很多局部变量导致栈内存不足。\n        //使用局部代码块可以避免这样的情况发生。\n        {\n            int i = 1;\n            ArrayList<Integer> list = new ArrayList<>();\n            while (i < 1000) {\n                list.add(i ++);\n            }\n            for (Integer j : list) {\n                System.out.println(j);\n            }\n            System.out.println("gogogo");\n        }\n        System.out.println("hello");\n    }\n}\n')])])]),t("h3",{attrs:{id:"构造代码块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造代码块"}},[n._v("#")]),n._v(" 构造代码块")]),n._v(" "),t("blockquote",[t("p",[n._v("位置：类成员的位置，就是类中方法之外的位置")])]),n._v(" "),t("blockquote",[t("p",[n._v("作用：把多个构造方法共同的部分提取出来，共用构造代码块")])]),n._v(" "),t("blockquote",[t("p",[n._v("调用：每次调用构造方法时，都会优先于构造方法执行，也就是每次new一个对象时自动调用，对  对象的初始化")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('class A{\n    int i = 1;\n    int initValue;//成员变量的初始化交给代码块来完成\n    {\n        //代码块的作用体现于此：在调用构造方法之前，用某段代码对成员变量进行初始化。\n        //而不是在构造方法调用时再进行。一般用于将构造方法的相同部分提取出来。\n        //\n        for (int i = 0;i < 100;i ++) {\n            initValue += i;\n        }\n    }\n    {\n        System.out.println(initValue);\n        System.out.println(i);//此时会打印1\n        int i = 2;//代码块里的变量和成员变量不冲突，但会优先使用代码块的变量\n        System.out.println(i);//此时打印2\n        //System.out.println(j);//提示非法向后引用，因为此时j的的初始化还没开始。\n        //\n    }\n    {\n        System.out.println("代码块运行");\n    }\n    int j = 2;\n    {\n        System.out.println(j);\n        System.out.println(i);//代码块中的变量运行后自动释放，不会影响代码块之外的代码\n    }\n    A(){\n        System.out.println("构造方法运行");\n    }\n}\npublic class 构造代码块 {\n    @Test\n    public void test() {\n        A a = new A();\n    }\n}\n')])])]),t("h3",{attrs:{id:"静态代码块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#静态代码块"}},[n._v("#")]),n._v(" 静态代码块")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v(' 位置：类成员位置，用static修饰的代码块\n\n 作用：对类进行一些初始化  只加载一次，当new多个对象时，只有第一次会调用静态代码块，因为，静态代码块                  是属于类的，所有对象共享一份\n\n 调用: new 一个对象时自动调用\n\n public class 静态代码块 {\n\n@Test\npublic void test() {\n    C c1 = new C();\n    C c2 = new C();\n    //结果,静态代码块只会调用一次，类的所有对象共享该代码块\n    //一般用于类的全局信息初始化\n    //静态代码块调用\n    //代码块调用\n    //构造方法调用\n    //代码块调用\n    //构造方法调用\n}\n\n}\nclass C{\n    C(){\n        System.out.println("构造方法调用");\n    }\n    {\n        System.out.println("代码块调用");\n    }\n    static {\n        System.out.println("静态代码块调用");\n    }\n}\n')])])]),t("h2",{attrs:{id:"java代码块、构造方法-包含继承关系-的执行顺序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java代码块、构造方法-包含继承关系-的执行顺序"}},[n._v("#")]),n._v(" Java代码块、构造方法（包含继承关系）的执行顺序")]),n._v(" "),t("p",[n._v("这是一道常见的面试题，要回答这个问题，先看看这个实例吧。")]),n._v(" "),t("p",[n._v("一共3个类：A、B、C\n其中A是B的父类，C无继承仅作为输出")]),n._v(" "),t("p",[n._v("A类：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('public class A {\n\nstatic {\n    Log.i("HIDETAG", "A静态代码块");\n}\n\nprivate static C c = new C("A静态成员");\nprivate  C c1 = new C("A成员");\n\n{\n    Log.i("HIDETAG", "A代码块");\n}\n\nstatic {\n    Log.i("HIDETAG", "A静态代码块2");\n}\n\npublic A() {\n    Log.i("HIDETAG", "A构造方法");\n}\n\n}\n')])])]),t("p",[n._v("B类：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('public class B extends A {\n\nprivate static C c1 = new C("B静态成员");\n\n{\n    Log.i("HIDETAG", "B代码块");\n}\n\nprivate C c = new C("B成员");\n\nstatic {\n    Log.i("HIDETAG", "B静态代码块2");\n}\n\nstatic {\n    Log.i("HIDETAG", "B静态代码块");\n}\n\npublic B() {\n    Log.i("HIDETAG", "B构造方法");\n\n}\n\n}\n')])])]),t("p",[n._v("C类：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('public class C {\n\npublic C(String str) {\n    Log.i("HIDETAG", str + "构造方法");\n}\n}\n')])])]),t("p",[n._v("执行语句：new B();")]),n._v(" "),t("p",[n._v("输出结果如下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v(" I/HIDETAG: A静态代码块\n I/HIDETAG: A静态成员构造方法\n I/HIDETAG: A静态代码块2\n I/HIDETAG: B静态成员构造方法\n I/HIDETAG: B静态代码块2\n I/HIDETAG: B静态代码块\n I/HIDETAG: A成员构造方法\n I/HIDETAG: A代码块\n I/HIDETAG: A构造方法\n I/HIDETAG: B代码块\n I/HIDETAG: B成员构造方法\n I/HIDETAG: B构造方法\n")])])]),t("p",[n._v("得出结论：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("执行顺序依次为：\n父类的静态成员和代码块\n子类静态成员和代码块\n父类成员初始化和代码快\n父类构造方法\n子类成员初始化和代码块\n子类构造方法\n")])])]),t("p",[n._v("注意：可以发现，同一级别的代码块和成员初始化是按照代码顺序从上到下依次执行")]),n._v(" "),t("p",[t("strong",[n._v("看完上面这个demo，再来看看下面这道题，看看你搞得定吗？")])]),n._v(" "),t("p",[n._v("看下面一段代码，求执行顺序：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('class A {\n    public A() {\n        System.out.println("1A类的构造方法");\n    }\n    {\n        System.out.println("2A类的构造快");\n    }\n    static {\n        System.out.println("3A类的静态块");\n    }\n}\n \npublic class B extends A {\n    public B() {\n        System.out.println("4B类的构造方法");\n    }\n    {\n        System.out.println("5B类的构造快");\n    }\n    static {\n        System.out.println("6B类的静态块");\n    }\n    public static void main(String[] args) {\n        System.out.println("7");\n        new B();\n        new B();\n        System.out.println("8");\n    }\n}\n')])])]),t("p",[n._v("执行顺序结果为：367215421548")]),n._v(" "),t("p",[n._v("为什么呢？")]),n._v(" "),t("p",[n._v("首先我们要知道下面这5点：")]),n._v(" "),t("p",[n._v("每次new都会执行构造方法以及构造块。\n构造块的内容会在构造方法之前执行。\n非主类的静态块会在类加载时，构造方法和构造块之前执行，切只执行一次。\n主类（public class）里的静态块会先于main执行。\n继承中，子类实例化，会先执行父类的构造方法，产生父类对象，再调用子类构造方法。\n所以题目里，由于主类B继承A，所以会先加载A，所以第一个执行的是第3句。")]),n._v(" "),t("p",[n._v("从第4点我们知道6会在7之前执行，所以前三句是367。")]),n._v(" "),t("p",[n._v("之后实例化了B两次，每次都会先实例化他的父类A，然后再实例化B，而根据第1、2、5点，知道顺序为2154。")]),n._v(" "),t("p",[n._v("最后执行8")]),n._v(" "),t("p",[n._v("所以顺序是367215421548")]),n._v(" "),t("h2",{attrs:{id:"参考文章"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[n._v("#")]),n._v(" 参考文章")]),n._v(" "),t("p",[n._v("https://blog.csdn.net/likunkun__/article/details/83066062\nhttps://www.jianshu.com/p/6877aae403f7\nhttps://www.jianshu.com/p/49e45af288ea\nhttps://blog.csdn.net/du_du1/article/details/91383128\nhttp://c.biancheng.net/view/976.html\nhttps://blog.csdn.net/evilcry2012/article/details/79499786\nhttps://www.jb51.net/article/129990.htm")]),n._v(" "),t("h2",{attrs:{id:"微信公众号"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#微信公众号"}},[n._v("#")]),n._v(" 微信公众号")]),n._v(" "),t("h3",{attrs:{id:"java技术江湖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java技术江湖"}},[n._v("#")]),n._v(" Java技术江湖")]),n._v(" "),t("p",[n._v("如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，作者黄小斜，专注 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！")]),n._v(" "),t("p",[t("strong",[n._v("Java工程师必备学习资源:")]),n._v(" 一些Java工程师常用学习资源，关注公众号后，后台回复关键字 "),t("strong",[n._v("“Java”")]),n._v(" 即可免费无套路获取。")]),n._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190805090108984.jpg",alt:"我的公众号"}})]),n._v(" "),t("h3",{attrs:{id:"个人公众号-黄小斜"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#个人公众号-黄小斜"}},[n._v("#")]),n._v(" 个人公众号：黄小斜")]),n._v(" "),t("p",[n._v("作者是 985 硕士，蚂蚁金服 JAVA 工程师，专注于 JAVA 后端技术栈：SpringBoot、MySQL、分布式、中间件、微服务，同时也懂点投资理财，偶尔讲点算法和计算机理论基础，坚持学习和写作，相信终身学习的力量！")]),n._v(" "),t("p",[t("strong",[n._v("程序员3T技术学习资源：")]),n._v(" 一些程序员学习技术的资源大礼包，关注公众号后，后台回复关键字 "),t("strong",[n._v("“资料”")]),n._v(" 即可免费无套路获取。")]),n._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190829222750556.jpg",alt:""}})])])}),[],!1,null,null,null);a.default=s.exports}}]);