(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{463:function(v,_,t){"use strict";t.r(_);var s=t(13),r=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"_035-亿级流量商品详情页的多级缓存架构以及架构中每一层的意义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_035-亿级流量商品详情页的多级缓存架构以及架构中每一层的意义"}},[v._v("#")]),v._v(" 035. 亿级流量商品详情页的多级缓存架构以及架构中每一层的意义")]),v._v(" "),t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#商品详情系统旁白"}},[v._v("商品详情系统旁白")])]),t("li",[t("a",{attrs:{href:"#上亿流量的商品详情页系统的多级缓存架构"}},[v._v("上亿流量的商品详情页系统的多级缓存架构")])]),t("li",[t("a",{attrs:{href:"#多级缓存架构中每一层的意义"}},[v._v("多级缓存架构中每一层的意义")])]),t("li",[t("a",{attrs:{href:"#小结"}},[v._v("小结")])])])]),t("p"),v._v(" "),t("p",[v._v("我们之前的三十讲，主要是在讲解 redis 如何支撑海量数据、高并发读写、高可用服务的架构")]),v._v(" "),t("p",[v._v("redis 架构，在我们的真正类似商品详情页读高并发的系统中，redis 就是底层的缓存存储的支持")]),v._v(" "),t("p",[v._v("从这一讲开始，我们正式开始做业务系统的开发")]),v._v(" "),t("h2",{attrs:{id:"商品详情系统旁白"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#商品详情系统旁白"}},[v._v("#")]),v._v(" 商品详情系统旁白")]),v._v(" "),t("p",[v._v("亿级流量以上的电商网站的商品详情页的系统，真实的系统中包含大量的业务，十几个人做一两年才堆出来复杂的业务系统。")]),v._v(" "),t("p",[v._v("而作为本课程不可能讲解复杂的业务，因为整套课程就几十个小时的课程。")]),v._v(" "),t("p",[v._v("如果只是纯粹的架构，那么就是一个骨架，所以必须有少量的业务，有血有肉，把整个项目串起来，在业务背景下去学习架构，效果才会理想")]),v._v(" "),t("p",[v._v("讲解商品详情页系统，主要讲解缓存架构，90% 大量的业务代码（没有什么技术含量），10% 的最优技术含量的就是架构，上亿流量，每秒 QPS 几万，上十万的，读并发")]),v._v(" "),t("p",[v._v("支撑读并发，主要是缓存架构")]),v._v(" "),t("h2",{attrs:{id:"上亿流量的商品详情页系统的多级缓存架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#上亿流量的商品详情页系统的多级缓存架构"}},[v._v("#")]),v._v(" 上亿流量的商品详情页系统的多级缓存架构")]),v._v(" "),t("p",[v._v("很多人以为，做个缓存其实就是用一下 redis 访问一下，就可以了，这个只是简单的缓存")]),v._v(" "),t("p",[v._v("如果做复杂的缓存，支撑电商复杂的场景下的高并发的缓存，遇到的问题非常非常之多，绝对不是说简单的访问一下 redsi 就可以的")]),v._v(" "),t("p",[v._v("采用三级缓存：nginx 本地缓存 + redis 分布式缓存 + tomcat 堆缓存的多级缓存架构")]),v._v(" "),t("p",[v._v("使用这个架构主要是为了解决业务中的一些需求和问题：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("时效性要求非常高的数据：库存")]),v._v(" "),t("p",[v._v("一般来说，显示的库存都是时效性要求会相对高一些，因为随着商品的不断的交易，库存会不断的变化")]),v._v(" "),t("p",[v._v("当然，我们就希望当库存变化的时候，尽可能更快将库存显示到页面上去，而不是说等了很长时间，库存才反应到页面上去")])]),v._v(" "),t("li",[t("p",[v._v("时效性要求不高的数据：商品的基本信息（名称、颜色、版本、规格参数，等等）")]),v._v(" "),t("p",[v._v("比如你现在改变了商品的名称，稍微晚个几分钟反应到商品页面上，也还能接受")])])]),v._v(" "),t("p",[v._v("商品价格/库存等 "),t("strong",[v._v("时效性要求高")]),v._v(" 的数据，而且种类较少，采取相关的服务系统每次发生了变更的时候，直接采取数据库和 redis 缓存双写的方案，这样缓存的时效性最高")]),v._v(" "),t("p",[v._v("商品基本信息等 "),t("strong",[v._v("时效性不高")]),v._v(" 的数据，而且种类繁多，来自多种不同的系统，采取 MQ 异步通知的方式，写一个数据生产服务，监听 MQ 消息，然后异步拉取服务的数据，更新 tomcat jvm 缓存 + redis 缓存")]),v._v(" "),t("p",[v._v("nginx+lua 脚本做页面动态生成的工作，每次请求过来，优先从 nginx 本地缓存中提取各种数据，结合页面模板，生成需要的页面，如果 nginx 本地缓存过期了，那么就从 nginx 到 redis 中去拉取数据，更新到 nginx 本地，如果 redis 中也被 LRU 算法清理掉了，那么就从 nginx走 http 接口到后端的服务中拉取数据，数据生产服务中，现在本地 tomcat 里的 jvm 堆缓存（ehcache）中找，如果也被 LRU 清理掉了，那么就重新发送请求到源头的服务中去拉取数据，然后再次更新 tomcat 堆内存缓存 + redis 缓存，并返回数据给 nginx，nginx 缓存到本地")]),v._v(" "),t("p",[t("img",{attrs:{src:"assets/markdown-img-paste-20190331203045365.png",alt:""}})]),v._v(" "),t("p",[v._v("结合上图去理解上面的文字，该架构 redis 不是应用服务主要使用的，是 nginx 通过 lua 脚本主要使用的缓存")]),v._v(" "),t("h2",{attrs:{id:"多级缓存架构中每一层的意义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多级缓存架构中每一层的意义"}},[v._v("#")]),v._v(" 多级缓存架构中每一层的意义")]),v._v(" "),t("p",[t("strong",[v._v("nginx 本地缓存")]),v._v("，抗的是热数据的高并发访问，一般来说，商品的购买总是有热点的，比如每天购买 iphone、nike、海尔等知名品牌的东西的人，总是比较多的")]),v._v(" "),t("p",[v._v("这些热数据，利用 nginx 本地缓存，由于经常被访问，所以可以被锁定在 nginx 的本地缓存内")]),v._v(" "),t("p",[v._v("大量的热数据的访问，就是经常会访问的那些数据，就会被保留在 nginx 本地缓存内，那么对这些热数据的大量访问，就直接走 nginx 就可以了")]),v._v(" "),t("p",[v._v("那么大量的访问，直接就可以走到 nginx 就行了，不需要走后续的各种网络开销了")]),v._v(" "),t("p",[v._v("传统的缓存架构如下图（我自己就是这种使用的）")]),v._v(" "),t("p",[t("img",{attrs:{src:"assets/markdown-img-paste-20190331203423381.png",alt:""}})]),v._v(" "),t("p",[v._v("这样就会多出来转发的网络开销。而 nginx 直接走 redis + 本地缓存就少了很多的网络开销")]),v._v(" "),t("p",[t("strong",[v._v("redis 分布式大规模缓存")]),v._v("，抗的是很高的离散访问，支撑海量的数据，高并发的访问，高可用的服务")]),v._v(" "),t("p",[v._v("redis 缓存最大量的数据，最完整的数据和缓存，1T+ 数据; 支撑高并发的访问，QPS 最高到几十万; 可用性，非常好，提供非常稳定的服务")]),v._v(" "),t("p",[v._v("因为 nginx 本地内存有限，也就能 cache 住部分热数据，除了各种 iphone、nike 等热数据，其他相对不那么热的数据，可能流量会经常走到 redis 中")]),v._v(" "),t("p",[v._v("利用 redis cluster 的多 master 写入，横向扩容，1T+ 以上海量数据支持，几十万的读写 QPS，99.99% 高可用性，那么就可以抗住大量的离散访问请求")]),v._v(" "),t("p",[t("strong",[v._v("tomcat jvm 堆内存缓存")]),v._v("，主要是抗 redis 大规模灾难的，如果 redis 出现了大规模的宕机，导致 nginx 大量流量直接涌入数据生产服务，那么最后的 tomcat 堆内存缓存至少可以再抗一下，不至于让数据库直接裸奔")]),v._v(" "),t("p",[v._v("同时 tomcat jvm 堆内存缓存，也可以抗住 redis 没有 cache 住的最后那少量的部分缓存")]),v._v(" "),t("h2",{attrs:{id:"小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[v._v("#")]),v._v(" 小结")]),v._v(" "),t("p",[v._v("针对高并发访问的一些特点，进行了拆分：")]),v._v(" "),t("ul",[t("li",[v._v("nginx 本地缓存：抗少量热数据请求")]),v._v(" "),t("li",[v._v("redis：抗最完整最全量的离散访问请求")]),v._v(" "),t("li",[v._v("应用堆内存：安全防护措施，防止 mysql 数据库裸奔")])])])}),[],!1,null,null,null);_.default=r.exports}}]);